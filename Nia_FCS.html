<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Nia Frame Capture Studio</title>
  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cairo+Play:wght@400&family=Inter:wght@400;500;600&family=Source+Code+Pro:wght@400&display=swap" rel="stylesheet">
  <!-- Remix Icons for UI -->
  <link href="https://cdn.jsdelivr.net/npm/remixicon@3.5.0/fonts/remixicon.css" rel="stylesheet">
  <!-- JSZip -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    :root {
      /* --- Dark Theme: Deep Ocean (Compact Version) --- */
      --bg-primary: #0a0f1f;
      --bg-secondary: #161d31;
      --bg-tertiary: #242c44;
      --text-primary: #e0e6f7;
      --text-secondary: #aeb9dd;
      --text-tertiary: #8a94b6;
      --border-color: #3a4466;
      --border-dashed: #525c8f;

      /* Accents */
      --accent-primary: #00c6ff;
      --accent-primary-dark: #00a8ff;
      --accent-secondary: #5eead4;
      --accent-secondary-dark: #2dd4bf;
      --accent-tertiary: #ff8cdc;
      --accent-tertiary-dark: #ff6ac1;
      --accent-interval: #9a6eff;
      --accent-interval-dark: #855bff;
      --danger-color: #f43f5e;
      --danger-color-dark: #e11d48;

      /* Gradients */
      --gradient-primary: linear-gradient(90deg, var(--accent-primary), var(--accent-primary-dark));
      --gradient-secondary: linear-gradient(90deg, var(--accent-secondary), var(--accent-secondary-dark));
      --gradient-tertiary: linear-gradient(90deg, var(--accent-tertiary), var(--accent-tertiary-dark));
      --gradient-interval: linear-gradient(90deg, var(--accent-interval), var(--accent-interval-dark));
      --gradient-danger: linear-gradient(90deg, var(--danger-color), var(--danger-color-dark));
      --gradient-disabled: linear-gradient(90deg, var(--bg-tertiary), var(--bg-tertiary));

      /* Base Styles */
      --white: #ffffff;
      --black: #000000;
      --glitch-cyan: rgba(0, 255, 255, 0.7);
      --glitch-magenta: rgba(255, 0, 255, 0.7);

      /* Layout & Sizing (Compact) */
      --border-radius-sm: 3px;
      --border-radius-md: 6px;
      --border-radius-lg: 10px;
      --border-radius-full: 9999px;
      --content-padding: 1.25rem;
      --settings-column-width: 460px;
      --scrollbar-width: 8px;
      --separator-width: 2px;

      /* Add a data font class for numerical values */
      --data-font: 'Source Code Pro', monospace;
    }

    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    body { background-color: var(--bg-primary); color: var(--text-primary); font-family: 'Inter', "Helvetica Neue", Arial, sans-serif; line-height: 1.5; font-size: 15px; min-height: 100vh; display: flex; overflow: hidden; }
    html, body { margin: 0; padding: 0; width: 100%; height: 100%; }

    /* Scrollbar Styling */
    ::-webkit-scrollbar { width: var(--scrollbar-width); height: var(--scrollbar-width); }
    ::-webkit-scrollbar-track { background: var(--bg-secondary); border-radius: var(--border-radius-full); }
    ::-webkit-scrollbar-thumb { background-color: var(--bg-tertiary); border-radius: var(--border-radius-full); border: 1px solid var(--bg-secondary); }
    ::-webkit-scrollbar-thumb:hover { background-color: var(--border-color); }
    * { scrollbar-width: thin; scrollbar-color: var(--bg-tertiary) var(--bg-secondary); }

    /* Layout */
    .app-container { flex: 1; display: flex; position: relative; width: 100%; height: 100%; overflow: hidden; }
    .vertical-separator { position: absolute; top: 0; bottom: 0; left: var(--settings-column-width); width: var(--separator-width); background-image: linear-gradient(to bottom, var(--border-dashed) 60%, transparent 40%); background-size: 100% 8px; background-repeat: repeat-y; z-index: 10; pointer-events: none; transition: background-image 0.3s ease; }
    .vertical-separator.loading { background-image: linear-gradient(to bottom, var(--accent-interval) 60%, transparent 40%); background-size: 100% 12px; animation: loadingAnimation 10s linear infinite; }
    .vertical-separator.loading-smart { background-image: linear-gradient(to bottom, var(--accent-secondary) 60%, transparent 40%); background-size: 100% 12px; animation: loadingAnimation 10s linear infinite; }
    .vertical-separator.loading-contact-sheet { background-image: linear-gradient(to bottom, var(--accent-tertiary) 60%, transparent 40%); background-size: 100% 12px; animation: loadingAnimation 8s linear infinite; }
    @keyframes loadingAnimation { 0% { background-position: 0 100vh; } 100% { background-position: 0 0; } }

    /* Settings Column */
    .settings-column { flex: 0 0 var(--settings-column-width); position: relative; height: 100%; overflow-y: auto; overflow-x: hidden; direction: rtl; background-color: var(--bg-secondary); padding: 0; border-right: 1px solid var(--border-color); }
    .settings-content-wrapper { direction: ltr; width: 100%; padding: var(--content-padding); display: flex; flex-direction: column; height: 100%; }

    /* Output Column */
    .output-column { flex: 1; display: flex; flex-direction: column; background-color: var(--bg-primary); overflow-y: auto; padding: var(--content-padding); }
    #screenshots { display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 0.8rem; align-content: start; }

    /* Hide screenshot grid when contact sheet preview is shown */
    .output-column.show-contact-sheet #screenshots { display: none; }
    .output-column:not(.show-contact-sheet) #contactSheetPreview { display: none; }


    /* H1 */
    h1 { font-family: 'Cairo Play', sans-serif; text-align: center; padding-bottom: 1rem; margin-bottom: 1.25rem; font-weight: 400; font-size: 2em; color: var(--white); position: relative; cursor: pointer; user-select: none; transition: color 0.3s ease; }
    h1::after { 
      content: ''; 
      position: absolute; 
      left: 0; 
      bottom: 0; 
      width: 100%; 
      height: 2px; 
      background-image: linear-gradient(to right, var(--accent-primary) 50%, transparent 50%);
      background-size: 20px 2px;
      background-repeat: repeat-x;
      opacity: 0;
      transition: opacity 0.4s ease;
    }
    h1:hover { 
      color: var(--accent-primary); 
      text-shadow: 0 0 10px rgba(0, 198, 255, 0.3);
    }
    h1:hover::after { 
      opacity: 1;
      animation: moveLines 1.5s linear infinite;
    }
    h1:active { transform: scale(0.98); }
    @keyframes moveLines { 
      0% { background-position: 0px; } 
      100% { background-position: 40px; }
    }

    /* Combined Drop Zone / File Info Area */
    #dropZone {
      border: 2px dashed var(--border-dashed);
      border-radius: var(--border-radius-lg);
      background: linear-gradient(145deg, var(--bg-tertiary), var(--bg-secondary));
      cursor: pointer;
      transition: background 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease, padding 0.3s ease;
      margin-bottom: 1.5rem;
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.15);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 1.5rem 1rem;
      flex-shrink: 0;
      position: relative;
      overflow: hidden;
    }
    
    #dropZone::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-image: var(--dropzone-bg-image, none);
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      opacity: 0;
      transition: opacity 0.5s ease;
      z-index: 0;
      min-height: 100%;
    }
    
    #dropZone.has-bg-image::before {
      opacity: 0.2;
    }
    
    #dropZone > * {
      position: relative;
      z-index: 1;
    }
    
    #dropZone:hover { border-color: var(--accent-primary); box-shadow: 0 5px 12px rgba(0, 198, 255, 0.15); }
    #dropZone #uploadIcon { margin-bottom: 0.75rem; color: var(--text-tertiary); transition: color 0.3s ease, transform 0.3s ease; display: block; }
    #dropZone:hover #uploadIcon { color: var(--accent-primary); transform: scale(1.1); }
    #dropZone #uploadIcon svg { width: 44px; height: 44px; fill: currentColor; }
    #dropZone #dropZoneText { margin-bottom: 1rem; font-size: 0.95rem; color: var(--text-tertiary); display: block; }
    #dropZone #loadedFileInfo { display: none; }
    #dropZone.file-loaded { padding: 1rem 1.25rem 0.75rem; align-items: stretch; text-align: left; justify-content: flex-start; cursor: default; }
    #dropZone.file-loaded #uploadIcon, #dropZone.file-loaded #dropZoneText { display: none; }
    #dropZone.file-loaded #loadedFileInfo { display: block; width: 100%; }
    #loadedFileName { font-size: 0.95rem; font-weight: 500; color: var(--text-primary); margin-bottom: 0; display: flex; align-items: center; word-break: break-all; flex: 1; margin-right: 1rem; }
    #loadedFileName::before { content: '✓'; color: var(--accent-secondary); font-size: 1.2em; margin-right: 0.5rem; font-weight: bold; }
    
    /* File name row */
    .file-name-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.75rem; width: 100%; }
    
    #loadedFileStats { font-size: 0.85rem; color: var(--text-tertiary); margin-bottom: 1rem; }
    #loadedFileStats .info-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.5rem; white-space: nowrap; }
    #loadedFileStats .info-row:last-child { margin-bottom: 0; }
    #loadedFileStats .info-label { font-weight: 500; color: var(--text-secondary); margin-right: 1rem; }
    #loadedFileStats .info-value { 
        font-family: var(--data-font); 
        text-align: right; 
        color: var(--text-primary); 
        font-weight: 500; 
        font-size: 0.9rem; 
    }
    #loadedFileStats .leader { display: none; }
    
    /* Original select file button (visible when no file is loaded) */
    #initialSelectFileButton { padding: 0.6rem 1.5rem; font-size: 0.9rem; background-color: rgba(255, 255, 255, 0.05); border: 1px solid var(--border-color); border-radius: var(--border-radius-md); color: var(--text-primary); cursor: pointer; transition: background-color 0.2s, border-color 0.2s, color 0.2s, box-shadow 0.2s; font-weight: 500; width: fit-content; align-self: center; }
    #dropZone:not(.file-loaded):hover #initialSelectFileButton { background-color: rgba(255, 255, 255, 0.1); border-color: var(--text-tertiary); box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1); }
    
    /* Change file button (visible only when file is loaded) */
    #selectFileButton { 
      font-size: 0.8rem;
      padding: 0.4rem 1rem;
      background-color: transparent; 
      border: 1px solid var(--text-primary); 
      color: var(--text-primary);
      border-radius: var(--border-radius-md);
      cursor: pointer;
      transition: background-color 0.2s;
    }
    #selectFileButton:hover { background-color: var(--text-primary); color: var(--bg-primary); }
    
    /* Hide initial button when file is loaded */
    #dropZone.file-loaded #initialSelectFileButton { display: none; }
    
    #videoInput { display: none; }

    /* Image Count Display */
    #imageCountDisplay { text-align: center; font-size: 0.9rem; color: var(--text-tertiary); margin-top: 1.5rem; margin-bottom: 0.75rem; padding: 0.4rem 0; background-color: var(--bg-tertiary); border-radius: var(--border-radius-md); border: 1px solid var(--border-color); flex-shrink: 0; }
    #imageCountValue { 
        font-weight: 600; 
        font-family: var(--data-font); 
        margin-left: 0.5ch; 
    }
    /* Mode-specific image count value colors */
    #imageCountValue.interval-mode { color: var(--accent-interval); }
    #imageCountValue.smart-mode { color: var(--accent-secondary); }
    #imageCountValue.manual-mode { color: var(--accent-primary); }
    #imageCountValue.contact-sheet-mode { color: var(--accent-tertiary); }

    /* Black Bars Toggle */
    .toggle-row { display: flex; align-items: center; margin-bottom: 1.25rem; background-color: var(--bg-tertiary); padding: 0.8rem 1rem; border-radius: var(--border-radius-md); border: 1px solid var(--border-color); flex-shrink: 0; }
    .toggle-label, h2.toggle-label { flex: 1; font-size: 0.9rem; color: var(--text-primary); font-weight: 500; margin-right: 0.8rem; margin: 0; }
    .toggle-switch { position: relative; display: inline-block; width: 48px; height: 24px; flex-shrink: 0; }
    .toggle-input { opacity: 0; width: 0; height: 0; }
    .toggle-label-switch { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--bg-primary); transition: .3s; border-radius: 24px; border: 1px solid var(--border-color); }
    .toggle-label-switch:before { position: absolute; content: ""; height: 18px; width: 18px; left: 2px; bottom: 2px; background-color: var(--text-tertiary); transition: .3s; border-radius: 50%; box-shadow: 0 1px 2px rgba(0,0,0,0.15); }
    .toggle-input:checked + .toggle-label-switch { background: var(--text-tertiary); border-color: transparent; }
    .toggle-input:checked + .toggle-label-switch:before { transform: translateX(24px); background-color: var(--white); }

    /* Tabs */
    .segmented-controls { display: flex; border-radius: var(--border-radius-md); overflow: hidden; background-color: var(--bg-tertiary); margin-bottom: 1.25rem; border: 1px solid var(--border-color); flex-shrink: 0; }
    .segmented-controls button { flex: 1; background-color: transparent; text-align: center; border: none; padding: 0.65rem 0.5rem; color: var(--text-tertiary); cursor: pointer; transition: background 0.2s, color 0.3s, box-shadow 0.2s; font-family: inherit; font-size: 0.85rem; font-weight: 500; border-left: 1px solid var(--border-color); position: relative; white-space: nowrap; }
    .segmented-controls button:first-child { border-left: none; }
    .segmented-controls button:hover:not(.active) { background-color: var(--border-color); color: var(--text-primary); }
    .mode-tabs button[data-mode="auto"].active { background: var(--gradient-interval); }
    .mode-tabs button[data-mode="autoSmart"].active { background: var(--gradient-secondary); }
    .mode-tabs button[data-mode="manual"].active { background: var(--gradient-primary); }
    .mode-tabs button[data-mode="contactSheet"].active { background: var(--gradient-tertiary); }
    .mode-tabs button.active { color: var(--bg-primary); font-weight: 600; box-shadow: inset 0 1px 3px rgba(0,0,0,0.2); }
    /* Format tabs base style */
    .format-tabs button.active { color: var(--bg-primary); font-weight: 600; box-shadow: inset 0 1px 2px rgba(0,0,0,0.15); }
    /* Mode-specific format tab styling */
    #autoMode .format-tabs button.active { background: var(--gradient-interval); }
    #autoSmartMode .format-tabs button.active, #smartFormatTabs button.active { background: var(--gradient-secondary); }
    .smart-algo-tabs button.active { background: var(--gradient-secondary); color: var(--bg-primary); font-weight: 600; box-shadow: inset 0 1px 2px rgba(0,0,0,0.15); }
    .grid-size-tabs button.active { background: var(--gradient-tertiary); color: var(--bg-primary); font-weight: 600; box-shadow: inset 0 1px 2px rgba(0,0,0,0.15); }
    .grid-size-tabs button { 
        position: relative; 
        padding-right: 24px; /* Ensure space for the checkmark */
    }
    .grid-size-tabs button.completed::after { 
        content: "✓"; 
        position: absolute;
        right: 8px;
        top: 50%;
        transform: translateY(-50%);
        font-weight: bold;
        color: var(--accent-tertiary);
    }
    .grid-size-tabs button.active.completed::after { 
        color: var(--bg-primary);
    }
    .format-tabs, .smart-algo-tabs, .grid-size-tabs { margin-bottom: 0.8rem; }
    .format-tabs button, .smart-algo-tabs button, .grid-size-tabs button { padding: 0.5rem 0.5rem; font-size: 0.8rem; }

    /* Mode Containers */
    .mode-content { flex-grow: 1; overflow-y: auto; /* Allow scrolling within the mode content area */ padding-right: 5px; /* Space for scrollbar */}
    .mode-content > div { display: none; }
    .mode-content > div.active { display: block; }

    /* Sliders */
    .slider-row { display: flex; align-items: center; gap: 1rem; margin-bottom: 1rem; flex-wrap: wrap; }
    .slider-label, h3.slider-label { width: 100px; text-align: left; font-size: 0.85rem; color: var(--text-tertiary); flex-shrink: 0; margin: 0; font-weight: normal; }
    .slider-wrapper { flex: 1; display: flex; align-items: center; gap: 0.8rem; min-width: 150px; }
    .value-display { 
        font-weight: 500; 
        min-width: 40px; 
        text-align: right; 
        font-family: var(--data-font); 
        color: var(--text-primary); 
        font-size: 0.9rem; 
    }
    input[type="range"] { /* ... */ -webkit-appearance: none; -moz-appearance: none; appearance: none; width: 100%; height: 6px; background: var(--bg-tertiary); border-radius: var(--border-radius-full); outline: none; cursor: pointer; transition: background 0.2s; }
    input[type="range"]::-webkit-slider-thumb { /* ... */ -webkit-appearance: none; width: 18px; height: 18px; border-radius: 50%; background: var(--white); border: none; box-shadow: 0 1px 4px rgba(0, 0, 0, 0.25); transition: transform 0.1s ease-out; }
    input[type="range"]::-moz-range-thumb { /* ... */ width: 18px; height: 18px; border-radius: 50%; background: var(--white); border: none; box-shadow: 0 1px 4px rgba(0, 0, 0, 0.25); transition: transform 0.1s ease-out; }
    input[type="range"]:active::-webkit-slider-thumb, input[type="range"]:active::-moz-range-thumb { transform: scale(1.1); }
    input[type="range"]:focus-visible { outline: 2px solid var(--accent-interval); outline-offset: 2px; }
    #autoSmartMode input[type="range"]:focus-visible { outline-color: var(--accent-secondary); }
    #manualMode input[type="range"]:focus-visible { outline-color: var(--accent-primary); }
    #contactSheetMode input[type="range"]:focus-visible { outline-color: var(--accent-secondary); }

    /* Notes & Buttons */
    #pngNote, #pngNoteSmart { font-size: 0.8rem; color: var(--text-tertiary); text-align: center; width: 100%; min-height: 30px; display: flex; align-items: center; justify-content: center; margin-bottom: 0.8rem; background-color: rgba(36, 44, 68, 0.5); border-radius: var(--border-radius-sm); padding: 0.2rem 0.4rem; }
    .button-group { display: flex; flex-direction: column; gap: 0.75rem; margin-top: 1rem; }
    .action-button { width: 100%; padding: 0.75rem 1.5rem; font-size: 0.95rem; border: none; border-radius: var(--border-radius-md); color: var(--bg-primary); cursor: pointer; transition: background 0.3s ease, opacity 0.2s, color 0.2s, box-shadow 0.2s ease; text-align: center; font-weight: 600; background-size: 200% auto; box-shadow: 0 3px 5px rgba(0, 0, 0, 0.1); }
    .action-button:hover:enabled { box-shadow: 0 5px 10px rgba(0, 0, 0, 0.15); background-position: right center; }
    .action-button:active:enabled { transform: scale(0.98); box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); }
    .action-button:disabled { 
      opacity: 0.5; 
      cursor: not-allowed; 
      box-shadow: none; 
      filter: saturate(0.4) brightness(0.85);
    }
    /* Mode-specific button styling */
    #processButton, #intervalModeButtons .action-button:not(.secondary-button) { background: var(--gradient-interval); }
    #processSmartButton, #smartModeButtons .action-button:not(.secondary-button) { background: var(--gradient-secondary); }
    #processContactSheetButton, #contactSheetModeButtons .action-button:not(.secondary-button) { background: var(--gradient-tertiary); }
    #addManualButton, #manualModeButtons .action-button:not(.secondary-button) { background: var(--gradient-primary); }
    
    /* Cancel state (overrides disabled) */
    .action-button.cancel-active { background: var(--gradient-danger) !important; color: var(--white) !important; }
    .action-button.cancel-active:hover:enabled { background: var(--gradient-danger) !important; filter: brightness(1.1); }
    
    #downloadAllButton, #downloadAllSmartButton, #downloadManualButton, #downloadContactSheetButton { background: transparent; border: 1px solid var(--accent-tertiary); color: var(--accent-tertiary); padding: calc(0.75rem - 1px) calc(1.5rem - 1px); box-shadow: none; }
    #downloadAllButton { border-color: var(--accent-interval); color: var(--accent-interval); }
    #downloadAllButton:hover:enabled { background-color: rgba(154, 110, 255, 0.1); border-color: var(--accent-interval-dark); color: var(--accent-interval-dark); }
    #downloadAllSmartButton { border-color: var(--accent-secondary); color: var(--accent-secondary); }
    #downloadAllSmartButton:hover:enabled { background-color: rgba(45, 212, 191, 0.1); border-color: var(--accent-secondary-dark); color: var(--accent-secondary-dark); }
    #downloadManualButton { border-color: var(--accent-primary); color: var(--accent-primary); }
    #downloadManualButton:hover:enabled { background-color: rgba(0, 198, 255, 0.1); border-color: var(--accent-primary-dark); color: var(--accent-primary-dark); }
    #downloadContactSheetButton { border-color: var(--accent-tertiary); color: var(--accent-tertiary); }
    #downloadContactSheetButton:hover:enabled { background-color: rgba(255, 106, 193, 0.1); border-color: var(--accent-tertiary-dark); color: var(--accent-tertiary-dark); box-shadow: none; }
    
    /* Individual disabled styles for each button to preserve their colors */
    #downloadAllButton:disabled { background: transparent; border-color: var(--accent-interval); color: var(--accent-interval); opacity: 0.5; box-shadow: none; }
    #downloadAllSmartButton:disabled { background: transparent; border-color: var(--accent-secondary); color: var(--accent-secondary); opacity: 0.5; box-shadow: none; }
    #downloadManualButton:disabled { background: transparent; border-color: var(--accent-primary); color: var(--accent-primary); opacity: 0.5; box-shadow: none; }
    #downloadContactSheetButton:disabled { background: transparent; border-color: var(--accent-tertiary); color: var(--accent-tertiary); opacity: 0.5; box-shadow: none; }

    #clearScreenshotsButton { margin-top: 1rem; padding: 0.6rem 1.2rem; font-size: 0.85rem; background-color: transparent; border: 1px solid var(--border-dashed); color: var(--text-tertiary); border-radius: var(--border-radius-md); cursor: pointer; transition: background-color 0.2s, color 0.2s, border-color 0.2s, box-shadow 0.2s; width: 100%; font-weight: 500; flex-shrink: 0; }
    #clearScreenshotsButton:hover:enabled { background-color: rgba(244, 63, 94, 0.1); color: var(--danger-color); border-color: var(--danger-color); box-shadow: 0 1px 4px rgba(244, 63, 94, 0.1); }
    #clearScreenshotsButton:disabled { opacity: 0.4; cursor: not-allowed; box-shadow: none; }

    /* Manual Mode */
    #manualVideo { width: 100%; border-radius: var(--border-radius-lg); background-color: var(--black); margin-bottom: 1rem; aspect-ratio: 16 / 9; border: 1px solid var(--border-color); }
    /* The manual-buttons class is now replaced by action-button-row */
    
    /* Cut Frame button unique styling */
    #addManualButton { 
      margin-bottom: 0.75rem;
    }
    
    /* Scissors cutting animation */
    @keyframes cut-animation {
      0% { transform: rotate(0) scaleY(1); }
      40% { transform: rotate(-20deg) scaleY(-1) scale(1.05); }
      100% { transform: rotate(0) scaleY(1); }
    }
    
    #addManualButton i {
      display: inline-block;
    }
    
    #addManualButton.cutting i {
      animation: cut-animation 0.3s ease-in-out;
    }
    
    #addManualButton:hover { 
      box-shadow: 0 5px 10px rgba(0, 0, 0, 0.15); 
      background-position: right center; 
    }
    #addManualButton:active { 
      transform: scale(0.98); 
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); 
    }
    

    /* Progress Bars */
    .progress-bar-container { width: 100%; height: 8px; background-color: var(--bg-tertiary); border-radius: var(--border-radius-full); overflow: hidden; margin-top: 0.8rem; display: none; border: 1px solid var(--border-color); }
    .progress-bar-fill { height: 100%; width: 0%; border-radius: var(--border-radius-full); transition: width 0.3s ease-out; }
    #progressBarAuto .progress-bar-fill { background: var(--gradient-primary); }
    #progressBarSmart .progress-bar-fill { background: var(--gradient-secondary); }
    #progressBarContactSheet .progress-bar-fill { background: var(--gradient-tertiary); }

    /* Screenshots Grid Item */
    .screenshot-container { position: relative; overflow: hidden; border-radius: var(--border-radius-md); border: 1px solid var(--border-color); background-color: var(--bg-secondary); transition: box-shadow 0.3s ease, border-color 0.3s ease; }
    .screenshot-container:hover { box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3); border-color: var(--accent-primary); }
    .screenshot-container a { display: block; line-height: 0; }
    .screenshot-container img { display: block; width: 100%; height: auto; object-fit: cover; border-radius: var(--border-radius-md); animation: fadeIn 0.5s ease-in-out; }
    .screenshot-overlay, .delete-btn { position: absolute; opacity: 0; transition: opacity 0.2s ease-in-out; pointer-events: none; }
    .screenshot-container:hover .screenshot-overlay, .screenshot-container:hover .delete-btn { opacity: 1; pointer-events: auto; }
    .screenshot-overlay { left: 0; bottom: 0; right: 0; background: linear-gradient(to top, rgba(10, 15, 31, 0.9), transparent); color: var(--white); font-size: 0.75rem; padding: 0.8rem 0.5rem 0.3rem; text-align: right; font-family: var(--data-font); }
    .delete-btn { top: 6px; right: 6px; background: rgba(244, 63, 94, 0.7); border: none; color: var(--white); font-size: 0.9rem; width: 24px; height: 24px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; line-height: 1; backdrop-filter: blur(2px); transition: background-color 0.2s ease; }
    .delete-btn:hover { background: var(--danger-color); }
    @keyframes fadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }

    /* Hidden Elements */
    #video, #canvas, #contactSheetCanvas { display: none; }
    #frameCanvas { display: none; }

    /* Contact Sheet Mode Specific */
    #contactSheetMode p { color: var(--text-tertiary); font-size: 0.9rem; margin-bottom: 1rem; background-color: rgba(36, 44, 68, 0.5); border-radius: var(--border-radius-sm); padding: 0.5rem 0.8rem; }
    #contactSheetVideo { width: 100%; border-radius: var(--border-radius-lg); background-color: var(--black); margin-bottom: 1rem; aspect-ratio: 16 / 9; border: 1px solid var(--border-color); }
    .fine-tune-message { color: var(--accent-tertiary); font-size: 0.85rem; margin: 0.5rem 0 1rem; text-align: center; display: none; }
    .contact-sheet-controls { display: none; /* Hidden by default */ grid-template-columns: repeat(5, 1fr); gap: 0.75rem; margin-bottom: 1rem; }
    .time-input-container { display: flex; flex-direction: column; gap: 0.3rem; position: relative; }
    .time-input-wrapper {
        position: relative;
        display: inline-block;
        width: 100%;
        height: 2rem;
    }
    .time-input {
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        opacity: 0;
        z-index: 1;
        pointer-events: none;
    }
    .time-formatted {
        width: 100%;
        height: 100%;
        font-family: monospace;
        text-align: center;
        position: relative;
        padding: 0.4rem;
        border-radius: var(--border-radius-sm);
        border: 1px solid var(--border-color);
        background-color: var(--input-bg);
        color: var(--text-color);
        box-sizing: border-box;
        cursor: ns-resize; /* Show up/down cursor to indicate draggable */
        user-select: none; /* Prevent text selection during drag */
        transition: background-color 0.15s ease;
    }
    .time-formatted:hover {
        background-color: var(--bg-tertiary);
        border-color: var(--accent-primary);
    }
    .time-formatted:focus {
        outline: none;
        border-color: var(--primary-color);
    }
    .time-formatted::after {
        content: "↕";
        position: absolute;
        right: 0.5rem;
        top: 50%;
        transform: translateY(-50%);
        color: var(--text-tertiary);
        font-size: 0.9rem;
        opacity: 0.6;
    }
    .time-formatted:hover::after {
        opacity: 1;
        color: var(--accent-primary);
    }

    /* Contact Sheet Preview Grid */
    #contactSheetPreview { 
        width: 100%;
        margin: 0 auto;
        display: grid;
        grid-template: repeat(var(--grid-rows, 4), 1fr) / repeat(var(--grid-cols, 5), 1fr);
        gap: 2px;
        overflow: hidden;
        background-color: var(--border-color);
        border: 1px solid var(--border-color);
        border-radius: var(--border-radius-md);
    }
    .grid-cell { 
        background-color: var(--bg-secondary); 
        position: relative; 
        overflow: hidden;
        border: none;
        display: flex;
        width: 100%;
        height: 100%;
        align-items: center; 
        justify-content: center;
    }
    .grid-cell.filled {
        cursor: pointer;
    }
    .grid-cell img { 
        max-width: 100%; 
        min-width: none;
        max-height: 100%; 
        min-height: max-content;
        object-fit: contain;
        display: block; 
        opacity: 0; 
        transition: opacity 0.3s ease; 
    }
    .grid-cell.filled img { 
        opacity: 1; 
        animation: fadeIn 0.3s ease-in-out;
    }
    .grid-cell .screenshot-overlay { 
        opacity: 0; 
        transition: opacity 0.2s ease-in-out; 
        pointer-events: none; 
        position: absolute; 
        left: 0; 
        bottom: 0; 
        right: 0; 
        background: linear-gradient(to top, rgba(10, 15, 31, 0.8), transparent); 
        color: var(--white); 
        font-size: 0.7rem; 
        padding: 0.6rem 0.4rem 0.2rem; 
        text-align: right; 
        font-family: var(--data-font); 
    }
    .grid-cell:hover .screenshot-overlay { opacity: 1; pointer-events: auto; }
    .contact-sheet-label { color: var(--accent-tertiary); font-size: 0.9rem; font-weight: 500; margin: 1rem 0 0.5rem; text-align: center; width: 100%; }


    /* Responsive */
    @media (max-width: 800px) {
        body { overflow-y: auto; height: auto; }
        .app-container { flex-direction: column; height: auto; overflow: visible; }
        .vertical-separator { display: none; }
        .settings-column { flex-basis: auto; width: 100%; height: auto; max-height: none; border-right: none; overflow-y: visible; padding: 0; direction: ltr; background-color: var(--bg-secondary); }
        .settings-content-wrapper { direction: ltr; padding: var(--content-padding); height: auto; } /* Reset height */
        .output-column { width: 100%; overflow-y: visible; background-color: var(--bg-primary); padding: var(--content-padding); }
        #screenshots { padding: 0; } /* Remove padding if output col has it */
        h1 { margin-bottom: 1.25rem; }
        .mode-content { overflow: visible; } /* Allow content to determine height */
    }
    @media (max-width: 600px) {
        :root { --content-padding: 1rem; }
        body { font-size: 14px; }
        .settings-content-wrapper { padding: 1rem; }
        .output-column { padding: 1rem; }
        #screenshots { grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 0.5rem; }
        .slider-label { width: 80px; }
        h1 { font-size: 1.8em; }
        .action-button { font-size: 0.9rem; padding: 0.7rem 1.2rem; }
        #dropZone { padding: 1.25rem 0.8rem; }
        #dropZone.file-loaded { padding: 0.8rem 1rem 0.6rem; }
        #loadedFileStats { font-size: 0.8rem; }
        #loadedFileStats .info-value { font-size: 0.85rem; }
        .segmented-controls button { font-size: 0.75rem; padding: 0.5rem 0.3rem; } /* Further reduce padding */
        #contactSheetPreview { gap: 1px; }
        .contact-sheet-controls { grid-template-columns: repeat(3, 1fr); } /* Adjust layout for smaller screens */
        .time-input-wrapper { height: 1.8rem; }
        .time-input { font-size: 0.8rem; }
        .time-formatted { font-size: 0.8rem; padding: 0.3rem; padding-right: 1.5rem; }
    }

    /* Highlight styles for contact sheet cells and time inputs */
    .time-input-container .time-formatted {
        transition: border-color 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease;
    }
    .time-input-container.highlight .time-formatted {
        border-color: var(--accent-primary);
        box-shadow: 0 0 0 2px rgba(0, 198, 255, 0.3);
        background-color: rgba(0, 198, 255, 0.05);
    }
    .grid-cell {
        transition: outline 0.2s ease;
    }
    .grid-cell.highlight {
        outline: 2px solid var(--accent-primary);
        outline-offset: 1px;
        position: relative;
        z-index: 2;
    }
    .grid-cell.highlight img {
        opacity: 1;
    }
    /* Frame adjustment buttons */
    .frame-adjust-buttons {
        position: absolute;
        bottom: 8px;
        left: 8px;
        display: none;
        gap: 6px;
        z-index: 5;
        background: transparent;
        padding: 0;
        width: auto;
        justify-content: flex-start;
    }
    .grid-cell.highlight .frame-adjust-buttons {
        display: flex;
    }
    /* Make sure not to show buttons when hovering time inputs */
    .time-input-container.highlight ~ #contactSheetPreview .grid-cell.highlight .frame-adjust-buttons {
        display: none;
    }
    .frame-adjust-btn {
        width: 28px;
        height: 28px;
        border-radius: 4px;
        background-color: rgba(0, 0, 0, 0.75);
        color: white;
        border: 1px solid rgba(255, 255, 255, 0.6);
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        font-size: 16px;
        cursor: pointer;
        transition: background-color 0.15s ease, transform 0.15s ease;
        user-select: none;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.4);
    }
    .frame-adjust-btn:hover {
        background-color: var(--accent-primary);
        transform: scale(1.1);
    }
    .frame-adjust-btn:active {
        transform: scale(0.95);
        background-color: var(--primary-color);
    }

    #contactSheetMode .video-container, #contactSheetMode #contactSheetVideo {
        display: none; /* Hide video player in contact sheet mode */
    }

    /* Sticky Button Container */
    .sticky-button-container {
        position: sticky;
        bottom: 0;
        background-color: var(--bg-secondary);
        padding-top: 1rem;
        margin-top: auto;
        border-top: 1px solid var(--border-color);
        z-index: 10;
        display: flex;
        flex-direction: column;
    }
    
    .sticky-button-container .button-group {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        margin-bottom: 1rem;
    }
    
    /* Status Row */
    .status-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0.5rem;
    }
    
    .status-row #clearScreenshotsButton {
        margin-top: 0;
        flex: 0 0 auto;
        width: auto;
        margin-right: 0.75rem;
    }
    
    .status-row #imageCountDisplay {
        flex: 1;
        margin-top: 0;
        margin-bottom: 0;
    }
    
    /* Info icon styling */
    .status-row .info-icon {
        margin-left: 1rem;
        color: var(--text-tertiary);
        cursor: pointer;
        transition: color 0.2s ease;
        font-size: 1.1rem;
    }
    
    .status-row .info-icon:hover {
        color: var(--accent-primary);
    }

    /* Info button styling */
    .status-row #toolInfoButton {
        background-color: var(--bg-secondary);
        border: 1px solid var(--border-color);
        color: var(--text-tertiary);
        border-radius: var(--border-radius-md);
        cursor: pointer;
        padding: 0.45rem;
        transition: all 0.2s ease;
        margin-left: 0.75rem;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 500;
        font-size: 0.9rem;
        min-width: 2.2rem;
        aspect-ratio: 1;
    }
    
    .status-row #toolInfoButton:hover {
        background-color: var(--bg-tertiary);
        border-color: var(--text-tertiary);
        color: var(--text-primary);
    }
    
    .status-row #toolInfoButton:active {
        transform: scale(0.95);
    }
    
    .status-row #toolInfoButton i {
        font-size: 1.1rem;
    }

    /* Modal/Lightbox styling */
    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.75);
        z-index: 1000;
        display: flex;
        justify-content: center;
        align-items: center;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease, visibility 0.3s ease;
    }
    
    .modal-overlay.active {
        opacity: 1;
        visibility: visible;
    }
    
    .modal-content {
        background: var(--bg-secondary);
        border-radius: var(--border-radius-lg);
        max-width: 600px;
        width: 90%;
        max-height: 90vh;
        overflow-y: auto;
        padding: 1.5rem;
        position: relative;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
        transform: translateY(20px);
        transition: transform 0.3s ease;
    }
    
    .modal-overlay.active .modal-content {
        transform: translateY(0);
    }
    
    .modal-close {
        position: absolute;
        top: 1rem;
        right: 1rem;
        color: var(--text-tertiary);
        background: none;
        border: none;
        font-size: 1.5rem;
        cursor: pointer;
        transition: color 0.2s ease;
    }
    
    .modal-close:hover {
        color: var(--accent-primary);
    }
    
    .modal-title {
        font-size: 1.5rem;
        margin-bottom: 1rem;
        color: var(--text-primary);
        padding-bottom: 0.75rem;
    }
    
    .modal-body {
        color: var(--text-tertiary);
        line-height: 1.6;
    }
    
    .modal-body p {
        margin-bottom: 1rem;
    }
    
    .modal-body h3 {
        color: var(--text-primary);
        margin: 1.5rem 0 0.5rem;
        font-size: 1.1rem;
    }
    
    .modal-body ul {
        padding-left: 1.5rem;
        margin-bottom: 1rem;
    }
    
    .modal-body li {
        margin-bottom: 0.5rem;
    }
    
    /* Show only the active progress bar */
    .sticky-button-container #progressBarAuto,
    .sticky-button-container #progressBarSmart,
    .sticky-button-container #progressBarContactSheet {
        margin-top: 0;
    }
    
    /* Progress Bar Wrapper - Maintains consistent height */
    .progress-bar-wrapper {
        height: 12px;
        margin-bottom: 0.75rem;
        position: relative;
    }
    
    .progress-bar-container {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 100%;
        background-color: var(--bg-tertiary);
        border-radius: var(--border-radius-sm);
        overflow: hidden;
    }
    
    .progress-bar-fill {
        height: 100%;
        width: 0%;
        background: var(--gradient-interval);
        border-radius: var(--border-radius-sm);
        transition: width 0.1s ease;
    }
    
    #progressBarSmart .progress-bar-fill {
        background: var(--gradient-secondary);
    }
    
    #progressBarContactSheet .progress-bar-fill {
        background: var(--gradient-tertiary);
    }

    .grid-size-title {
        font-size: 0.9rem;
        color: var(--text-primary);
        font-weight: 500;
        margin-bottom: 0.5rem;
        text-align: center;
    }
    
    /* Action Button Row for equal width buttons */
    .action-button-row {
        display: flex;
        gap: 0.75rem;
        width: 100%;
    }
    .action-button-row .action-button {
        flex: 1;
    }
    
    /* Secondary action buttons */
    .secondary-button {
        background: transparent;
        border: 1px solid var(--accent-tertiary);
        color: var(--accent-tertiary);
        padding: calc(0.75rem - 1px) calc(1.5rem - 1px);
        box-shadow: none;
    }
    .secondary-button:hover:enabled {
        background-color: rgba(255, 106, 193, 0.1);
        border-color: var(--accent-tertiary-dark);
        color: var(--accent-tertiary-dark);
        box-shadow: none;
    }
    
    /* Mode-specific secondary button styling */
    #manualModeButtons .secondary-button {
        border-color: var(--accent-primary);
        color: var(--accent-primary);
    }
    #manualModeButtons .secondary-button:hover:enabled {
        background-color: rgba(0, 198, 255, 0.1);
        border-color: var(--accent-primary-dark);
        color: var(--accent-primary-dark);
    }
    #smartModeButtons .secondary-button {
        border-color: var(--accent-secondary);
        color: var(--accent-secondary);
    }
    #smartModeButtons .secondary-button:hover:enabled {
        background-color: rgba(94, 234, 212, 0.1);
        border-color: var(--accent-secondary-dark);
        color: var(--accent-secondary-dark);
    }
    
    /* Ensure both buttons in Manual mode use accent-primary */
    #extractManualButton {
        border-color: var(--accent-primary) !important;
        color: var(--accent-primary) !important;
    }
    #extractManualButton:hover:enabled {
        background-color: rgba(0, 198, 255, 0.1) !important;
        border-color: var(--accent-primary-dark) !important;
        color: var(--accent-primary-dark) !important;
    }
    
    #processButton { background: var(--gradient-interval); }

    .image-count .count {
        font-weight: bold;
        font-size: 1.1em;
    }

    .image-count .count.interval-mode {
        color: #4CAF50; /* Green for interval mode */
    }

    .image-count .count.smart-mode {
        color: #2196F3; /* Blue for smart mode */
    }

    .image-count .count.manual-mode {
        color: #FF9800; /* Orange for manual mode */
    }

    .image-count .count.contact-sheet-mode {
        color: #9C27B0; /* Purple for contact sheet mode */
    }
  </style>
</head>
<body>

  <div class="app-container">

    <div class="vertical-separator"></div>

    <div class="settings-column">
      <div class="settings-content-wrapper">
        <h1 id="pageTitle" data-text="Nia Frame Capture Studio">Nia Frame Capture Studio</h1>

        <div id="dropZone">
            <div id="uploadIcon"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM14 13v4h-4v-4H7l5-5 5 5h-3z"/></svg></div>
            <div id="dropZoneText">Drag & drop video file or</div>
            <div id="loadedFileInfo">
                <div class="file-name-row">
                    <div id="loadedFileName">Filename goes here</div>
                    <button id="selectFileButton" class="file-loaded-button">Change File</button>
                </div>
                <div id="loadedFileStats">
                    <div class="info-row"><div class="info-label">Resolution</div><div class="info-value" id="resolutionValue">-</div></div>
                    <div class="info-row"><div class="info-label">Duration</div><div class="info-value" id="lengthValue">-</div></div>
                    <div class="info-row"><div class="info-label">Aspect Ratio</div><div class="info-value" id="aspectRatioValue">-</div></div>
                    <div class="info-row"><div class="info-label">Bitrate</div><div class="info-value" id="bitrateValue">-</div></div>
                </div>
            </div>
            <button id="initialSelectFileButton" type="button">Select File</button>
            <input type="file" id="videoInput" accept="video/*">
        </div>

        <div class="toggle-row"><h2 class="toggle-label">Remove Black Bars</h2><div class="toggle-switch"><input type="checkbox" id="removeBarsToggle" class="toggle-input"><label for="removeBarsToggle" class="toggle-label-switch"></label></div></div>

        <div class="segmented-controls mode-tabs">
            <button class="mode-tab active" data-mode="manual">Manual</button>
            <button class="mode-tab" data-mode="auto">Interval</button>
            <button class="mode-tab" data-mode="autoSmart">Smart Auto</button>
            <button class="mode-tab" data-mode="contactSheet">Contact Sheet</button>
        </div>

        <div class="mode-content">
            <div id="manualMode" class="active">
              <video id="manualVideo" controls></video>
            </div>
            <div id="autoMode">
                <div class="slider-row"><h3 class="slider-label">Interval</h3><div class="slider-wrapper"><input type="range" id="intervalInput" min="1" max="30" value="10" step="1"><span id="intervalValue" class="value-display"></span></div></div>
                <div class="segmented-controls format-tabs"><button class="format-tab active" data-format="png">PNG</button><button class="format-tab" data-format="jpeg">JPEG</button><button class="format-tab" data-format="webp">WEBP</button></div>
                <div id="pngNote">Lossless quality, largest file size.</div>
                <div class="slider-row" id="jpegSettings" style="display:none;"><h3 class="slider-label">JPEG Quality</h3><div class="slider-wrapper"><input type="range" id="jpegQuality" min="10" max="100" value="85" step="5"><span id="jpegQualityValue" class="value-display"></span></div></div>
                <div class="slider-row" id="webpSettings" style="display:none;"><h3 class="slider-label">WEBP Quality</h3><div class="slider-wrapper"><input type="range" id="webpQuality" min="10" max="100" value="85" step="5"><span id="webpQualityValue" class="value-display"></span></div></div>
            </div>
            <div id="autoSmartMode">
               <div class="segmented-controls smart-algo-tabs"><button class="smart-tab active" data-algo="histogram">Histogram Diff</button><button class="smart-tab" data-algo="pixeldiff">Pixel Diff</button><button class="smart-tab" data-algo="ssim">Low SSIM</button></div>
               <div class="slider-row" id="histThresholdSettings"><h3 class="slider-label">Hist Thresh</h3><div class="slider-wrapper"><input type="range" id="histThresholdInput" min="0.05" max="0.75" value="0.40" step="0.05"><span id="histThresholdValue" class="value-display"></span></div></div>
               <div class="slider-row" id="pixelThresholdSettings" style="display:none;"><h3 class="slider-label">Pixel Thresh</h3><div class="slider-wrapper"><input type="range" id="pixelThresholdInput" min="5" max="100" value="35" step="5"><span id="pixelThresholdValue" class="value-display"></span></div></div>
               <div class="slider-row" id="ssimThresholdSettings" style="display:none;"><h3 class="slider-label">SSIM Thresh</h3><div class="slider-wrapper"><input type="range" id="ssimThresholdInput" min="0.1" max="1.00" value="0.90" step="0.05"><span id="ssimThresholdValue" class="value-display"></span></div></div>
               <div class="segmented-controls format-tabs" id="smartFormatTabs"><button class="format-tab active" data-format="png">PNG</button><button class="format-tab" data-format="jpeg">JPEG</button><button class="format-tab" data-format="webp">WEBP</button></div>
               <div id="pngNoteSmart">Lossless quality, largest file size.</div>
               <div class="slider-row" id="jpegSettingsSmart" style="display:none;"><h3 class="slider-label">JPEG Quality</h3><div class="slider-wrapper"><input type="range" id="jpegQualitySmart" min="10" max="100" value="85" step="5"><span id="jpegQualityValueSmart" class="value-display"></span></div></div>
               <div class="slider-row" id="webpSettingsSmart" style="display:none;"><h3 class="slider-label">WEBP Quality</h3><div class="slider-wrapper"><input type="range" id="webpQualitySmart" min="10" max="100" value="85" step="5"><span id="webpQualityValueSmart" class="value-display"></span></div></div>
            </div>
            <div id="contactSheetMode">
                <p>Generate a grid of screenshots. Choose a grid size and adjust times below to fine-tune.</p>
                <div class="grid-size-title">Grid Size:</div>
                <div class="segmented-controls grid-size-tabs">
                    <button class="grid-size-tab active" data-rows="4" data-cols="5">5×4</button>
                    <button class="grid-size-tab" data-rows="3" data-cols="4">4×3</button>
                    <button class="grid-size-tab" data-rows="2" data-cols="3">Custom</button>
                </div>
                <div id="customGridControls" style="display: none; margin-bottom: 1.25rem;">
                    <div style="display: flex; align-items: center; gap: 10px; justify-content: center;">
                        <label style="display: flex; align-items: center;">
                            <span>Columns:</span>
                            <input type="number" id="customGridCols" min="1" max="6" value="3" style="width: 50px; margin-left: 5px; padding: 5px;">
                        </label>
                        <span>×</span>
                        <label style="display: flex; align-items: center;">
                            <span>Rows:</span>
                            <input type="number" id="customGridRows" min="1" max="6" value="2" style="width: 50px; margin-left: 5px; padding: 5px;">
                        </label>
                    </div>
                </div>
                <div class="video-container">
                <video id="contactSheetVideo" controls></video>
                </div>
                <div id="fineTuneMessage" class="fine-tune-message">
                    Drag up/down on time values to adjust frames, or click to enter time manually.
                    Hover over thumbnails to use -/+ buttons for quick 1-second adjustments.
                    Click "Update Sheet Image" when finished.
                </div>
                <div class="contact-sheet-controls">
                    <!-- Inputs generated by JS -->
                </div>
            </div>
        </div>

        <div class="sticky-button-container">
            <!-- Auto Mode Buttons -->
            <div class="button-group" id="intervalModeButtons">
                <button id="processButton" class="action-button">Extract Screenshots</button>
                <button id="downloadAllButton" class="action-button secondary-button" disabled>Download All (.zip)</button>
            </div>
            
            <!-- Smart Auto Mode Buttons -->
            <div class="button-group" id="smartModeButtons" style="display:none;">
                <button id="processSmartButton" class="action-button">Extract Smart Shots</button>
                <button id="downloadAllSmartButton" class="action-button secondary-button" disabled>Download All (.zip)</button>
            </div>
            
            <!-- Manual Mode Buttons -->
            <div class="button-group" id="manualModeButtons" style="display:none;">
                <button id="addManualButton" class="action-button" type="button">Cut Frame <i class="ri-scissors-line"></i></button>
                <div class="action-button-row">
                    <button id="extractManualButton" class="action-button secondary-button" type="button">Quick Save Frame</button>
                    <button id="downloadManualButton" class="action-button secondary-button" type="button" disabled>Download Added</button>
                </div>
            </div>
            
            <!-- Contact Sheet Mode Buttons -->
            <div class="button-group" id="contactSheetModeButtons" style="display:none;">
                <button id="processContactSheetButton" class="action-button">Generate/Update Sheet</button>
                <div class="action-button-row">
                    <button id="previewContactSheetButton" class="action-button secondary-button" disabled>Preview Sheet Image</button>
                    <button id="downloadContactSheetButton" class="action-button secondary-button" disabled>Download Sheet Image</button>
                </div>
            </div>
            
            <!-- Progress Bars -->
            <div class="progress-bar-wrapper">
                <div id="progressBarAuto" class="progress-bar-container" style="display:none;"><div id="progressBarFillAuto" class="progress-bar-fill"></div></div>
                <div id="progressBarSmart" class="progress-bar-container" style="display:none;"><div id="progressBarFillSmart" class="progress-bar-fill"></div></div>
                <div id="progressBarContactSheet" class="progress-bar-container" style="display:none;"><div id="progressBarFillContactSheet" class="progress-bar-fill"></div></div>
            </div>
            
            <div class="status-row">
                <button id="clearScreenshotsButton" type="button" disabled>Clear Output</button>
                <div id="imageCountDisplay">Generated Images:<span id="imageCountValue">0</span></div>
                <button id="toolInfoButton" type="button" title="About this tool"><i class="ri-information-line"></i></button>
            </div>
        </div>

      </div> <!-- End Settings Content Wrapper -->
    </div> <!-- End Settings Column -->

    <!-- Right Column: Output Area -->
    <div class="output-column" id="outputColumn">
      <div id="screenshots">
        <!-- Screenshot previews will be appended here -->
      </div>
      <!-- Contact Sheet Preview -->
      <div id="contactSheetPreview">
        <!-- Grid cells generated by JS -->
      </div>
    </div>

  </div> <!-- End App Container -->

  <!-- Hidden elements -->
  <video id="video" style="display:none;"></video>
  <canvas id="canvas"></canvas>
  <canvas id="frameCanvas" style="display:none;"></canvas>
  <canvas id="contactSheetCanvas" style="display:none;"></canvas>

  <!-- Modal/Lightbox for tool information -->
  <div class="modal-overlay" id="toolInfoModal">
    <div class="modal-content">
      <button class="modal-close" id="modalClose"><i class="ri-close-line"></i></button>
      <h2 class="modal-title">Nia Frame Capture Studio</h2>
      <div class="modal-body">
        <p>Nia Frame Capture Studio is a powerful tool for extracting high-quality screenshots from video files directly in your browser, with no uploads required.</p>
        
        <h3>Features:</h3>
        <ul>
          <li><strong>Interval Mode:</strong> Extract frames at regular time intervals</li>
          <li><strong>Smart Auto Mode:</strong> Automatically extract only visually distinct frames using advanced algorithms</li>
          <li><strong>Manual Mode:</strong> Manually select and capture specific frames</li>
          <li><strong>Contact Sheet:</strong> Generate a grid of screenshots in a single image</li>
          <li><strong>Black Bar Removal:</strong> Automatically detect and crop black bars from letterboxed videos</li>
        </ul>
        
        <h3>Smart Auto Algorithms:</h3>
        <ul>
          <li><strong>Histogram Diff:</strong> Compares color distribution between frames. Higher threshold captures only major scene changes; lower threshold captures subtle visual differences.</li>
          <li><strong>Pixel Diff:</strong> Measures the percentage of pixels that have changed between frames. Higher threshold focuses on significant visual changes; lower threshold catches minor movements.</li>
          <li><strong>Low SSIM:</strong> Uses Structural Similarity Index to detect changes in image structure and patterns. Lower values capture more frames; higher values focus only on major scene transitions.</li>
        </ul>
        
        <h3>Supported Formats:</h3>
        <ul>
          <li><strong>PNG:</strong> Lossless quality with largest file size</li>
          <li><strong>JPEG:</strong> Smaller file size with adjustable quality</li>
          <li><strong>WEBP:</strong> Modern format with good compression and quality</li>
        </ul>
        
        <p>All processing happens locally in your browser - your videos are never uploaded to any server.</p>
      </div>
    </div>
  </div>


  <script>
    'use strict';

    let verticalSeparatorElement = null;
    let cropData = null;
    let removeBarsEnabled = false;
    // Grid caches to store state for each grid size
    let gridCache = {
      '5x4': { data: null, blob: null, completed: false },
      '4x3': { data: null, blob: null, completed: false },
      '3x2': { data: null, blob: null, completed: false }
    };

    // --- Tool Info Modal ---
    const toolInfoIcon = document.getElementById('toolInfoButton');
    const toolInfoModal = document.getElementById('toolInfoModal');
    const modalClose = document.getElementById('modalClose');

    if (toolInfoIcon && toolInfoModal && modalClose) {
        // Open modal when info button is clicked
        toolInfoIcon.addEventListener('click', () => {
            toolInfoModal.classList.add('active');
            // Prevent scrolling of the body when modal is open
            document.body.style.overflow = 'hidden';
        });
        
        // Close modal when close button is clicked
        modalClose.addEventListener('click', () => {
            toolInfoModal.classList.remove('active');
            // Re-enable scrolling
            document.body.style.overflow = '';
        });
        
        // Close modal when clicking outside the content
        toolInfoModal.addEventListener('click', (e) => {
            if (e.target === toolInfoModal) {
                toolInfoModal.classList.remove('active');
                document.body.style.overflow = '';
            }
        });
        
        // Close modal when Escape key is pressed
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && toolInfoModal.classList.contains('active')) {
                toolInfoModal.classList.remove('active');
                document.body.style.overflow = '';
            }
        });
    }

    // --- Debounce Helper ---
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    };


    document.addEventListener('DOMContentLoaded', () => {
      try {
        // --- DOM Element References ---
        const pageTitle = document.getElementById('pageTitle');
        const dropZone = document.getElementById('dropZone');
        const uploadIcon = document.getElementById('uploadIcon');
        const dropZoneText = document.getElementById('dropZoneText');
        const loadedFileInfo = document.getElementById('loadedFileInfo');
        const loadedFileName = document.getElementById('loadedFileName');
        const selectFileButton = document.getElementById('selectFileButton');
        const initialSelectFileButton = document.getElementById('initialSelectFileButton');
        const videoInput = document.getElementById('videoInput');

        const resolutionValue = document.getElementById('resolutionValue');
        const lengthValue = document.getElementById('lengthValue');
        const aspectRatioValue = document.getElementById('aspectRatioValue');
        const bitrateValue = document.getElementById('bitrateValue');

        const imageCountDisplay = document.getElementById('imageCountDisplay');
        const imageCountValue = document.getElementById('imageCountValue');
        
        // Set initial mode-specific class for image count
        if (imageCountValue) {
            imageCountValue.classList.add('manual-mode'); // Start with manual as default
        }

        const modeTabs = document.querySelectorAll('.mode-tab');
        const modeContentDiv = document.querySelector('.mode-content');
        const contactSheetModeDiv = document.getElementById('contactSheetMode');
        
        // Button groups in sticky container
        const intervalModeButtons = document.getElementById('intervalModeButtons');
        const smartModeButtons = document.getElementById('smartModeButtons');
        const contactSheetModeButtons = document.getElementById('contactSheetModeButtons');
        const manualModeButtons = document.getElementById('manualModeButtons');
        
        // Initialize button groups visibility
        if (manualModeButtons) manualModeButtons.style.display = 'flex';
        if (intervalModeButtons) intervalModeButtons.style.display = 'none';
        if (smartModeButtons) smartModeButtons.style.display = 'none';
        if (contactSheetModeButtons) contactSheetModeButtons.style.display = 'none';

        const intervalInput = document.getElementById('intervalInput');
        const intervalValue = document.getElementById('intervalValue');
        const jpegQualityAuto = document.getElementById('jpegQuality');
        const jpegQualityValueAuto = document.getElementById('jpegQualityValue');
        const webpQualityAuto = document.getElementById('webpQuality');
        const webpQualityValueAuto = document.getElementById('webpQualityValue');
        const jpegQualitySmart = document.getElementById('jpegQualitySmart');
        const jpegQualityValueSmart = document.getElementById('jpegQualityValueSmart');
        const webpQualitySmart = document.getElementById('webpQualitySmart');
        const webpQualityValueSmart = document.getElementById('webpQualityValueSmart');

        const formatTabsAuto = document.querySelectorAll('#autoMode .format-tab');
        const pngNoteAuto = document.getElementById('pngNote');
        const jpegSettingsAuto = document.getElementById('jpegSettings');
        const webpSettingsAuto = document.getElementById('webpSettings');
        const formatTabsSmart = document.querySelectorAll('#smartFormatTabs .format-tab');
        const pngNoteSmart = document.getElementById('pngNoteSmart');
        const jpegSettingsSmart = document.getElementById('jpegSettingsSmart');
        const webpSettingsSmart = document.getElementById('webpSettingsSmart');

        const processButton = document.getElementById('processButton');
        const downloadAllButton = document.getElementById('downloadAllButton');
        const progressBarAuto = document.getElementById('progressBarAuto');
        const progressBarFillAuto = document.getElementById('progressBarFillAuto');

        const processSmartButton = document.getElementById('processSmartButton');
        const downloadAllSmartButton = document.getElementById('downloadAllSmartButton');
        const progressBarSmart = document.getElementById('progressBarSmart');
        const progressBarFillSmart = document.getElementById('progressBarFillSmart');

        const smartAlgoTabs = document.querySelectorAll('.smart-tab');
        const histThresholdSettings = document.getElementById('histThresholdSettings');
        const pixelThresholdSettings = document.getElementById('pixelThresholdSettings');
        const ssimThresholdSettings = document.getElementById('ssimThresholdSettings');

        const manualVideo = document.getElementById('manualVideo');
        const extractManualButton = document.getElementById('extractManualButton');
        const addManualButton = document.getElementById('addManualButton');
        const downloadManualButton = document.getElementById('downloadManualButton');

        const contactSheetVideo = document.getElementById('contactSheetVideo');
        const contactSheetControlsElement = document.querySelector('.contact-sheet-controls');
        const fineTuneMessageElement = document.getElementById('fineTuneMessage');
        const processContactSheetButton = document.getElementById('processContactSheetButton');
        const downloadContactSheetButton = document.getElementById('downloadContactSheetButton');
        const previewContactSheetButton = document.getElementById('previewContactSheetButton');
        const progressBarContactSheet = document.getElementById('progressBarContactSheet');
        const progressBarFillContactSheet = document.getElementById('progressBarFillContactSheet');
        const contactSheetCanvas = document.getElementById('contactSheetCanvas'); // For final download generation
        const contactSheetPreviewElement = document.getElementById('contactSheetPreview'); // The grid container

        const removeBarsToggle = document.getElementById('removeBarsToggle');
        const screenshotsDiv = document.getElementById('screenshots');
        const video = document.getElementById('video'); // Hidden processing video
        const canvas = document.getElementById('canvas'); // General purpose canvas
        const frameCanvas = document.getElementById('frameCanvas'); // Hidden canvas for processing steps if needed
        const clearScreenshotsButton = document.getElementById('clearScreenshotsButton');
        const outputColumn = document.getElementById('outputColumn');

        verticalSeparatorElement = document.querySelector('.vertical-separator');

        // --- Check if Core Elements Exist ---
        if (!dropZone || !videoInput || !selectFileButton || !video || !manualVideo || !canvas || !frameCanvas || !contactSheetCanvas || !modeContentDiv || !screenshotsDiv || !clearScreenshotsButton || !processContactSheetButton || !downloadContactSheetButton || !previewContactSheetButton || !progressBarContactSheet || !loadedFileInfo || !loadedFileName || !imageCountDisplay || !imageCountValue || !contactSheetVideo || !contactSheetControlsElement || !fineTuneMessageElement || !contactSheetPreviewElement || !outputColumn) {
            throw new Error("One or more critical HTML elements are missing. Check IDs.");
        }

        // --- State Variables ---
        let currentMode = 'auto';
        let smartAlgorithm = 'histogram';
        let uploadedFile = null;
        let currentVideoDuration = 0;
        let processingActive = false;
        let cancelExtractionRequested = false;
        let screenshotBlobs = []; // Auto/Smart mode blobs { blob, timestamp }
        let manualScreenshotBlobs = []; // Manual mode blobs { blob, timestamp }
        let contactSheetBlob = null; // Final downloadable contact sheet blob
        let contactSheetPreviewData = new Array(20).fill(null); // Store { blob, timestamp } for each cell preview
        let currentSamplingProcess = null; // Ref to cancel sampling
        let fineTuneCaptureTimeout = null; // Timeout for debounced fine-tune captures


        // --- Helper Functions ---
        const updateSliderBackground = (slider) => { 
            if (!slider) return; 
            const val = slider.value; 
            const min = slider.min || 0; 
            const max = slider.max || 100; 
            const pct = max > min ? ((val - min) * 100) / (max - min) : 0; 
            
            let color = 'var(--accent-interval)'; // Default for autoMode (Interval)
            
            // Fix for pixelThresholdInput which might not be properly detected
            if (slider.id === 'pixelThresholdInput') {
                color = 'var(--accent-secondary)';
            } 
            else if (slider.closest('#autoSmartMode')) {
                color = 'var(--accent-secondary)'; // Smart Auto mode
            } else if (slider.closest('#manualMode')) {
                color = 'var(--accent-primary)'; // Manual mode
            } else if (slider.closest('#contactSheetMode')) {
                color = 'var(--accent-tertiary)'; // Contact Sheet mode
            }
            
            slider.style.background = `linear-gradient(to right, ${color} 0%, ${color} ${pct}%, var(--bg-tertiary) ${pct}%, var(--bg-tertiary) 100%)`;
        };
        const formatTime = (seconds) => {
            if (isNaN(seconds)) seconds = 0;
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            const ms = Math.floor((seconds % 1) * 100);  // Get 2 decimal places for milliseconds
            
            if (h > 0) {
                return `${h}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
            } else {
                return `${m}:${s.toString().padStart(2, '0')}`;
            }
        };
        
        // Parse a time string in the format "h:mm:ss" or "m:ss" to seconds
        const parseTimeString = (timeStr) => {
            try {
                // Handle direct number input (like "45.5")
                if (!timeStr.includes(':')) {
                    const directSeconds = parseFloat(timeStr);
                    if (!isNaN(directSeconds)) {
                        return directSeconds;
                    }
                }
                
                // Handle time format with colons
                const parts = timeStr.trim().split(':');
                
                if (parts.length === 2) {
                    // Format: m:ss or m:ss.ms
                    const minutes = parseInt(parts[0], 10);
                    const seconds = parseFloat(parts[1]);
                    
                    if (!isNaN(minutes) && !isNaN(seconds)) {
                        return minutes * 60 + seconds;
                    }
                }
                else if (parts.length === 3) {
                    // Format: h:mm:ss or h:mm:ss.ms
                    const hours = parseInt(parts[0], 10);
                    const minutes = parseInt(parts[1], 10);
                    const seconds = parseFloat(parts[2]);
                    
                    if (!isNaN(hours) && !isNaN(minutes) && !isNaN(seconds)) {
                        return hours * 3600 + minutes * 60 + seconds;
                    }
                }
                
                // Fallback for invalid input
                console.warn("Invalid time format:", timeStr);
                return 0;
            } catch (error) {
                console.error("Error parsing time string:", error);
                return 0;
            }
        };
        const gcd = (a, b) => { return b ? gcd(b, a % b) : a; };
        
        // Add a function to detect common aspect ratios with some tolerance
        const getCommonAspectRatio = (width, height) => {
            // Calculate the raw aspect ratio as a decimal
            const rawRatio = width / height;
            
            // Common aspect ratios with their decimal values and display formats
            const commonRatios = [
                { ratio: 16/9, display: "16:9" },  // 1.778
                { ratio: 4/3, display: "4:3" },    // 1.333
                { ratio: 21/9, display: "21:9" },  // 2.333 (Ultrawide)
                { ratio: 2/1, display: "2:1" },    // 2.0 (Univisium)
                { ratio: 1.85/1, display: "1.85:1" }, // Academy
                { ratio: 2.35/1, display: "2.35:1" }, // Cinemascope
                { ratio: 2.39/1, display: "2.39:1" }, // Anamorphic
                { ratio: 2.40/1, display: "2.4:1" },  // DCI/SMPTE standard
                { ratio: 3/2, display: "3:2" },    // 1.5 (Classic 35mm)
                { ratio: 5/4, display: "5:4" },    // 1.25 (Medium format)
                { ratio: 1/1, display: "1:1" },    // 1.0 (Square)
                { ratio: 9/16, display: "9:16" }   // 0.5625 (Vertical/Portrait)
            ];
            
            // Tolerance threshold (0.5% deviation)
            const TOLERANCE = 0.005;
            
            // Check if the ratio is close to a common ratio
            for (const { ratio, display } of commonRatios) {
                const deviation = Math.abs(rawRatio - ratio) / ratio;
                if (deviation < TOLERANCE) {
                    return display;
                }
            }
            
            // If no common ratio found, calculate using GCD with rounding for precision
            // Round to nearest whole number for better precision with black bar detection
            const a = Math.round(width);
            const b = Math.round(height);
            const divisor = gcd(a, b);
            
            return `${a / divisor}:${b / divisor}`;
        };
        
        // Function to standardize resolution to common formats
        const getStandardizedResolution = (width, height) => {
            // Round to the nearest 10 for cleaner values
            const roundWidth = (w) => {
                // If already a multiple of 10, leave as is
                if (w % 10 === 0) return w;
                
                // Get the last digit
                const lastDigit = w % 10;
                
                // Round down if 4 or less, up if 5 or more
                return lastDigit <= 4 ? w - lastDigit : w + (10 - lastDigit);
            };
            
            // Apply rounding to width and height
            const roundedWidth = roundWidth(Math.round(width));
            const roundedHeight = roundWidth(Math.round(height));
            
            // Just return the clean dimensions without aspect ratio info
            return `${roundedWidth}×${roundedHeight}`;
        };
        
        const updateFileInfoDisplay = () => { 
            if (!video?.duration || !video?.videoWidth || !video?.videoHeight || 
                !resolutionValue || !lengthValue || !aspectRatioValue || !bitrateValue) return; 
            
            currentVideoDuration = video.duration;
            
            // Use cropped dimensions if black bars removal is enabled
            let width = video.videoWidth;
            let height = video.videoHeight;
            
            // If we have crop data and black bar removal is enabled, use the cropped dimensions
            if (removeBarsEnabled && cropData && cropData.cropWidth > 0 && cropData.cropHeight > 0) {
                width = cropData.cropWidth;
                height = cropData.cropHeight;
            }
            
            lengthValue.textContent = formatTime(currentVideoDuration);
            
            // Update resolution display with standardized format - no cropped label needed
            resolutionValue.textContent = getStandardizedResolution(width, height);
            
            // Calculate aspect ratio from the current dimensions (cropped or original)
            aspectRatioValue.textContent = getCommonAspectRatio(width, height);
            
            if (uploadedFile && uploadedFile.size > 0 && currentVideoDuration > 0) {
                const bitrateKbps = Math.round((uploadedFile.size * 8) / currentVideoDuration / 1000);
                bitrateValue.textContent = `${bitrateKbps} kbps`;
            } else {
                bitrateValue.textContent = "N/A";
            }
        };
        const updateImageCount = () => { 
            const autoSmartCount = screenshotBlobs.length; 
            const manualCount = manualScreenshotBlobs.length; 
            const totalCount = screenshotsDiv ? screenshotsDiv.childElementCount : 0; 
            
            if (imageCountValue) {
                // First update the display value
                imageCountValue.textContent = totalCount;
                
                // Remove all mode-specific classes
                imageCountValue.classList.remove('interval-mode', 'smart-mode', 'manual-mode', 'contact-sheet-mode');
                
                // Add the appropriate class based on current mode
                if (currentMode === 'auto') {
                    imageCountValue.classList.add('interval-mode');
                } else if (currentMode === 'autoSmart') {
                    imageCountValue.classList.add('smart-mode');
                } else if (currentMode === 'manual') {
                    imageCountValue.classList.add('manual-mode');
                } else if (currentMode === 'contactSheet') {
                    imageCountValue.classList.add('contact-sheet-mode');
                }
            }
            
            if(downloadAllButton) downloadAllButton.disabled = currentMode !== 'auto' || autoSmartCount === 0 || processingActive; 
            if(downloadAllSmartButton) downloadAllSmartButton.disabled = currentMode !== 'autoSmart' || autoSmartCount === 0 || processingActive; 
            if(downloadManualButton) downloadManualButton.disabled = currentMode !== 'manual' || manualCount === 0 || processingActive; 
            if(downloadContactSheetButton) downloadContactSheetButton.disabled = currentMode !== 'contactSheet' || !contactSheetBlob || processingActive; 
            if(previewContactSheetButton) previewContactSheetButton.disabled = currentMode !== 'contactSheet' || !contactSheetBlob || processingActive; 
            if(clearScreenshotsButton) clearScreenshotsButton.disabled = totalCount === 0 && !contactSheetPreviewData.some(d => d !== null); 
        };
        const updateDropZoneUI = (isFileLoaded, filename) => { 
          if(!dropZone || !selectFileButton || !loadedFileName) return; 
          
          if (isFileLoaded && filename) { 
            dropZone.classList.add('file-loaded'); 
            loadedFileName.textContent = filename; 
            selectFileButton.textContent = "Change File"; 
            selectFileButton.classList.add('file-selected'); 
            updateFileInfoDisplay(); 
          } else { 
            dropZone.classList.remove('file-loaded');
            dropZone.classList.remove('has-bg-image');
            
            // Clean up any existing background image blob URL
            const oldBgUrl = dropZone.dataset.bgUrl;
            if (oldBgUrl) {
                URL.revokeObjectURL(oldBgUrl);
                dropZone.dataset.bgUrl = '';
            }
            
            // Reset the background image CSS variable
            document.documentElement.style.setProperty('--dropzone-bg-image', 'none');
             
            loadedFileName.textContent = ''; 
            selectFileButton.textContent = "Change File"; 
            selectFileButton.classList.remove('file-selected'); 
            if(resolutionValue) resolutionValue.textContent = '-'; 
            if(lengthValue) lengthValue.textContent = '-'; 
            if(aspectRatioValue) aspectRatioValue.textContent = '-'; 
            if(bitrateValue) bitrateValue.textContent = '-'; 
          } 
        };

        // --- UI State Management ---
        const resetProcessingUI = (mode = 'all') => { /* ... */ 
            console.log(`[Reset UI] Resetting for mode: ${mode}`); 
            processingActive = false; 
            cancelExtractionRequested = false; 
            currentSamplingProcess = null; 
            
            if (verticalSeparatorElement) 
                verticalSeparatorElement.classList.remove('loading', 'loading-smart', 'loading-contact-sheet'); 
                
            const resetButton = (btn, text, startHandler) => { 
                if (!btn) return; 
                btn.disabled = !video?.src; 
                btn.textContent = text; 
                btn.classList.remove('cancel-active'); 
                btn.removeEventListener('click', handleCancelClick); 
                btn.removeEventListener('click', startHandler); 
                btn.addEventListener('click', startHandler); 
            }; 
            
            if ((mode === 'auto' || mode === 'all') && processButton) { 
                if(progressBarAuto) progressBarAuto.style.display = 'none'; 
                if(progressBarFillAuto) progressBarFillAuto.style.width = '0%'; 
                resetButton(processButton, 'Extract Screenshots', startAutoExtraction); 
                if(downloadAllButton) downloadAllButton.disabled = currentMode !== 'auto' || screenshotBlobs.length === 0; 
            } 
            
            if ((mode === 'autoSmart' || mode === 'all') && processSmartButton) { 
                if(progressBarSmart) progressBarSmart.style.display = 'none'; 
                if(progressBarFillSmart) progressBarFillSmart.style.width = '0%'; 
                resetButton(processSmartButton, 'Extract Smart Shots', startSmartExtraction); 
                if(downloadAllSmartButton) downloadAllSmartButton.disabled = currentMode !== 'autoSmart' || screenshotBlobs.length === 0; 
            } 
            
            if ((mode === 'contactSheet' || mode === 'all') && processContactSheetButton) { 
                if(progressBarContactSheet) progressBarContactSheet.style.display = 'none'; 
                if(progressBarFillContactSheet) progressBarFillContactSheet.style.width = '0%'; 
                resetButton(processContactSheetButton, 'Generate/Update Sheet', generateContactSheet); 
                if(downloadContactSheetButton) downloadContactSheetButton.disabled = currentMode !== 'contactSheet' || !contactSheetBlob;
                if(previewContactSheetButton) previewContactSheetButton.disabled = currentMode !== 'contactSheet' || !contactSheetBlob;
            } 
            
            if (mode === 'manual' || mode === 'all') { 
                if(addManualButton) addManualButton.disabled = !video?.src; 
                if(extractManualButton) extractManualButton.disabled = !video?.src; 
                if(downloadManualButton) downloadManualButton.disabled = currentMode !== 'manual' || manualScreenshotBlobs.length === 0 || processingActive; 
            } 
            
            if (video?.src) { 
                if(processButton && currentMode !== 'auto') processButton.disabled = false; 
                if(processSmartButton && currentMode !== 'autoSmart') processSmartButton.disabled = false; 
                if(processContactSheetButton && currentMode !== 'contactSheet') processContactSheetButton.disabled = false; 
                if(addManualButton && currentMode !== 'manual') addManualButton.disabled = false; 
                if(extractManualButton && currentMode !== 'manual') extractManualButton.disabled = false; 
            } 
            
            updateImageCount(); 
        };
        
        const setProcessingUI = (mode) => { /* ... */ 
            console.log(`[Set UI] Setting processing state for mode: ${mode}`); 
            processingActive = true; 
            cancelExtractionRequested = false; 
            
            [processButton, processSmartButton, processContactSheetButton, downloadAllButton, downloadAllSmartButton, downloadManualButton, downloadContactSheetButton, addManualButton, extractManualButton, clearScreenshotsButton].forEach(btn => { 
                if (btn) btn.disabled = true; 
            }); 
            
            let processBtn, progressBar, progressBarFill, startHandler, loadingClass; 
            
            if (mode === 'auto' && processButton) { 
                processBtn = processButton; 
                progressBar = progressBarAuto; 
                progressBarFill = progressBarFillAuto; 
                startHandler = startAutoExtraction; 
                loadingClass = 'loading'; 
            } else if (mode === 'autoSmart' && processSmartButton) { 
                processBtn = processSmartButton; 
                progressBar = progressBarSmart; 
                progressBarFill = progressBarFillSmart; 
                startHandler = startSmartExtraction; 
                loadingClass = 'loading-smart'; 
            } else if (mode === 'contactSheet' && processContactSheetButton) { 
                processBtn = processContactSheetButton; 
                progressBar = progressBarContactSheet; 
                progressBarFill = progressBarFillContactSheet; 
                startHandler = generateContactSheet; 
                loadingClass = 'loading-contact-sheet'; 
            } else { 
                return; 
            } 
            
            if (verticalSeparatorElement && loadingClass) 
                verticalSeparatorElement.classList.add(loadingClass); 
                
            if (progressBar) 
                progressBar.style.display = 'block'; 
                
            if (progressBarFill) 
                progressBarFill.style.width = '0%'; 
                
            processBtn.textContent = 'Cancel Extraction'; 
            processBtn.classList.add('cancel-active'); 
            processBtn.removeEventListener('click', startHandler);
            
            // More robust event listener attachment and cleanup for the cancel button
            processBtn.removeEventListener('click', handleCancelClick);  
            processBtn.addEventListener('click', handleCancelClick); 
            processBtn.disabled = false; 
        };

        // Cancel Handler
        const handleCancelClick = () => {
            console.log("[Cancel Action] Cancel requested by user");
            
            // Set the cancellation flag - the extraction loops will detect this
            cancelExtractionRequested = true;
            
            // If we have an active sampling process, explicitly cancel it
            if (currentSamplingProcess && typeof currentSamplingProcess.cancel === 'function') {
                console.log("[Cancel Action] Calling cancel on active sampling process");
                currentSamplingProcess.cancel();
            }
            
            // Simple failsafe: Force reset after a short delay if still processing
            setTimeout(() => {
                if (processingActive) {
                    console.log("[Cancel Action] Forcing reset of UI");
                    resetProcessingUI(currentMode);
                }
            }, 300);
        };

        // --- Helper Functions (Cont.) ---
        const computeHistogram = (imageData, sampleFactor = 4) => { /* ... */ const data = imageData.data; const hist = new Array(256).fill(0); let count = 0; for (let i = 0; i < data.length; i += 4 * sampleFactor) { const gray = Math.round(0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]); hist[gray]++; count++; } if (count === 0) return hist; return hist.map(val => val / count); };
        const histogramDifference = (hist1, hist2) => { /* ... */ if (!hist1 || !hist2 || hist1.length !== hist2.length) return 1; return hist1.reduce((acc, val, i) => acc + Math.abs(val - hist2[i]), 0); };
        const computePixelDiff = (data1, data2, sampleFactor = 4) => { /* ... */ let diff = 0; let count = 0; const step = 4 * sampleFactor; for (let i = 0; i < data1.length; i += step) { diff += Math.abs(data1[i] - data2[i]); diff += Math.abs(data1[i+1] - data2[i+1]); diff += Math.abs(data1[i+2] - data2[i+2]); count++; } return count > 0 ? (diff / (count * 3)) : 0; };
        
        const computeSSIM = (imageData1, imageData2, sampleFactor = 4) => {
            const data1 = imageData1.data;
            const data2 = imageData2.data;
            const width = imageData1.width;
            const height = imageData1.height;
            
            // Constants for stability and avoiding division by zero
            const K1 = 0.01, K2 = 0.03;
            const L = 255; // Dynamic range for 8-bit images
            const C1 = (K1 * L) ** 2;
            const C2 = (K2 * L) ** 2;
            
            // Block size for local analysis
            const blockSize = Math.min(8, Math.max(4, sampleFactor * 2));
            const step = Math.max(4, blockSize / 2) * 4; // Step in pixels (x4 for RGBA)
            
            let ssim_sum = 0;
            let blocks = 0;
            
            // For detecting motion in static scenes
            let motionScore = 0;
            let maxMotionRegion = 0;
            const motionThreshold = 30; // Threshold for significant motion
            
            // Track regions with significant changes
            const regionsX = 3; // Divide image into a 3x3 grid
            const regionsY = 3;
            const regionScores = Array(regionsX * regionsY).fill(0);
            
            // Process in blocks to better capture structural information
            for (let y = 0; y < height - blockSize; y += blockSize) {
                for (let x = 0; x < width - blockSize; x += blockSize) {
                    let sum1 = 0, sum2 = 0;
                    let sum1_sq = 0, sum2_sq = 0;
                    let sum_cross = 0;
                    let count = 0;
                    let blockMotion = 0;
                    
                    // Process pixels within the block
                    for (let by = 0; by < blockSize; by += 1) {
                        for (let bx = 0; bx < blockSize; bx += 1) {
                            const i = ((y + by) * width + (x + bx)) * 4;
                            
                            // Convert to grayscale to simplify calculations
                            const gray1 = 0.299 * data1[i] + 0.587 * data1[i + 1] + 0.114 * data1[i + 2];
                            const gray2 = 0.299 * data2[i] + 0.587 * data2[i + 1] + 0.114 * data2[i + 2];
                            
                            // Accumulate absolute difference for motion detection
                            blockMotion += Math.abs(gray1 - gray2);
                            
                            sum1 += gray1;
                            sum2 += gray2;
                            sum1_sq += gray1 * gray1;
                            sum2_sq += gray2 * gray2;
                            sum_cross += gray1 * gray2;
                            count++;
                        }
                    }
                    
                    if (count === 0) continue;
                    
                    // Calculate mean and variance for both patches
                    const mean1 = sum1 / count;
                    const mean2 = sum2 / count;
                    const variance1 = sum1_sq / count - mean1 * mean1;
                    const variance2 = sum2_sq / count - mean2 * mean2;
                    const covariance = sum_cross / count - mean1 * mean2;
                    
                    // Calculate SSIM for this block
                    // (2*μx*μy + C1) * (2*σxy + C2) / ((μx² + μy² + C1) * (σx² + σy² + C2))
                    const numerator = (2 * mean1 * mean2 + C1) * (2 * covariance + C2);
                    const denominator = (mean1 * mean1 + mean2 * mean2 + C1) * (variance1 + variance2 + C2);
                    
                    // Avoid division by zero
                    const blockSSIM = denominator > 0 ? numerator / denominator : 1;
                    
                    // Calculate average motion in this block
                    const avgMotion = blockMotion / count;
                    motionScore += avgMotion;
                    
                    // Record motion in grid regions to detect localized changes
                    const regionX = Math.floor((x / width) * regionsX);
                    const regionY = Math.floor((y / height) * regionsY);
                    const regionIndex = regionY * regionsX + regionX;
                    if (regionIndex >= 0 && regionIndex < regionScores.length) {
                        regionScores[regionIndex] += avgMotion;
                    }
                    
                    ssim_sum += blockSSIM;
                    blocks++;
                }
            }
            
            // Get average SSIM
            const avgSSIM = blocks > 0 ? ssim_sum / blocks : 1;
            // Get average motion
            const avgMotion = blocks > 0 ? motionScore / blocks : 0;
            
            // Find the region with maximum motion (to detect local changes in static scenes)
            maxMotionRegion = Math.max(...regionScores);
            const hasSignificantLocalMotion = maxMotionRegion > motionThreshold * 3;
            
            // Adjust SSIM for static scenes with talking
            // If there's some motion but overall SSIM is high, this might be dialogue
            if (avgSSIM > 0.85 && avgMotion < motionThreshold && !hasSignificantLocalMotion) {
                // Make it less sensitive in static dialogue scenes
                return Math.min(1, avgSSIM + 0.1);
            }
            
            // If there's significant motion in a specific region (like a face moving)
            // but the overall frame is static, boost the difference
            if (avgSSIM > 0.75 && hasSignificantLocalMotion) {
                return avgSSIM * 0.9;
            }
            
            return avgSSIM;
        };
        
        const createScreenshotElement = (blob, timestamp, blobArrayRef) => { /* ... */ if(!screenshotsDiv || !blob) return null; const container = document.createElement('div'); container.className = "screenshot-container"; const blobUrl = URL.createObjectURL(blob); container.dataset.blobUrl = blobUrl; container.dataset.timestamp = String(timestamp); const a = document.createElement('a'); a.href = blobUrl; a.target = "_blank"; const img = document.createElement('img'); img.src = blobUrl; img.alt = `Screenshot at ${formatTime(timestamp)}`; a.appendChild(img); container.appendChild(a); if (timestamp >= 0) { const overlay = document.createElement('div'); overlay.className = "screenshot-overlay"; overlay.textContent = formatTime(timestamp); container.appendChild(overlay); } const delBtn = document.createElement('button'); delBtn.className = "delete-btn"; delBtn.innerHTML = "×"; delBtn.title = "Remove this screenshot"; delBtn.addEventListener('click', (e) => { e.stopPropagation(); const urlToRemove = container.dataset.blobUrl; const timeToRemove = parseFloat(container.dataset.timestamp); const indexToRemove = blobArrayRef.findIndex(item => item.timestamp === timeToRemove && item.blob?.size === blob.size); if (indexToRemove > -1) { blobArrayRef.splice(indexToRemove, 1); } else { console.warn("Could not find blob to remove."); } URL.revokeObjectURL(urlToRemove); container.remove(); updateImageCount(); }); container.appendChild(delBtn); return container; };
        const getCurrentFormatSettings = () => { /* ... */ let format = 'png'; let qualitySlider = null; let qualityValue = 1.0; const activeModeId = document.querySelector('.mode-content > div.active')?.id; const formatTabsContainerId = (activeModeId === 'manualMode' || activeModeId === 'contactSheetMode') ? 'autoMode' : activeModeId; const activeFormatTab = document.querySelector(`#${formatTabsContainerId} .format-tab.active`); if (activeFormatTab) format = activeFormatTab.getAttribute('data-format') || 'png'; if (format === 'jpeg') { qualitySlider = (activeModeId === 'autoSmartMode') ? jpegQualitySmart : jpegQualityAuto; qualityValue = qualitySlider ? parseFloat(qualitySlider.value) / 100 : 0.85; } else if (format === 'webp') { qualitySlider = (activeModeId === 'autoSmartMode') ? webpQualitySmart : webpQualityAuto; qualityValue = qualitySlider ? parseFloat(qualitySlider.value) / 100 : 0.85; } const type = `image/${format}`; return { type, quality: qualityValue }; };
        const downloadBlobsAsZip = (blobDataArray, baseFilename = "screenshots") => { /* ... */ if (!blobDataArray || blobDataArray.length === 0) { alert("No screenshots to download."); return; } if (!window.JSZip) { alert("Error: JSZip library not loaded."); return; } const zip = new JSZip(); const { type } = getCurrentFormatSettings(); const extension = type.split('/')[1] === 'jpeg' ? 'jpg' : type.split('/')[1]; blobDataArray.forEach((item, index) => { if (!item || !item.blob) return; const timeSuffix = (item.timestamp !== undefined && item.timestamp >= 0) ? `_${formatTime(item.timestamp).replace(':','-')}` : `_${index + 1}`; const filename = `${baseFilename}${timeSuffix}.${extension}`; zip.file(filename, item.blob); }); zip.generateAsync({ type: "blob" }).then((content) => { const tempLink = document.createElement('a'); const url = URL.createObjectURL(content); tempLink.href = url; tempLink.download = `${baseFilename}.zip`; document.body.appendChild(tempLink); tempLink.click(); document.body.removeChild(tempLink); URL.revokeObjectURL(url); }).catch((err) => { console.error("Error generating ZIP:", err); alert("Error creating ZIP file: " + err.message); }); };
        const handleFileLoad = (file) => { 
            if (!video || !manualVideo || !contactSheetVideo || !file) return; 
            uploadedFile = file; 
            const fileURL = URL.createObjectURL(file); 
            video.src = fileURL; 
            manualVideo.src = fileURL; 
            contactSheetVideo.src = fileURL; 
            updateDropZoneUI(true, file.name); 
            resetUIOnNewVideo(); 
            
            // Wait for video metadata to be loaded
            if (video.readyState >= 1) {
                // Set timeout to ensure the video has loaded enough
                setTimeout(updateDropZoneThumbnail, 500);
            } else {
                video.addEventListener('loadeddata', () => {
                    setTimeout(updateDropZoneThumbnail, 500);
                }, { once: true });
            }
        };
        const resetUIOnNewVideo = () => { 
            if(screenshotsDiv) screenshotsDiv.innerHTML = ''; 
            screenshotBlobs = []; 
            manualScreenshotBlobs = []; 
            contactSheetBlob = null; 
            cropData = null; 
            clearContactSheetPreview(true);
            
            // Reset grid cache for new video
            gridCache = {
                '5x4': { data: null, blob: null, completed: false },
                '4x3': { data: null, blob: null, completed: false },
                '3x2': { data: null, blob: null, completed: false }
            };
            
            // Clear completion markers
            document.querySelectorAll('.grid-size-tab').forEach(tab => {
                tab.classList.remove('completed');
            });
            
            updateImageCount(); 
            resetProcessingUI('all'); 
        };

        // --- Refactored Sampling Logic ---
        const sampleVideoFrames = (options) => {
            const { videoElement = video, // Allow specifying which video element
                    sampleTimestamps, // Provide timestamps directly
                    outputType, useCrop,
                    processFrameCallback, onCompleteCallback, onProgressCallback, onErrorCallback } = options;

            let localCancelRequested = false; 
            let currentSampleIndex = 0; 
            const collectedData = [];

            // Early validations with proper cancel checks
            if (!videoElement || !videoElement.src || videoElement.readyState < videoElement.HAVE_METADATA || videoElement.duration <= 0) { 
                const error = new Error("Video not ready for sampling."); 
                if (onErrorCallback) onErrorCallback(error); 
                else console.error(error); 
                if (onCompleteCallback) onCompleteCallback(collectedData);
                return { 
                    cancel: () => {
                        console.log("[sampleVideoFrames] Cancellation requested on invalid video.");
                        localCancelRequested = true;
                    } 
                }; 
            }
            
            if (!sampleTimestamps || sampleTimestamps.length === 0) { 
                const error = new Error("No timestamps provided for sampling."); 
                if (onErrorCallback) onErrorCallback(error); 
                else console.error(error); 
                if (onCompleteCallback) onCompleteCallback(collectedData);
                return { 
                    cancel: () => {
                        console.log("[sampleVideoFrames] Cancellation requested on empty timestamps.");
                        localCancelRequested = true;
                    } 
                }; 
            }

            const totalSamples = sampleTimestamps.length;
            
            // Check for external cancellation flag
            const checkCancelled = () => localCancelRequested || cancelExtractionRequested;

            const processNext = () => {
                // Check cancellation first thing
                if (checkCancelled()) {
                    console.log("[sampleVideoFrames] Cancelled before processing frame");
                    if (onCompleteCallback) onCompleteCallback(collectedData);
                    return;
                }

                if (currentSampleIndex >= sampleTimestamps.length) {
                    console.log("[sampleVideoFrames] All samples processed");
                    if (onCompleteCallback) onCompleteCallback(collectedData);
                    return;
                }

                const timestamp = sampleTimestamps[currentSampleIndex];
                
                // Calculate and report progress percentage
                if (onProgressCallback) {
                    const progress = Math.min(Math.round((currentSampleIndex / totalSamples) * 100), 100);
                    onProgressCallback(progress);
                }

                const captureCurrentFrame = (callback) => {
                    // Check cancellation before starting frame capture
                    if (checkCancelled()) {
                        console.log(`[sampleVideoFrames] Cancelled before capturing frame at ${timestamp.toFixed(2)}s`);
                        callback(null);
                        return;
                    }

                    try {
                        const ctx = frameCanvas.getContext('2d', { willReadFrequently: true });
                        if (!ctx) throw new Error("Could not get 2d context for frame canvas");

                        let seekTimeout = setTimeout(() => {
                            videoElement.removeEventListener('seeked', onSeeked);
                            videoElement.removeEventListener('error', onError);
                            console.warn(`[sampleVideoFrames] Seek timeout for frame at ${timestamp.toFixed(2)}s`);
                            callback(null);
                        }, 5000);

                        const onSeeked = () => {
                            clearTimeout(seekTimeout);
                            videoElement.removeEventListener('error', onError);
                            
                            // Check cancellation after seek completes
                            if (checkCancelled()) {
                                console.log(`[sampleVideoFrames] Cancelled after seeking to ${timestamp.toFixed(2)}s`);
                                callback(null);
                                return;
                            }

                            try {
                                const sourceX = (useCrop && cropData) ? cropData.cropX : 0;
                                const sourceY = (useCrop && cropData) ? cropData.cropY : 0;
                                const sourceWidth = (useCrop && cropData && cropData.cropWidth > 0) ? cropData.cropWidth : videoElement.videoWidth;
                                const sourceHeight = (useCrop && cropData && cropData.cropHeight > 0) ? cropData.cropHeight : videoElement.videoHeight;

                                if (sourceWidth <= 0 || sourceHeight <= 0) {
                                    throw new Error("Invalid dimensions for drawing");
                                }

                                frameCanvas.width = sourceWidth;
                                frameCanvas.height = sourceHeight;
                                
                                ctx.drawImage(videoElement, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, sourceWidth, sourceHeight);
                                
                                // Handle various output types
                                if (outputType === 'blob') {
                                    const { type, quality } = getCurrentFormatSettings();
                                    frameCanvas.toBlob((blob) => {
                                        // Check cancellation after blob creation
                                        if (checkCancelled()) {
                                            console.log(`[sampleVideoFrames] Cancelled after blob creation at ${timestamp.toFixed(2)}s`);
                                            callback(null);
                                            return;
                                        }
                                        callback(blob);
                                    }, type, quality);
                                } 
                                else {
                                    callback(frameCanvas.toDataURL('image/png'));
                                }
                            } catch (error) {
                                console.error(`[sampleVideoFrames] Draw error at ${timestamp.toFixed(2)}s:`, error);
                                callback(null);
                            }
                        };

                        const onError = (e) => {
                            console.error(`[sampleVideoFrames] Video error at ${timestamp.toFixed(2)}s:`, e);
                            clearTimeout(seekTimeout);
                            videoElement.removeEventListener('seeked', onSeeked);
                            callback(null);
                        };

                        videoElement.addEventListener('seeked', onSeeked, { once: true });
                        videoElement.addEventListener('error', onError, { once: true });

                        const targetTime = Math.max(0, Math.min(timestamp, videoElement.duration - 0.01));
                        videoElement.currentTime = targetTime;
                    } catch (error) {
                        console.error(`[sampleVideoFrames] Error setting up frame capture at ${timestamp.toFixed(2)}s:`, error);
                        callback(null);
                    }
                };

                captureCurrentFrame((frameData, error) => {
                    // Check cancellation before processing the result
                    if (checkCancelled()) { 
                        console.log(`[sampleVideoFrames] Cancelled during frame ${currentSampleIndex} callback`); 
                        if (onCompleteCallback) onCompleteCallback(collectedData); 
                        return; 
                    }
                    
                    if (error || !frameData) { 
                        console.warn(`[sampleVideoFrames] Failed to capture frame at ${timestamp.toFixed(2)}s:`, error || "No data returned"); 
                    }
                    else {
                        try {
                            // Pass the index along with the data and timestamp
                            processFrameCallback(frameData, timestamp, currentSampleIndex);
                            collectedData[currentSampleIndex] = { data: frameData, timestamp }; // Store successful data
                        } catch (processError) { 
                            console.error(`[sampleVideoFrames] Error in processFrameCallback at ${timestamp.toFixed(2)}s:`, processError); 
                            if (onErrorCallback) onErrorCallback(processError); 
                        }
                    }
                    
                    // Check cancellation again before scheduling next frame
                    if (checkCancelled()) { 
                        console.log(`[sampleVideoFrames] Cancelled after processing frame ${currentSampleIndex}`); 
                        if (onCompleteCallback) onCompleteCallback(collectedData); 
                        return; 
                    }
                    
                    currentSampleIndex++; 
                    requestAnimationFrame(processNext); // Use rAF for next step
                });
            };
            
            // Start the process
            requestAnimationFrame(processNext);
            
            // Return an object with cancel method
            return { 
                cancel: () => { 
                    console.log("[sampleVideoFrames] Cancellation explicitly requested."); 
                    localCancelRequested = true; 
                } 
            };
        };


        // --- Black Bars Detection (Uses Sampler with calculated times) ---
        const detectCropBoundariesMulti = (callback) => {
            if (!video || !video.src || video.readyState < 2 || !video.duration || !isFinite(video.duration) ||
                video.videoWidth === 0 || video.videoHeight === 0) {
                console.warn("Video not ready for crop detection.");
                cropData = { cropX: 0, cropY: 0, cropWidth: video.videoWidth || 1, cropHeight: video.videoHeight || 1 };
                if (callback) callback();
                return;
            }
            
            // Define sample times at 30%, 50%, and 70% of video duration
            const samplePercents = [0.3, 0.5, 0.7];
            const sampleTimes = samplePercents.map(
                (p) => Math.min(Math.max(p * video.duration, 0.1), video.duration - 0.1)
            );
            let sampleResults = [];
            let currentSample = 0;

            // Helper function to analyze the current frame for black borders
            function analyzeFrame(callbackFrame) {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = video.videoWidth;
                tempCanvas.height = video.videoHeight;
                const ctx = tempCanvas.getContext("2d");
                ctx.drawImage(video, 0, 0, video.videoWidth, video.videoHeight);
                const imageData = ctx.getImageData(0, 0, video.videoWidth, video.videoHeight);
                const data = imageData.data,
                    width = video.videoWidth,
                    height = video.videoHeight;
                const pixelThreshold = 15,
                    lineRatioThreshold = 0.98;
                let topCrop = 0,
                    bottomCrop = height - 1,
                    leftCrop = 0,
                    rightCrop = width - 1;

                // Detect top crop boundary
                for (let y = 0; y < height / 2; y++) {
                    let blackPxCount = 0;
                    for (let x = 0; x < width; x++) {
                        const i = (y * width + x) * 4;
                        if (data[i] < pixelThreshold && data[i + 1] < pixelThreshold && data[i + 2] < pixelThreshold) {
                            blackPxCount++;
                        }
                    }
                    if (blackPxCount / width < lineRatioThreshold) {
                        topCrop = y;
                        break;
                    }
                    if (y === Math.floor(height / 2) - 1) topCrop = y;
                }

                // Detect bottom crop boundary
                for (let y = height - 1; y >= height / 2; y--) {
                    let blackPxCount = 0;
                    for (let x = 0; x < width; x++) {
                        const i = (y * width + x) * 4;
                        if (data[i] < pixelThreshold && data[i + 1] < pixelThreshold && data[i + 2] < pixelThreshold) {
                            blackPxCount++;
                        }
                    }
                    if (blackPxCount / width < lineRatioThreshold) {
                        bottomCrop = y;
                        break;
                    }
                    if (y === Math.ceil(height / 2)) bottomCrop = y;
                }

                // Detect left crop boundary
                for (let x = 0; x < width / 2; x++) {
                    let blackPxCount = 0;
                    for (let y = topCrop; y <= bottomCrop; y++) {
                        const i = (y * width + x) * 4;
                        if (data[i] < pixelThreshold && data[i + 1] < pixelThreshold && data[i + 2] < pixelThreshold) {
                            blackPxCount++;
                        }
                    }
                    if (blackPxCount / (bottomCrop - topCrop + 1) < lineRatioThreshold) {
                        leftCrop = x;
                        break;
                    }
                    if (x === Math.floor(width / 2) - 1) leftCrop = x;
                }

                // Detect right crop boundary
                for (let x = width - 1; x >= width / 2; x--) {
                    let blackPxCount = 0;
                    for (let y = topCrop; y <= bottomCrop; y++) {
                        const i = (y * width + x) * 4;
                        if (data[i] < pixelThreshold && data[i + 1] < pixelThreshold && data[i + 2] < pixelThreshold) {
                            blackPxCount++;
                        }
                    }
                    if (blackPxCount / (bottomCrop - topCrop + 1) < lineRatioThreshold) {
                        rightCrop = x;
                        break;
                    }
                    if (x === Math.ceil(width / 2)) rightCrop = x;
                }

                callbackFrame({ topCrop, bottomCrop, leftCrop, rightCrop });
            }

            // Helper function to compute the median of an array of numbers
            function median(arr) {
                const sorted = arr.slice().sort((a, b) => a - b);
                return sorted[Math.floor(sorted.length / 2)];
            }

            // Process each sample sequentially
            function processNextSample() {
                if (currentSample >= sampleTimes.length) {
                    // Combine sample results by taking the median for each boundary
                    const topCrops = sampleResults.map((r) => r.topCrop);
                    const bottomCrops = sampleResults.map((r) => r.bottomCrop);
                    const leftCrops = sampleResults.map((r) => r.leftCrop);
                    const rightCrops = sampleResults.map((r) => r.rightCrop);

                    const finalTop = median(topCrops);
                    const finalBottom = median(bottomCrops);
                    const finalLeft = median(leftCrops);
                    const finalRight = median(rightCrops);

                    const finalCropWidth = Math.max(1, finalRight - finalLeft + 1);
                    const finalCropHeight = Math.max(1, finalBottom - finalTop + 1);

                    cropData = {
                        cropX: finalLeft,
                        cropY: finalTop,
                        cropWidth: finalCropWidth,
                        cropHeight: finalCropHeight,
                    };
                    
                    console.log("Detected black bars crop data:", cropData);
                    if (callback) callback();
                    return;
                }
                
                // Set up listener for each sample's seek event
                const sampleTime = sampleTimes[currentSample];
                video.addEventListener(
                    "seeked",
                    function onSeeked() {
                        video.removeEventListener("seeked", onSeeked);
                        analyzeFrame((boundaries) => {
                            sampleResults.push(boundaries);
                            currentSample++;
                            processNextSample();
                        });
                    },
                    { once: true }
                );
                
                // Handle errors during seeking
                video.addEventListener(
                    "error",
                    function onError(e) {
                        console.error("Seek error during crop detection:", e);
                        video.removeEventListener("error", onError);
                        // In case of an error, default to full frame for this sample
                        sampleResults.push({
                            topCrop: 0,
                            bottomCrop: video.videoHeight - 1,
                            leftCrop: 0,
                            rightCrop: video.videoWidth - 1
                        });
                        currentSample++;
                        processNextSample();
                    },
                    { once: true }
                );
                
                try {
                    video.currentTime = sampleTime;
                } catch (error) {
                    console.error("Error setting video time:", error);
                    sampleResults.push({
                        topCrop: 0,
                        bottomCrop: video.videoHeight - 1,
                        leftCrop: 0,
                        rightCrop: video.videoWidth - 1
                    });
                    currentSample++;
                    processNextSample();
                }
            }

            processNextSample();
         };


        // --- Event Listeners Setup ---
        if (pageTitle) pageTitle.addEventListener('click', () => window.location.reload());
        if (video) video.addEventListener('loadedmetadata', () => {
            updateFileInfoDisplay(); 
             resetProcessingUI('all');
            
            // If remove bars toggle is enabled, detect black bars when a new video loads
            if (removeBarsEnabled) {
                // Small delay to ensure video is ready
                setTimeout(() => {
                    detectCropBoundariesMulti(() => {
                        console.log("Black bar detection completed for new video");
                        
                        // Update thumbnail and stats after detection completes
                        updateDropZoneThumbnail();
                        updateFileInfoDisplay(); // Update stats again with crop data
                    });
                }, 100);
            } else {
                // Just update the thumbnail normally without crop
                setTimeout(updateDropZoneThumbnail, 100);
            }
         });
        // Sync contactSheetVideo playback time if user scrubs it
        if (contactSheetVideo) {
            contactSheetVideo.addEventListener('timeupdate', () => {
                if (!processingActive && currentMode === 'contactSheet') {
                   // Optional: Update an input field if needed, or just use for playback
                }
            });
        }

        // File Upload Listeners
        if (videoInput) videoInput.addEventListener('change', (event) => { const file = event.target.files[0]; if (file) handleFileLoad(file); });
        if (dropZone) { /* ... */ dropZone.addEventListener('dragover', (e) => { e.preventDefault(); if (!dropZone.classList.contains('file-loaded')) dropZone.classList.add('hover'); }); dropZone.addEventListener('dragleave', (e) => { e.preventDefault(); dropZone.classList.remove('hover'); }); dropZone.addEventListener('drop', (e) => { e.preventDefault(); dropZone.classList.remove('hover'); const file = e.dataTransfer.files[0]; if (file && file.type.startsWith('video/')) handleFileLoad(file); else alert("Please drop a valid video file."); }); 
        
        // Updated to handle both states
        dropZone.addEventListener('click', (e) => { 
          if (dropZone.classList.contains('file-loaded')) {
            // If file is loaded and click is not on the change file button
            if (selectFileButton && !selectFileButton.contains(e.target) && videoInput) videoInput.click();
          } else {
            // If no file is loaded and click is not on the initial button
            if (initialSelectFileButton && !initialSelectFileButton.contains(e.target) && videoInput) videoInput.click();
          }
        }); 
        }
        
        // Event listeners for both buttons
        if (selectFileButton) selectFileButton.addEventListener('click', (e) => { 
          e.stopPropagation(); 
          if(videoInput) videoInput.click(); 
        });
        
        if (initialSelectFileButton) initialSelectFileButton.addEventListener('click', (e) => { 
          e.stopPropagation(); 
          if(videoInput) videoInput.click(); 
        });

        // --- Mode Tabs Listener ---
        if (modeTabs.length > 0 && modeContentDiv) {
             modeTabs.forEach(tab => {
                 tab.addEventListener('click', () => {
                   if (processingActive) return; const newMode = tab.getAttribute('data-mode'); if (!newMode || !modeContentDiv) return; currentMode = newMode; modeTabs.forEach(t => t.classList.remove('active')); tab.classList.add('active');
                   Array.from(modeContentDiv.children).forEach(contentDiv => { contentDiv.classList.toggle('active', contentDiv.id === `${newMode}Mode`); });

                   const showPreview = (newMode === 'contactSheet');
                   outputColumn.classList.toggle('show-contact-sheet', showPreview);
                   
                   // Toggle the correct button groups
                   const intervalModeButtons = document.getElementById('intervalModeButtons');
                   const smartModeButtons = document.getElementById('smartModeButtons');
                   const contactSheetModeButtons = document.getElementById('contactSheetModeButtons');
                   const manualModeButtons = document.getElementById('manualModeButtons');
                   
                   if (intervalModeButtons) intervalModeButtons.style.display = (newMode === 'auto') ? 'flex' : 'none';
                   if (smartModeButtons) smartModeButtons.style.display = (newMode === 'autoSmart') ? 'flex' : 'none';
                   if (contactSheetModeButtons) contactSheetModeButtons.style.display = (newMode === 'contactSheet') ? 'flex' : 'none';
                   if (manualModeButtons) manualModeButtons.style.display = (newMode === 'manual') ? 'flex' : 'none';
                   
                   // Toggle the correct progress bars - keep them hidden initially
                   const progressBarAuto = document.getElementById('progressBarAuto');
                   const progressBarSmart = document.getElementById('progressBarSmart');
                   const progressBarContactSheet = document.getElementById('progressBarContactSheet');
                   
                   if (progressBarAuto) progressBarAuto.style.display = 'none';
                   if (progressBarSmart) progressBarSmart.style.display = 'none';
                   if (progressBarContactSheet) progressBarContactSheet.style.display = 'none';

                   if (showPreview) {
                       initContactSheetPreview(); // Ensure grid is ready
                       generateTimeInputs(); // Initialize time inputs if needed
                   } else {
                       contactSheetBlob = null; // Reset blob if switching away
                       if(downloadContactSheetButton) downloadContactSheetButton.disabled = true;
                       if (contactSheetControlsElement) contactSheetControlsElement.style.display = 'none';
                       if (fineTuneMessageElement) fineTuneMessageElement.style.display = 'none';
                   }
                   // Clear regular screenshots if switching to contact sheet or manual
                   if (newMode === 'contactSheet' || newMode === 'manual') { if (screenshotsDiv) screenshotsDiv.innerHTML = ''; screenshotBlobs = []; manualScreenshotBlobs = []; }

                   document.querySelectorAll(`#${newMode}Mode input[type="range"]`).forEach(updateSliderBackground); updateImageCount();
                 });
             });
         }

        // --- Grid Size Tabs Listener ---
        const gridSizeTabs = document.querySelectorAll('.grid-size-tab');
        const customGridControls = document.getElementById('customGridControls');
        const customGridCols = document.getElementById('customGridCols');
        const customGridRows = document.getElementById('customGridRows');
        
        if (gridSizeTabs.length > 0) {
            gridSizeTabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    if (processingActive) return;
                    
                    // Update active tab styling
                    gridSizeTabs.forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    
                    // Get rows and cols attributes
                    let rows = parseInt(tab.getAttribute('data-rows'));
                    let cols = parseInt(tab.getAttribute('data-cols'));
                    
                    // Show/hide custom grid controls
                    const isCustom = tab.textContent.trim() === 'Custom';
                    if (customGridControls) {
                        customGridControls.style.display = isCustom ? 'block' : 'none';
                    }
                    
                    // If custom, use the values from inputs
                    if (isCustom && customGridRows && customGridCols) {
                        rows = parseInt(customGridRows.value) || 2;
                        cols = parseInt(customGridCols.value) || 3;
                        
                        // Update the custom tab's data attributes
                        tab.setAttribute('data-rows', rows);
                        tab.setAttribute('data-cols', cols);
                    }
                    
                    if (isNaN(rows) || isNaN(cols)) return;
                    
                    // Save current state if we have data
                    const previousTab = document.querySelector('.grid-size-tab.active');
                    if (previousTab && previousTab !== tab) {
                        const prevRows = parseInt(previousTab.getAttribute('data-rows'));
                        const prevCols = parseInt(previousTab.getAttribute('data-cols'));
                        const cacheKey = `${prevCols}x${prevRows}`;
                        
                        if (contactSheetPreviewData.some(item => item !== null)) {
                            gridCache[cacheKey] = {
                                data: [...contactSheetPreviewData],
                                blob: contactSheetBlob,
                                completed: previousTab.classList.contains('completed')
                            };
                        }
                    }
                    
                    // Check if we have cached data for this grid size
                    const cacheKey = `${cols}x${rows}`;
                    const cachedGrid = gridCache[cacheKey];
                    
                    if (cachedGrid?.data) {
                        // Restore from cache
                        contactSheetPreviewData = [...cachedGrid.data];
                        contactSheetBlob = cachedGrid.blob;
                        
                        // Restore cell visuals
                        clearContactSheetPreview(true); // Clear existing
                        initContactSheetPreview(rows, cols);
                        generateTimeInputs(rows, cols);
                        
                        contactSheetPreviewData.forEach((data, index) => {
                            if (data && data.blob) {
                                updatePreviewCell(index, data.blob, data.timestamp);
                                
                                // Update time input values
                                const timeInput = document.getElementById(`timeInput_${index}`);
                                const timeFormatted = document.getElementById(`timeFormatted_${index}`);
                                if (timeInput) timeInput.value = data.timestamp.toFixed(2);
                                if (timeFormatted) timeFormatted.value = formatTime(data.timestamp);
                            }
                        });
                        
                        // Show controls if we have data
                        if (contactSheetControlsElement) contactSheetControlsElement.style.display = 'grid';
                        if (fineTuneMessageElement) fineTuneMessageElement.style.display = 'block';
                        
                        if (contactSheetBlob && downloadContactSheetButton) {
                            downloadContactSheetButton.disabled = false;
                        }
                        if (previewContactSheetButton) previewContactSheetButton.disabled = !cachedGrid.blob;
                        
                        if (cachedGrid.completed) {
                            tab.classList.add('completed');
                        } else {
                            tab.classList.remove('completed');
                        }
                    } else {
                        // Initialize new grid
                        contactSheetPreviewData = new Array(rows * cols).fill(null);
                        contactSheetBlob = null;
                        
                        if (downloadContactSheetButton) {
                            downloadContactSheetButton.disabled = true;
                        }
                        
                        tab.classList.remove('completed');
                    }
                    
                    // Update the UI
                    initContactSheetPreview(rows, cols);
                    generateTimeInputs(rows, cols);
                });
            });
        }
        
        // Custom grid dimension inputs event listeners
        if (customGridCols && customGridRows) {
            const updateCustomGrid = () => {
                if (processingActive) return;
                
                // Find the custom tab by its text content
                const customTab = Array.from(gridSizeTabs).find(tab => tab.textContent.trim() === 'Custom');
                if (!customTab || !customTab.classList.contains('active')) return;
                
                const rows = Math.min(Math.max(parseInt(customGridRows.value) || 2, 1), 6);
                const cols = Math.min(Math.max(parseInt(customGridCols.value) || 3, 1), 6);
                
                // Update values to ensure they're within bounds
                customGridRows.value = rows;
                customGridCols.value = cols;
                
                // Update the custom tab's data attributes
                customTab.setAttribute('data-rows', rows);
                customTab.setAttribute('data-cols', cols);
                
                // Initialize new grid with new dimensions
                contactSheetPreviewData = new Array(rows * cols).fill(null);
                contactSheetBlob = null;
                
                if (downloadContactSheetButton) {
                    downloadContactSheetButton.disabled = true;
                }
                
                customTab.classList.remove('completed');
                
                // Update the UI
                initContactSheetPreview(rows, cols);
                generateTimeInputs(rows, cols);
            };
            
            customGridCols.addEventListener('input', updateCustomGrid);
            customGridRows.addEventListener('input', updateCustomGrid);
        }

        // --- Sliders, Toggle, Format Tabs, Algo Tabs Setup ---
        const setupSlider = (slider, displaySpan, suffix) => { 
            if (!slider || !displaySpan) return; 
            
            const updateSliderUI = () => { 
                displaySpan.textContent = slider.value + suffix; 
                updateSliderBackground(slider); 
            }; 
            
            slider.addEventListener('input', updateSliderUI); 
            updateSliderUI(); 
        };
        setupSlider(intervalInput, intervalValue, 's'); setupSlider(jpegQualityAuto, jpegQualityValueAuto, '%'); setupSlider(webpQualityAuto, webpQualityValueAuto, '%'); setupSlider(jpegQualitySmart, jpegQualityValueSmart, '%'); setupSlider(webpQualitySmart, webpQualityValueSmart, '%'); setupSlider(histThresholdInput, histThresholdValue, ''); setupSlider(pixelThresholdInput, pixelThresholdValue, ''); setupSlider(ssimThresholdInput, ssimThresholdValue, '');
        // Set up toggle handlers to sync the state across modes
        if (removeBarsToggle) removeBarsToggle.addEventListener('change', (e) => { 
            removeBarsEnabled = e.target.checked; 
            if (removeBarsEnabled && video?.src && video.readyState >= 2) {
                    detectCropBoundariesMulti(() => {
                    console.log("Black bar detection completed after toggle");
                    
                    // Update thumbnail and stats after black bar detection
                    updateDropZoneThumbnail();
                    updateFileInfoDisplay();
                });
            } else if (!removeBarsEnabled) {
                // Reset crop data when disabling
                cropData = null;
                
                // Update the dropzone thumbnail with full frame and refresh stats
                updateDropZoneThumbnail();
                updateFileInfoDisplay();
            }
        });

        // Add a function to update the dropzone thumbnail with the current crop settings
        const updateDropZoneThumbnail = () => {
            if (!video?.src || video.readyState < 1 || !dropZone) return;
            
            // Use the 25% point of the video for the preview
            const previewTime = video.duration * 0.25;
            
            // Capture frame for background (this will apply crop if enabled)
            captureFrameAtTime(previewTime, (blob) => {
                if (!blob || !dropZone) return;
                
                // Create URL from the blob
                const blobUrl = URL.createObjectURL(blob);
                
                // Clean up the previous background if it exists
                const oldBgUrl = dropZone.dataset.bgUrl;
                if (oldBgUrl) {
                    URL.revokeObjectURL(oldBgUrl);
                }
                
                // Store the URL for cleanup later
                dropZone.dataset.bgUrl = blobUrl;
                
                // Update the CSS variable directly
                document.documentElement.style.setProperty('--dropzone-bg-image', `url(${blobUrl})`);
                dropZone.classList.add('has-bg-image');
            });
        };
        const setupFormatTabs = (tabsNodeList, pngNoteEl, jpegSettingsEl, webpSettingsEl) => { /* ... */ if (tabsNodeList.length === 0 || !pngNoteEl || !jpegSettingsEl || !webpSettingsEl) return; const updateFormatVisibility = (format) => { pngNoteEl.style.display = (format === 'png') ? 'flex' : 'none'; jpegSettingsEl.style.display = (format === 'jpeg') ? 'flex' : 'none'; webpSettingsEl.style.display = (format === 'webp') ? 'flex' : 'none'; }; let initialFormat = 'png'; tabsNodeList.forEach(tab => { if (tab.classList.contains('active')) initialFormat = tab.getAttribute('data-format') || 'png'; tab.addEventListener('click', () => { if (processingActive) return; const format = tab.getAttribute('data-format'); if (!format) return; tabsNodeList.forEach(t => t.classList.remove('active')); tab.classList.add('active'); updateFormatVisibility(format); }); }); updateFormatVisibility(initialFormat); };
        setupFormatTabs(formatTabsAuto, pngNoteAuto, jpegSettingsAuto, webpSettingsAuto); setupFormatTabs(formatTabsSmart, pngNoteSmart, jpegSettingsSmart, webpSettingsSmart);
        if (smartAlgoTabs.length > 0) {
            let initialAlgo = 'histogram';
            const updateThresholdSliders = (algo) => {
                if(histThresholdSettings) histThresholdSettings.style.display = (algo === 'histogram') ? 'flex' : 'none';
                if(pixelThresholdSettings) pixelThresholdSettings.style.display = (algo === 'pixeldiff') ? 'flex' : 'none';
                if(ssimThresholdSettings) ssimThresholdSettings.style.display = (algo === 'ssim') ? 'flex' : 'none';
                
                // Update the slider background for the newly visible slider
                if(algo === 'histogram' && histThresholdInput) updateSliderBackground(histThresholdInput);
                if(algo === 'pixeldiff' && pixelThresholdInput) updateSliderBackground(pixelThresholdInput);
                if(algo === 'ssim' && ssimThresholdInput) updateSliderBackground(ssimThresholdInput);
            };
            smartAlgoTabs.forEach(tab => {
                if (tab.classList.contains('active')) initialAlgo = tab.getAttribute('data-algo') || 'histogram';
                tab.addEventListener('click', () => {
                    if (processingActive) return;
                    const algo = tab.getAttribute('data-algo');
                    if(!algo) return;
                    smartAlgorithm = algo;
                    smartAlgoTabs.forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    updateThresholdSliders(algo);
                });
            });
            smartAlgorithm = initialAlgo;
            updateThresholdSliders(initialAlgo);
        }

        // --- Processing Logic (Auto/Smart/Manual) ---
        // Capture frame function for single frames
        const captureFrameAtTime = (time, callback) => {
            if (!video || !canvas || !video.src || video.readyState < 1) {
                callback(null);
                return;
            }

            const videoElement = video;
            let seekTimeout = setTimeout(() => {
                videoElement.removeEventListener('seeked', onSeeked);
                videoElement.removeEventListener('error', onError);
                callback(null);
            }, 5000);

            const onSeeked = () => {
                clearTimeout(seekTimeout);
                videoElement.removeEventListener('error', onError);
                try {
                    const ctx = canvas.getContext('2d');
                    if (!ctx) throw new Error('Could not get 2d context');

                    // Apply black bar removal if enabled and we have crop data
                    if (removeBarsEnabled && cropData) {
                        canvas.width = cropData.cropWidth;
                        canvas.height = cropData.cropHeight;
                        ctx.drawImage(
                            videoElement, 
                            cropData.cropX, cropData.cropY, cropData.cropWidth, cropData.cropHeight,
                            0, 0, cropData.cropWidth, cropData.cropHeight
                        );
                    } else {
                        canvas.width = videoElement.videoWidth;
                        canvas.height = videoElement.videoHeight;
                        ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
                    }
                    
                    const { type, quality } = getCurrentFormatSettings();
                    canvas.toBlob((blob) => callback(blob), type, quality);
                } catch (error) {
                    console.error("[captureFrameAtTime] Error:", error);
                    callback(null);
                }
            };

            const onError = (e) => {
                console.error("[captureFrameAtTime] Video Error:", e);
                clearTimeout(seekTimeout);
                videoElement.removeEventListener('seeked', onSeeked);
                callback(null);
            };

            videoElement.addEventListener('seeked', onSeeked, { once: true });
            videoElement.addEventListener('error', onError, { once: true });

            try {
                const targetTime = Math.max(0, Math.min(time, currentVideoDuration - 0.01));
                if (Math.abs(videoElement.currentTime - targetTime) > 0.01) {
                    videoElement.currentTime = targetTime;
                } else {
                    onSeeked();
                }
            } catch (error) {
                console.error("[captureFrameAtTime] Seek Error:", error);
                clearTimeout(seekTimeout);
                videoElement.removeEventListener('seeked', onSeeked);
                videoElement.removeEventListener('error', onError);
                callback(null);
            }
        };

        const startAutoExtraction = () => {
            if (!video?.src || processingActive || !intervalInput) return;
            
            setProcessingUI('auto');
            if (screenshotsDiv) screenshotsDiv.innerHTML = '';
            screenshotBlobs = [];
            updateImageCount();
            contactSheetBlob = null;

            const interval = parseFloat(intervalInput.value);
            if (isNaN(interval) || interval <= 0) {
                resetProcessingUI('auto');
                return;
            }

            // Ensure video is fully ready by seeking to the beginning first
            const ensureVideoReady = () => {
                if (video.readyState < 4) { // HAVE_ENOUGH_DATA
                    console.log("[Auto Extraction] Waiting for video to be fully ready...");
                    // Seek to beginning to ensure video is ready
                    video.currentTime = 0;
                    
                    // Wait for video to be ready before starting
                    video.addEventListener('canplay', startExtraction, { once: true });
                } else {
                    // Video is already ready
                    startExtraction();
                }
            };
            
            const startExtraction = () => {
                // Start with a small offset to avoid the empty first frame
                let currentTime = 0.1;  // Start at 0.1 seconds instead of 0
                const totalDuration = currentVideoDuration;
                let frameAnimationId = null;
                let isCancelled = false;
                
                // Create an object that can be cancelled
                currentSamplingProcess = {
                    cancel: () => {
                        console.log("[Auto Extraction] Cancel called via currentSamplingProcess");
                        isCancelled = true;
                        cancelExtractionRequested = true;
                        if (frameAnimationId) {
                            cancelAnimationFrame(frameAnimationId);
                            frameAnimationId = null;
                        }
                    }
                };

                function processNextFrame() {
                    if (isCancelled || cancelExtractionRequested || currentTime > totalDuration + 0.1) {
                        console.log("[Auto Extraction] Terminating extraction loop");
                        resetProcessingUI('auto'); // This re-attaches the start listener
                        return;
                    }
                    
                    const timestamp = currentTime;
                    const progress = Math.min((currentTime / totalDuration) * 100, 100);
                    if (progressBarFillAuto) progressBarFillAuto.style.width = `${progress}%`;

                    captureFrameAtTime(timestamp, (blob) => {
                        // Only process if not cancelled and blob exists
                        if (!isCancelled && !cancelExtractionRequested && blob) {
                            const blobData = { blob, timestamp };
                            screenshotBlobs.push(blobData);
                            const container = createScreenshotElement(blob, timestamp, screenshotBlobs);
                            if (container && screenshotsDiv) screenshotsDiv.appendChild(container);
                            updateImageCount();
                        }
                        
                        // Schedule next only if not cancelled
                        if (!isCancelled && !cancelExtractionRequested) {
                            currentTime += interval;
                            frameAnimationId = requestAnimationFrame(processNextFrame);
                        } else {
                            // If cancelled during capture/blob, ensure UI reset happens
                            resetProcessingUI('auto');
                        }
                    });
                }

                // Start the extraction process
                frameAnimationId = requestAnimationFrame(processNextFrame);
            };
            
            // Start the process with a small delay to ensure everything is ready
            ensureVideoReady();
        };

        const startSmartExtraction = () => {
            if (!video?.src || processingActive) return;
            
            setProcessingUI('autoSmart');
            if (screenshotsDiv) screenshotsDiv.innerHTML = '';
            screenshotBlobs = [];
            updateImageCount();
            contactSheetBlob = null;

            const smartInterval = 1.0;
            const sampleFactor = 8;
            const histThreshold = histThresholdInput ? parseFloat(histThresholdInput.value) : 0.35;
            const pixelThreshold = pixelThresholdInput ? parseFloat(pixelThresholdInput.value) : 35;
            const ssimThreshold = ssimThresholdInput ? parseFloat(ssimThresholdInput.value) : 0.90;

            // Ensure video is fully ready by seeking to the beginning first
            const ensureVideoReady = () => {
                if (video.readyState < 4) { // HAVE_ENOUGH_DATA
                    console.log("[Smart Extraction] Waiting for video to be fully ready...");
                    // Seek to beginning to ensure video is ready
                    video.currentTime = 0;
                    
                    // Wait for video to be ready before starting
                    video.addEventListener('canplay', startExtraction, { once: true });
                } else {
                    // Video is already ready
                    startExtraction();
                }
            };
            
            const startExtraction = () => {
                // Start with a small offset to avoid the empty first frame
                let currentTime = 0.1;  // Start at 0.1 seconds instead of 0
                const totalDuration = currentVideoDuration;
                let previousImageData = null;
                let previousHist = null;
                let previousPixelData = null;
                let frameAnimationId = null;
                let isCancelled = false;
                
                // Create an object that can be cancelled
                currentSamplingProcess = {
                    cancel: () => {
                        console.log("[Smart Extraction] Cancel called via currentSamplingProcess");
                        isCancelled = true;
                        cancelExtractionRequested = true;
                        if (frameAnimationId) {
                            cancelAnimationFrame(frameAnimationId);
                            frameAnimationId = null;
                        }
                    }
                };

                function processNextSmartFrame() {
                    if (isCancelled || cancelExtractionRequested || currentTime > totalDuration + 0.1) {
                        console.log("[Smart Extraction] Terminating extraction loop");
                        resetProcessingUI('autoSmart'); // This re-attaches the start listener
                        return;
                    }
                    
                    const timestamp = currentTime;
                    const progress = Math.min((currentTime / totalDuration) * 100, 100);
                    if (progressBarFillSmart) progressBarFillSmart.style.width = `${progress}%`;

                    captureFrameAtTime(timestamp, (blob) => {
                        if (isCancelled || cancelExtractionRequested) {
                            resetProcessingUI('autoSmart');
                            return;
                        }
                        
                        if (!blob) {
                            // If frame fails, just move to next frame
                            currentTime += smartInterval;
                            frameAnimationId = requestAnimationFrame(processNextSmartFrame);
                            return;
                        }

                        const tempCanvas = document.createElement('canvas');
                        const tempCtx = tempCanvas.getContext('2d');
                        const img = new Image();
                        
                        img.onload = () => {
                            if (isCancelled || cancelExtractionRequested) {
                                resetProcessingUI('autoSmart');
                                URL.revokeObjectURL(img.src);
                                return;
                            }
                            
                            try {
                                tempCanvas.width = img.width;
                                tempCanvas.height = img.height;
                                if (!tempCtx) throw new Error("Could not get temp canvas context");
                                tempCtx.drawImage(img, 0, 0);
                                const currentImageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                                URL.revokeObjectURL(img.src);

                                let captureThisFrame = false;
                                if (!previousImageData) {
                                    captureThisFrame = true;
                                } else if (currentImageData) {
                                    if (smartAlgorithm === "histogram") {
                                        const currentHist = computeHistogram(currentImageData, sampleFactor);
                                        if (!previousHist || histogramDifference(currentHist, previousHist) >= histThreshold) {
                                            captureThisFrame = true;
                                        }
                                        previousHist = currentHist;
                                    } else if (smartAlgorithm === "pixeldiff") {
                                        const diff = computePixelDiff(currentImageData.data, previousPixelData, sampleFactor);
                                        if (diff >= pixelThreshold) {
                                            captureThisFrame = true;
                                        }
                                    } else if (smartAlgorithm === "ssim") {
                                        const ssimValue = computeSSIM(previousImageData, currentImageData, sampleFactor);
                                        if (ssimValue < ssimThreshold) {
                                            captureThisFrame = true;
                                        }
                                    }
                                }

                                if (captureThisFrame) {
                                    const blobData = { blob, timestamp };
                                    screenshotBlobs.push(blobData);
                                    const container = createScreenshotElement(blob, timestamp, screenshotBlobs);
                                    if (container && screenshotsDiv) screenshotsDiv.appendChild(container);
                                    updateImageCount();
                                    
                                    previousImageData = currentImageData;
                                    if (smartAlgorithm === 'pixeldiff' && currentImageData) {
                                        previousPixelData = currentImageData.data.slice();
                                    }
                                    if (smartAlgorithm === 'histogram' && !previousHist && currentImageData) {
                                        previousHist = computeHistogram(currentImageData, sampleFactor);
                                    }
                                }
                                
                                // Only proceed if not cancelled
                                if (!isCancelled && !cancelExtractionRequested) {
                                    currentTime += smartInterval;
                                    frameAnimationId = requestAnimationFrame(processNextSmartFrame);
                                } else {
                                    resetProcessingUI('autoSmart');
                                }
                                
                            } catch (error) {
                                console.error("[Process Smart] Error:", error);
                                URL.revokeObjectURL(img.src);
                                
                                // Continue to next frame unless cancelled
                                if (!isCancelled && !cancelExtractionRequested) {
                                    currentTime += smartInterval;
                                    frameAnimationId = requestAnimationFrame(processNextSmartFrame);
                                } else {
                                    resetProcessingUI('autoSmart');
                                }
                            }
                        };
                        
                        img.onerror = () => {
                            console.error("[Process Smart] Failed to load blob into image");
                            URL.revokeObjectURL(img.src);
                            
                            // Continue to next frame unless cancelled
                            if (!isCancelled && !cancelExtractionRequested) {
                                currentTime += smartInterval;
                                frameAnimationId = requestAnimationFrame(processNextSmartFrame);
                            } else {
                                resetProcessingUI('autoSmart');
                            }
                        };
                        
                        img.src = URL.createObjectURL(blob);
                    });
                }
                
                // Start the extraction process
                frameAnimationId = requestAnimationFrame(processNextSmartFrame);
            };
            
            // Start the process with a small delay to ensure everything is ready
            ensureVideoReady();
        };

        // --- Contact Sheet Preview & Generation ---
        const initContactSheetPreview = (rows = 4, cols = 5) => {
            if (!contactSheetPreviewElement) return;
            contactSheetPreviewElement.innerHTML = ''; // Clear existing
            
            // Set CSS variables for grid layout
            document.documentElement.style.setProperty('--grid-rows', rows);
            document.documentElement.style.setProperty('--grid-cols', cols);
            
            // Reset contactSheetPreviewData array to match grid size
            contactSheetPreviewData = new Array(rows * cols).fill(null);
            
            for (let i = 0; i < rows * cols; i++) {
                const cell = document.createElement('div'); 
                cell.className = 'grid-cell';
                
                // Create img element directly in the cell
                const img = document.createElement('img'); 
                img.alt = `Frame ${i+1}`; // Alt text for accessibility
                cell.appendChild(img);
                cell.dataset.index = i;
                
                // Make cell itself clickable
                cell.addEventListener('click', (e) => {
                    // Only trigger if we're not clicking on a button
                    if (!e.target.closest('.frame-adjust-btn') && cell.dataset.blobUrl) {
                        window.open(cell.dataset.blobUrl, '_blank');
                    }
                });
                
                // Create frame adjustment buttons container
                const btnContainer = document.createElement('div');
                btnContainer.className = 'frame-adjust-buttons';
                
                // Create minus button
                const minusBtn = document.createElement('div');
                minusBtn.className = 'frame-adjust-btn';
                minusBtn.textContent = '-';
                minusBtn.title = 'Go back 1 second';
                minusBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent other click handlers
                    adjustFrameTime(i, -1); // Adjust time by -1 second
                });
                
                // Create plus button
                const plusBtn = document.createElement('div');
                plusBtn.className = 'frame-adjust-btn';
                plusBtn.textContent = '+';
                plusBtn.title = 'Go forward 1 second';
                plusBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent other click handlers
                    adjustFrameTime(i, 1); // Adjust time by +1 second
                });
                
                // Add buttons to container
                btnContainer.appendChild(minusBtn);
                btnContainer.appendChild(plusBtn);
                
                // Add the container to the cell
                cell.appendChild(btnContainer);
                
                // Add highlighting interactions
                cell.addEventListener('mouseenter', () => {
                    cell.classList.add('highlight');
                    const timeInput = contactSheetControlsElement?.querySelector(`.time-input-container[data-index="${i}"]`);
                    if (timeInput) timeInput.classList.add('highlight');
                });
                
                cell.addEventListener('mouseleave', () => {
                    cell.classList.remove('highlight');
                    const timeInput = contactSheetControlsElement?.querySelector(`.time-input-container[data-index="${i}"]`);
                    if (timeInput) timeInput.classList.remove('highlight');
                });
                
                contactSheetPreviewElement.appendChild(cell);
            }
            console.log(`Contact sheet preview grid initialized with ${rows}×${cols} grid.`);
        };
        
        // Function to adjust frame time by a given offset (in seconds)
        const adjustFrameTime = (index, offsetSeconds) => {
            // Get the current time value
            const timeInput = document.getElementById(`timeInput_${index}`);
            if (!timeInput) return;
            
            const currentValue = parseFloat(timeInput.value);
            if (isNaN(currentValue)) return;
            
            // Calculate new time with constraints
            const newValue = Math.max(0, Math.min(
                currentValue + offsetSeconds,
                currentVideoDuration - 0.01
            ));
            
            // Update the value in the input field
            const timeFormatted = document.getElementById(`timeFormatted_${index}`);
            
            if (timeInput) timeInput.value = newValue.toFixed(2);
            if (timeFormatted) timeFormatted.value = formatTime(newValue);
            
            // Trigger update of the frame
            handleFineTuneChange(index, newValue);
        };

        const clearContactSheetPreview = (clearInputs = true) => {
            contactSheetPreviewData.forEach((data, index) => {
                if (data?.blobUrl) URL.revokeObjectURL(data.blobUrl);
                const cell = contactSheetPreviewElement?.querySelector(`.grid-cell[data-index="${index}"]`);
                if (cell) {
                    cell.classList.remove('filled');
                    cell.style.cursor = 'default';
                    const img = cell.querySelector('img');
                    if (img) img.src = '';
                    const overlay = cell.querySelector('.screenshot-overlay');
                    if (overlay) overlay.remove();
                    delete cell.dataset.blobUrl;
                    delete cell.dataset.timestamp;
                }
            });
            
            // Don't use fill as the array length might have changed
            contactSheetPreviewData = new Array(contactSheetPreviewData.length).fill(null);
            
            if (clearInputs) {
                contactSheetControlsElement?.querySelectorAll('.time-input').forEach(input => input.value = '0');
                contactSheetControlsElement?.querySelectorAll('.time-formatted').forEach(input => input.value = '0:00');
            }
            // Hide fine-tuning controls
            if (contactSheetControlsElement) contactSheetControlsElement.style.display = 'none';
            if (fineTuneMessageElement) fineTuneMessageElement.style.display = 'none';
            if (downloadContactSheetButton) downloadContactSheetButton.disabled = true;
            if (previewContactSheetButton) previewContactSheetButton.disabled = true;
            console.log("Contact sheet preview cleared.");
        };

        const updatePreviewCell = (index, blob, timestamp) => {
            const cell = contactSheetPreviewElement?.querySelector(`.grid-cell[data-index="${index}"]`);
            if (!cell || !blob) return;

            // Revoke previous blob URL for this cell if it exists
            const existingData = contactSheetPreviewData[index];
            if (existingData?.blobUrl) {
                URL.revokeObjectURL(existingData.blobUrl);
            }

            // Create a single blob URL for the cell
            const blobUrl = URL.createObjectURL(blob);
            
            // Update image source
            const img = cell.querySelector('img');
            if (img) img.src = blobUrl;
            
            // Store URL directly on the cell for click handler
            cell.classList.add('filled');
            cell.dataset.blobUrl = blobUrl;
            cell.dataset.timestamp = String(timestamp);
            cell.style.cursor = 'pointer';

            // Update or add timestamp overlay
            let overlay = cell.querySelector('.screenshot-overlay');
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.className = 'screenshot-overlay';
                cell.appendChild(overlay);
            }
            overlay.textContent = formatTime(timestamp);

            // Store the data
            contactSheetPreviewData[index] = { blob, timestamp, blobUrl };
            updateImageCount(); // Update clear button state if needed
        };

        const generateContactSheet = async () => {
            if (!video?.src || processingActive) return;
            setProcessingUI('contactSheet');
            contactSheetBlob = null; // Reset final downloadable blob
            if(downloadContactSheetButton) downloadContactSheetButton.disabled = true;

            // Get current grid size
            const activeGridSizeTab = document.querySelector('.grid-size-tab.active');
            const rows = parseInt(activeGridSizeTab?.getAttribute('data-rows') || 4);
            const cols = parseInt(activeGridSizeTab?.getAttribute('data-cols') || 5);
            const numSamples = rows * cols;

            const startPercent = 0.1; const endPercent = 0.9;
            const sampleTimestamps = [];
            const step = (endPercent - startPercent) / (numSamples > 1 ? numSamples - 1 : 1);
            for (let i = 0; i < numSamples; i++) {
                 const percent = startPercent + (i * step);
                 const time = Math.max(0.01, Math.min(percent * currentVideoDuration, currentVideoDuration - 0.01));
                 if (!isNaN(time)) sampleTimestamps.push(time);
                 // Update corresponding input fields if they exist
                 const timeInput = document.getElementById(`timeInput_${i}`);
                 const timeFormatted = document.getElementById(`timeFormatted_${i}`);
                 if (timeInput) timeInput.value = time.toFixed(2);
                 if (timeFormatted) timeFormatted.value = formatTime(time);
            }

            if (sampleTimestamps.length !== numSamples) {
                console.warn(`Calculated ${sampleTimestamps.length} timestamps, expected ${numSamples}`);
                 if (sampleTimestamps.length === 0) {
                     alert("Error: Could not calculate timestamps for contact sheet.");
                     resetProcessingUI('contactSheet');
                     return;
                 }
            }

            // Clear previous preview and data before starting new generation
            clearContactSheetPreview(false); // Keep calculated input values

            try {
                currentSamplingProcess = sampleVideoFrames({
                    videoElement: video, // Use the hidden video for processing
                    sampleTimestamps: sampleTimestamps,
                    outputType: 'blob',
                    useCrop: removeBarsEnabled,
                    processFrameCallback: (blob, timestamp, index) => {
                        if (blob) {
                            updatePreviewCell(index, blob, timestamp); // Update grid cell live
                        } else {
                            console.warn(`Failed blob generation for cell ${index} at ${formatTime(timestamp)}`);
                        }
                    },
                    onProgressCallback: (progress) => {
                        if (progressBarFillContactSheet) progressBarFillContactSheet.style.width = `${progress}%`;
                    },
                    onCompleteCallback: async (collectedData) => {
                        if (cancelExtractionRequested) { console.log("Contact Sheet generation cancelled during sampling."); resetProcessingUI('contactSheet'); return; }
                        console.log("Contact Sheet sampling complete. Generating final image...");
                        if (progressBarFillContactSheet) progressBarFillContactSheet.style.width = `100%`; // Show 100% before final render

                        // Filter out any null entries if frames failed
                        const validPreviewData = contactSheetPreviewData.filter(data => data !== null);

                        if (validPreviewData.length === 0) {
                            throw new Error("Failed to collect any valid frames for final contact sheet render.");
                        }

                        // Render final image onto contactSheetCanvas
                        const cols = 5; const targetAspectRatio = 16 / 9;
                        const targetWidth = 1920; const targetHeight = Math.round(targetWidth / targetAspectRatio);
                        const cellWidth = Math.floor(targetWidth / cols); const cellHeight = Math.floor(targetHeight / Math.ceil(validPreviewData.length / cols));

                        const ctx = contactSheetCanvas.getContext('2d'); if (!ctx) throw new Error("Could not get contact sheet canvas context");
                        contactSheetCanvas.width = targetWidth; contactSheetCanvas.height = targetHeight; ctx.fillStyle = 'black'; ctx.fillRect(0, 0, targetWidth, targetHeight);

                        // Load images from preview data blobs
                        const imageLoadPromises = validPreviewData.map(({ blob }) => new Promise((resolve) => {
                            const img = new Image();
                             img.onload = () => resolve(img); // Keep blob URL until drawn
                             img.onerror = () => { console.warn("Failed to load preview blob into image for final render."); resolve(null); };
                             img.src = URL.createObjectURL(blob); // Use the blob directly
                        }));

                        const loadedImages = await Promise.all(imageLoadPromises);

                        // Draw onto final canvas
                        loadedImages.forEach((img, index) => {
                            if (!img) return;
                            const dataEntry = validPreviewData[index]; // Get corresponding data entry
                            const originalIndex = contactSheetPreviewData.findIndex(d => d === dataEntry); // Find original cell index

                            const row = Math.floor(originalIndex / cols);
                            const col = originalIndex % cols;
                            const drawX = col * cellWidth; const drawY = row * cellHeight;
                            const scale = Math.min(cellWidth / img.width, cellHeight / img.height);
                            const drawWidth = img.width * scale; const drawHeight = img.height * scale;
                            const offsetX = drawX + (cellWidth - drawWidth) / 2; const offsetY = drawY + (cellHeight - drawHeight) / 2;
                            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
                            URL.revokeObjectURL(img.src); // Revoke URL *after* drawing
                        });

                        contactSheetCanvas.toBlob((finalBlob) => {
                            if (finalBlob) { 
                                contactSheetBlob = finalBlob; 
                                console.log("Contact Sheet final image generated.");
                                
                                // Mark the current grid size as completed
                                const activeTab = document.querySelector('.grid-size-tab.active');
                                if (activeTab) {
                                    activeTab.classList.add('completed');
                                    
                                    // Update cache
                                    const rows = parseInt(activeTab.getAttribute('data-rows'));
                                    const cols = parseInt(activeTab.getAttribute('data-cols'));
                                    const cacheKey = `${cols}x${rows}`;
                                    
                                    gridCache[cacheKey] = {
                                        data: [...contactSheetPreviewData],
                                        blob: finalBlob,
                                        completed: true
                                    };
                                }
                            }
                            else { console.error("Failed to generate final contact sheet blob."); contactSheetBlob = null; }
                            resetProcessingUI('contactSheet'); // Finish UI reset
                            // Show fine-tuning controls
                            if (contactSheetControlsElement) contactSheetControlsElement.style.display = 'grid';
                            if (fineTuneMessageElement) fineTuneMessageElement.style.display = 'block';
                        }, 'image/jpeg', 0.9);
                    },
                    onErrorCallback: (error) => { console.error("Error during contact sheet frame sampling:", error); alert(`Error generating contact sheet: ${error.message}`); resetProcessingUI('contactSheet'); }
                });
            } catch (error) { console.error("Failed to start contact sheet generation:", error); alert(`Error starting contact sheet generation: ${error.message}`); resetProcessingUI('contactSheet'); }
        };

        // --- Fine-Tuning Contact Sheet Cell ---
        const handleFineTuneChange = debounce((index, newTime) => {
            if (isNaN(newTime) || newTime < 0) return;
            const clampedTime = Math.min(newTime, currentVideoDuration - 0.01); // Clamp time

            // Update the preview using the main video element
            captureFrameAtTime(clampedTime, (blob) => { // Use the reliable capture function
                 if (blob) {
                     updatePreviewCell(index, blob, clampedTime);
                     
                     // Invalidate the final blob - user needs to regenerate for download
                     contactSheetBlob = null;
                     if (downloadContactSheetButton) downloadContactSheetButton.disabled = true;
                     if (previewContactSheetButton) previewContactSheetButton.disabled = true;
                     if (processContactSheetButton) processContactSheetButton.textContent = 'Update Sheet Image'; // Change button text
                     
                     // Remove completed marker since content has changed
                     const activeTab = document.querySelector('.grid-size-tab.active');
                     if (activeTab) {
                         activeTab.classList.remove('completed');
                         
                         // Update cache to show incomplete state
                         const rows = parseInt(activeTab.getAttribute('data-rows'));
                         const cols = parseInt(activeTab.getAttribute('data-cols'));
                         const cacheKey = `${cols}x${rows}`;
                         
                         if (gridCache[cacheKey]) {
                             gridCache[cacheKey].completed = false;
                             gridCache[cacheKey].blob = null;
                         }
                     }
                 } else {
                     console.warn(`Fine-tuning failed for cell ${index} at ${clampedTime.toFixed(2)}s`);
                 }
            });
        }, 200); // Shorter debounce for more responsive dragging

        // --- Contact Sheet Time Input Generation & Listeners ---
        const generateTimeInputs = (rows = 4, cols = 5) => {
             if (!contactSheetControlsElement) return;
             contactSheetControlsElement.innerHTML = ''; // Clear previous
             
             // Update grid template for the controls
             contactSheetControlsElement.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;

             for (let i = 0; i < rows * cols; i++) {
                 const container = document.createElement('div'); 
                 container.className = 'time-input-container';
                 container.dataset.index = i; // Store index for highlighting

                 const wrapper = document.createElement('div');
                 wrapper.className = 'time-input-wrapper';

                 // Hidden number input to store the actual value
                 const timeInput = document.createElement('input');
                 timeInput.type = 'number';
                 timeInput.className = 'time-input';
                 timeInput.id = `timeInput_${i}`;
                 timeInput.value = contactSheetPreviewData[i]?.timestamp?.toFixed(2) || '0.00';
                 timeInput.min = '0';
                 timeInput.max = currentVideoDuration ? currentVideoDuration.toFixed(2) : '999';
                 timeInput.dataset.index = i;

                 // Visible formatted text input
                 const timeFormatted = document.createElement('input');
                 timeFormatted.type = 'text';
                 timeFormatted.className = 'time-formatted';
                 timeFormatted.id = `timeFormatted_${i}`;
                 timeFormatted.value = formatTime(parseFloat(timeInput.value));
                 timeFormatted.dataset.index = i;
                 timeFormatted.placeholder = "0:00";
                 timeFormatted.setAttribute('draggable', 'false'); // Prevent default drag

                 // Add highlighting interactions
                 // When time input is hovered, highlight both the input and corresponding cell
                 container.addEventListener('mouseenter', () => {
                     container.classList.add('highlight');
                     const cell = contactSheetPreviewElement?.querySelector(`.grid-cell[data-index="${i}"]`);
                     if (cell) cell.classList.add('highlight');
                 });
                 
                 container.addEventListener('mouseleave', () => {
                     container.classList.remove('highlight');
                     const cell = contactSheetPreviewElement?.querySelector(`.grid-cell[data-index="${i}"]`);
                     if (cell) cell.classList.remove('highlight');
                 });

                 // Add event listeners for direct editing of time text
                 timeFormatted.addEventListener('change', (e) => {
                     const index = parseInt(e.target.dataset.index);
                     const parsedSeconds = parseTimeString(e.target.value);
                     updateTimeValue(index, parsedSeconds);
                 });

                 // When user clicks on the text field, allow text editing
                 timeFormatted.addEventListener('focus', (e) => {
                     e.target.select();
                 });

                 // Implement drag-to-adjust functionality
                 let isDragging = false;
                 let startY = 0;
                 let startValue = 0;
                 let sensitivity = 0.05; // Seconds per pixel

                 timeFormatted.addEventListener('mousedown', (e) => {
                     isDragging = true;
                     startY = e.clientY;
                     startValue = parseFloat(timeInput.value);
                     document.body.style.cursor = 'ns-resize';
                     
                     // Add global event listeners to track drag even outside the element
                     document.addEventListener('mousemove', handleMouseMove);
                     document.addEventListener('mouseup', handleMouseUp);
                     
                     // Prevent text selection during drag
                     e.preventDefault();
                 });

                 const handleMouseMove = (e) => {
                     if (!isDragging) return;
                     
                     const deltaY = startY - e.clientY;
                     const newValue = Math.max(0, Math.min(
                         startValue + (deltaY * sensitivity),
                         currentVideoDuration - 0.01
                     ));
                     
                     // Update both inputs
                     timeInput.value = newValue.toFixed(2);
                     timeFormatted.value = formatTime(newValue);
                     
                     // Trigger frame update as user drags
                     handleFineTuneChange(parseInt(timeInput.dataset.index), newValue);
                 };

                 const handleMouseUp = () => {
                     isDragging = false;
                     document.body.style.cursor = '';
                     document.removeEventListener('mousemove', handleMouseMove);
                     document.removeEventListener('mouseup', handleMouseUp);
                 };

                 // Helper function to update time value
                 const updateTimeValue = (index, seconds) => {
                     if (isNaN(seconds)) seconds = 0;
                     const clampedTime = Math.min(Math.max(0, seconds), currentVideoDuration - 0.01);
                     
                     // Update the inputs
                     const numberInput = document.getElementById(`timeInput_${index}`);
                     const formatted = document.getElementById(`timeFormatted_${index}`);
                     
                     if (numberInput) numberInput.value = clampedTime.toFixed(2);
                     if (formatted) formatted.value = formatTime(clampedTime);
                     
                     // Update video and frame
                         if (contactSheetVideo && !contactSheetVideo.seeking) {
                         contactSheetVideo.currentTime = clampedTime;
                     }
                     
                     handleFineTuneChange(index, clampedTime);
                 };

                 wrapper.appendChild(timeInput);
                 wrapper.appendChild(timeFormatted);
                 container.appendChild(wrapper);
                 contactSheetControlsElement.appendChild(container);
             }
        };


        if (extractManualButton) extractManualButton.addEventListener('click', () => { /* ... */ if (!manualVideo?.src || manualVideo.readyState < 1 || processingActive || !canvas) return; try { const { type, quality } = getCurrentFormatSettings(); const ctx = canvas.getContext('2d'); if(!ctx) throw new Error("Canvas context not available"); if (removeBarsEnabled && cropData && cropData.cropWidth > 0 && cropData.cropHeight > 0) { canvas.width = cropData.cropWidth; canvas.height = cropData.cropHeight; ctx.drawImage(manualVideo, cropData.cropX, cropData.cropY, cropData.cropWidth, cropData.cropHeight, 0, 0, cropData.cropWidth, cropData.cropHeight); } else { canvas.width = manualVideo.videoWidth; canvas.height = manualVideo.videoHeight; if (canvas.width === 0 || canvas.height === 0) throw new Error("Video dimensions are zero for manual extract."); ctx.drawImage(manualVideo, 0, 0, canvas.width, canvas.height); } canvas.toBlob((blob) => { if (blob) { const tempLink = document.createElement('a'); const url = URL.createObjectURL(blob); tempLink.href = url; const extension = type.split('/')[1] === 'jpeg' ? 'jpg' : type.split('/')[1]; tempLink.download = `quick_frame_${formatTime(manualVideo.currentTime).replace(':','-')}.${extension}`; document.body.appendChild(tempLink); tempLink.click(); document.body.removeChild(tempLink); URL.revokeObjectURL(url); } }, type, quality); } catch(error) { console.error("[Manual Quick Save] Error:", error); alert("An error occurred during Quick Save."); } });
        if (addManualButton) addManualButton.addEventListener('click', () => { 
          // Add cutting class to trigger the cutting animation
          addManualButton.classList.add('cutting');
          
          // Remove the class after the animation completes
          setTimeout(() => {
            addManualButton.classList.remove('cutting');
          }, 300);
          
          if (!manualVideo?.src || manualVideo.readyState < 1 || processingActive || !canvas) return;
          
          try { 
            const { type, quality } = getCurrentFormatSettings();
            const ctx = canvas.getContext('2d');
            if(!ctx) throw new Error("Canvas context not available");
            
            if (removeBarsEnabled && cropData && cropData.cropWidth > 0 && cropData.cropHeight > 0) {
              canvas.width = cropData.cropWidth;
              canvas.height = cropData.cropHeight;
              ctx.drawImage(manualVideo, cropData.cropX, cropData.cropY, cropData.cropWidth, cropData.cropHeight, 0, 0, cropData.cropWidth, cropData.cropHeight);
            } else {
              canvas.width = manualVideo.videoWidth;
              canvas.height = manualVideo.videoHeight;
              if (canvas.width === 0 || canvas.height === 0) throw new Error("Video dimensions are zero for manual add.");
              ctx.drawImage(manualVideo, 0, 0, canvas.width, canvas.height);
            }
            
            const timestamp = manualVideo.currentTime;
            canvas.toBlob((blob) => {
              if (blob) {
                const blobData = { blob, timestamp };
                manualScreenshotBlobs.push(blobData);
                const container = createScreenshotElement(blob, timestamp, manualScreenshotBlobs);
                if(container && screenshotsDiv) screenshotsDiv.appendChild(container);
                updateImageCount();
              }
            }, type, quality);
          } catch(error) {
            console.error("[Manual Add] Error:", error);
            alert("An error occurred while adding the frame.");
          }
        });

        // --- Download & Clear Buttons ---
        if(downloadAllButton) downloadAllButton.addEventListener('click', () => { if (!processingActive) downloadBlobsAsZip(screenshotBlobs, "auto_screenshots"); });
        if(downloadAllSmartButton) downloadAllSmartButton.addEventListener('click', () => { if (!processingActive) downloadBlobsAsZip(screenshotBlobs, "smart_screenshots"); });
        if(downloadManualButton) downloadManualButton.addEventListener('click', () => { if (!processingActive) downloadBlobsAsZip(manualScreenshotBlobs, "manual_screenshots"); });
        
        // Preview Contact Sheet button
        if(previewContactSheetButton) previewContactSheetButton.addEventListener('click', () => {
            if (!processingActive && contactSheetBlob) {
                // Open the image in a new tab
                const url = URL.createObjectURL(contactSheetBlob);
                window.open(url, '_blank');
                // Don't revoke the URL since the browser will need it for the tab
            } else if (!contactSheetBlob) {
                alert("Please generate the contact sheet first or update it after fine-tuning.");
            }
        });
        
        // Download Contact Sheet button
        if(downloadContactSheetButton) downloadContactSheetButton.addEventListener('click', () => { 
            if (!processingActive && contactSheetBlob) { 
                const tempLink = document.createElement('a'); 
                const url = URL.createObjectURL(contactSheetBlob); 
                tempLink.href = url; 
                tempLink.download = `contact_sheet_${uploadedFile?.name.split('.')[0] || 'video'}.jpg`; 
                document.body.appendChild(tempLink); 
                tempLink.click(); 
                document.body.removeChild(tempLink); 
                URL.revokeObjectURL(url); 
            } else if (!contactSheetBlob) { 
                alert("Please generate the contact sheet first or update it after fine-tuning."); 
            } 
        });

        if (clearScreenshotsButton) clearScreenshotsButton.addEventListener('click', () => {
            if (processingActive) return;
            const hasScreenshots = screenshotBlobs.length > 0 || manualScreenshotBlobs.length > 0;
            const hasContactSheetPreview = contactSheetPreviewData.some(d => d !== null);
            if (screenshotsDiv && (hasScreenshots || hasContactSheetPreview)) {
                 if (confirm("Are you sure you want to clear all generated output (screenshots and contact sheet preview)?")) {
                     // Clear regular screenshots
                     screenshotsDiv.querySelectorAll('.screenshot-container').forEach(container => { if (container.dataset.blobUrl) URL.revokeObjectURL(container.dataset.blobUrl); });
                     screenshotsDiv.innerHTML = ''; screenshotBlobs = []; manualScreenshotBlobs = [];
                     
                     // Clear contact sheet preview and data
                     clearContactSheetPreview(true); // Clear inputs too
                     contactSheetBlob = null; // Reset downloadable blob
                     
                     // Clear all completion markers and grid caches
                     document.querySelectorAll('.grid-size-tab').forEach(tab => {
                         tab.classList.remove('completed');
                     });
                     
                     // Reset grid cache
                     gridCache = {
                         '5x4': { data: null, blob: null, completed: false },
                         '4x3': { data: null, blob: null, completed: false },
                         '3x2': { data: null, blob: null, completed: false }
                     };
                     
                     if(downloadContactSheetButton) downloadContactSheetButton.disabled = true;
                     if(processContactSheetButton) processContactSheetButton.textContent = 'Generate/Update Sheet'; // Reset button text
                     updateImageCount();
                 }
            }
        });

        // --- Final Initial Setup ---
        currentMode = document.querySelector('.mode-tab.active')?.getAttribute('data-mode') || 'auto';
        smartAlgorithm = document.querySelector('.smart-tab.active')?.getAttribute('data-algo') || 'histogram';
        
        // Initialize all sliders' backgrounds - even those in hidden sections
        document.querySelectorAll('input[type="range"]').forEach(updateSliderBackground);
        
        resetProcessingUI('all');
        updateDropZoneUI(false, null); // Initial state
        updateImageCount();
        initContactSheetPreview(); // Initialize the grid structure
        generateTimeInputs(); // Generate inputs structure
        
        // Ensure buttons are properly disabled initially
        if(downloadContactSheetButton) downloadContactSheetButton.disabled = true;
        if(previewContactSheetButton) previewContactSheetButton.disabled = true;

        console.log("Nia Frame Capture Studio Initialized.");

        // Initialize contact sheet mode
        if (contactSheetMode && contactSheetPreviewElement) {
            // Initial grid setup
            initContactSheetPreview();
            generateTimeInputs();
            
            // Check if custom tab is active initially and show its controls
            const activeTab = document.querySelector('.grid-size-tab.active');
            if (activeTab && activeTab.textContent.trim() === 'Custom' && customGridControls) {
                customGridControls.style.display = 'block';
                
                // Set custom values to match the tab's data attributes
                if (customGridRows && customGridCols) {
                    customGridRows.value = activeTab.getAttribute('data-rows') || '2';
                    customGridCols.value = activeTab.getAttribute('data-cols') || '3';
                }
            }
        }

      } catch (error) { /* ... error handling ... */ console.error("Error during script execution:", error); const errorDisplay = document.createElement('div'); errorDisplay.textContent = `Initialization Error: ${error.message}. Please refresh or check console (F12).`; errorDisplay.style.cssText = 'color: var(--danger-color); padding: 1rem; background-color: var(--bg-secondary); border: 1px solid var(--danger-color); margin: 1rem; border-radius: var(--border-radius-md);'; document.body.prepend(errorDisplay); }
    }); // End DOMContentLoaded
  </script>

</body>
</html>
