<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Frame Capture Studio</title>
  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Doto&family=Inter:wght@400;500;600&family=Source+Code+Pro:wght@400&display=swap" rel="stylesheet">
  <!-- JSZip -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    :root {
      /* --- Dark Theme: Deep Ocean (Compact Version) --- */
      --bg-primary: #0a0f1f;
      --bg-secondary: #161d31;
      --bg-tertiary: #242c44;
      --text-primary: #e0e6f7;
      --text-secondary: #8a94b6;
      --border-color: #3a4466;
      --border-dashed: #525c8f;

      /* Accents */
      --accent-primary: #00c6ff;
      --accent-primary-dark: #00a5d9;
      --accent-secondary: #2dd4bf;
      --accent-secondary-dark: #14b8a6;
      --accent-tertiary: #ff6ac1;
      --accent-tertiary-dark: #f53aab;
      --danger-color: #f43f5e;
      --danger-color-dark: #e11d48;

      /* Gradients */
      --gradient-primary: linear-gradient(90deg, var(--accent-primary), #00a8ff);
      --gradient-secondary: linear-gradient(90deg, var(--accent-secondary), #5eead4);
      --gradient-tertiary: linear-gradient(90deg, var(--accent-tertiary), #ff8cdc);
      --gradient-danger: linear-gradient(90deg, var(--danger-color), #fb7185);
      --gradient-disabled: linear-gradient(90deg, var(--bg-tertiary), #2f3958);

      /* Base Styles */
      --white: #ffffff;
      --black: #000000;
      --glitch-cyan: rgba(0, 255, 255, 0.7);
      --glitch-magenta: rgba(255, 0, 255, 0.7);

      /* Layout & Sizing (Compact) */
      --border-radius-sm: 3px; /* Slightly smaller radius */
      --border-radius-md: 6px;
      --border-radius-lg: 10px;
      --border-radius-full: 9999px;
      --content-padding: 1.25rem; /* Reduced padding */
      --settings-column-width: 460px; /* Slightly narrower column */
      --scrollbar-width: 8px; /* Thinner scrollbar */
      --separator-width: 2px;
    }

    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      background-color: var(--bg-primary);
      color: var(--text-primary);
      font-family: 'Inter', "Helvetica Neue", Arial, sans-serif;
      line-height: 1.5; /* Slightly tighter line height */
      font-size: 15px; /* Slightly smaller base font size */
      min-height: 100vh;
      display: flex;
      overflow: hidden;
    }
    html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
    }

    /* Scrollbar Styling (Thinner) */
    ::-webkit-scrollbar { width: var(--scrollbar-width); height: var(--scrollbar-width); }
    ::-webkit-scrollbar-track { background: var(--bg-secondary); border-radius: var(--border-radius-full); }
    ::-webkit-scrollbar-thumb { background-color: var(--bg-tertiary); border-radius: var(--border-radius-full); border: 1px solid var(--bg-secondary); } /* Thinner border */
    ::-webkit-scrollbar-thumb:hover { background-color: var(--border-color); }
    * { scrollbar-width: thin; scrollbar-color: var(--bg-tertiary) var(--bg-secondary); }

    /* Layout */
    .app-container { flex: 1; display: flex; position: relative; width: 100%; height: 100%; overflow: hidden; }
    .vertical-separator { position: absolute; top: 0; bottom: 0; left: var(--settings-column-width); width: var(--separator-width); background-image: linear-gradient(to bottom, var(--border-dashed) 60%, transparent 40%); background-size: 100% 8px; background-repeat: repeat-y; z-index: 10; pointer-events: none; transition: background-image 0.3s ease; }
    .vertical-separator.loading { background-image: linear-gradient(to bottom, var(--accent-primary) 60%, transparent 40%); background-size: 100% 12px; animation: loadingAnimation 10s linear infinite; }
    .vertical-separator.loading-smart { background-image: linear-gradient(to bottom, var(--accent-secondary) 60%, transparent 40%); background-size: 100% 12px; animation: loadingAnimation 10s linear infinite; }
    @keyframes loadingAnimation { 0% { background-position: 0 100vh; } 100% { background-position: 0 0; } }

    /* --- SETTINGS COLUMN STYLES (Compact) --- */
    .settings-column { flex: 0 0 var(--settings-column-width); position: relative; height: 100%; overflow-y: auto; overflow-x: hidden; direction: rtl; background-color: var(--bg-secondary); padding: 0; border-right: 1px solid var(--border-color); }
    .settings-content-wrapper { direction: ltr; width: 100%; padding: var(--content-padding); }
    /* --- END SETTINGS COLUMN STYLES --- */


    .output-column { flex: 1; display: flex; flex-direction: column; background-color: var(--bg-primary); overflow-y: auto; }
    #screenshots { padding: var(--content-padding); display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); /* Slightly smaller min size */ gap: 0.8rem; /* Reduced gap */ align-content: start; }

    /* H1 (Compact) */
    h1 { font-family: 'Doto', sans-serif; text-align: center; padding-bottom: 1rem; /* Reduced padding */ margin-bottom: 1.25rem; /* Reduced margin */ font-weight: 400; font-size: 2em; /* Slightly smaller */ color: var(--white); position: relative; cursor: pointer; user-select: none; transition: color 0.3s ease; border-bottom: 1px solid var(--border-color); }
    h1::before, h1::after { content: attr(data-text); position: absolute; top: 0; left: 0; right: 0; padding-bottom: 1rem; overflow: hidden; color: var(--white); background: var(--bg-secondary); transition: transform 0.05s ease-in-out, color 0.1s ease; opacity: 0; }
    h1:hover::before { color: var(--glitch-magenta); transform: translate(-2px, -1px) skewX(-5deg); opacity: 1; animation: glitchAnim 0.8s infinite linear alternate-reverse; }
    h1:hover::after { color: var(--glitch-cyan); transform: translate(2px, 1px) skewX(5deg); opacity: 1; animation: glitchAnim 0.8s infinite linear alternate; }
    h1:active { transform: scale(0.98); }
    @keyframes glitchAnim { 0% { clip-path: polygon(0 0, 100% 0, 100% 45%, 0 45%); } 20% { clip-path: polygon(0 20%, 100% 20%, 100% 25%, 0 25%); } 40% { clip-path: polygon(0 60%, 100% 60%, 100% 70%, 0 70%); } 60% { clip-path: polygon(0 85%, 100% 85%, 100% 90%, 0 90%); } 80% { clip-path: polygon(0 40%, 100% 40%, 100% 55%, 0 55%); } 100% { clip-path: polygon(0 0, 100% 0, 100% 10%, 0 10%); } }

    /* Drop Zone (Compact) */
    #dropZone { padding: 1.5rem 1rem; /* Reduced padding */ border: 2px dashed var(--border-dashed); border-radius: var(--border-radius-lg); background: linear-gradient(145deg, var(--bg-tertiary), var(--bg-secondary)); display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; cursor: pointer; transition: background 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease; margin-bottom: 1.5rem; /* Reduced margin */ box-shadow: 0 3px 8px rgba(0, 0, 0, 0.15); }
    #dropZone:hover { border-color: var(--accent-primary); box-shadow: 0 5px 12px rgba(0, 198, 255, 0.15); }
    #uploadIcon { margin-bottom: 0.75rem; color: var(--text-secondary); transition: color 0.3s ease, transform 0.3s ease; }
    #dropZone:hover #uploadIcon { color: var(--accent-primary); transform: scale(1.1); }
    #uploadIcon svg { width: 44px; height: 44px; fill: currentColor; } /* Slightly smaller icon */
    #dropZoneText { margin-bottom: 1rem; font-size: 0.95rem; color: var(--text-secondary); }
    #dropZone.file-loaded #dropZoneText { color: var(--text-primary); font-weight: 500; }
    #videoInput { display: none; }
    #selectFileButton { padding: 0.6rem 1.5rem; /* Reduced padding */ font-size: 0.9rem; background-color: rgba(255, 255, 255, 0.05); border: 1px solid var(--border-color); border-radius: var(--border-radius-md); color: var(--text-primary); cursor: pointer; transition: background-color 0.2s, border-color 0.2s, color 0.2s, box-shadow 0.2s; font-weight: 500; }
    #dropZone:hover #selectFileButton { background-color: rgba(255, 255, 255, 0.1); border-color: var(--text-secondary); box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1); }
    #selectFileButton.file-selected { background-color: transparent; border: 1px solid var(--accent-secondary); color: var(--accent-secondary); cursor: default; }
    #selectFileButton.file-selected:hover { background-color: rgba(45, 212, 191, 0.1); }

    /* File Info (Compact) */
    #fileInfo { font-size: 0.85rem; /* Slightly smaller */ color: var(--text-secondary); background-color: var(--bg-tertiary); padding: 1rem 1.25rem; /* Reduced padding */ border-radius: var(--border-radius-md); margin-bottom: 1.5rem; /* Reduced margin */ border: 1px solid var(--border-color); }
    .info-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.5rem; /* Reduced spacing */ white-space: nowrap; }
    .info-row:last-child { margin-bottom: 0; }
    .info-label { font-weight: 500; color: var(--text-primary); margin-right: 1rem; }
    .info-value { font-family: 'Source Code Pro', monospace; text-align: right; color: var(--accent-primary); font-weight: 500; font-size: 0.9rem; }
    .leader { display: none; }

    /* Tabs (Compact) */
    .segmented-controls { display: flex; border-radius: var(--border-radius-md); overflow: hidden; background-color: var(--bg-tertiary); margin-bottom: 1.25rem; /* Reduced margin */ border: 1px solid var(--border-color); }
    .segmented-controls button { flex: 1; background-color: transparent; text-align: center; border: none; padding: 0.65rem 0.5rem; /* Reduced padding */ color: var(--text-secondary); cursor: pointer; transition: background-color 0.2s, color 0.3s, box-shadow 0.2s; font-family: inherit; font-size: 0.85rem; /* Slightly smaller */ font-weight: 500; border-left: 1px solid var(--border-color); position: relative; }
    .segmented-controls button:first-child { border-left: none; }
    .segmented-controls button:hover:not(.active) { background-color: var(--border-color); color: var(--text-primary); }
    .mode-tabs button.active { background: var(--gradient-primary); color: var(--bg-primary); font-weight: 600; box-shadow: inset 0 1px 3px rgba(0,0,0,0.2); }
    .format-tabs button.active { background: var(--gradient-primary); color: var(--bg-primary); font-weight: 600; box-shadow: inset 0 1px 2px rgba(0,0,0,0.15); }
    .smart-algo-tabs button.active { background: var(--gradient-secondary); color: var(--bg-primary); font-weight: 600; box-shadow: inset 0 1px 2px rgba(0,0,0,0.15); }
    .format-tabs, .smart-algo-tabs { margin-bottom: 0.8rem; } /* Reduced margin */
    .format-tabs button, .smart-algo-tabs button { padding: 0.5rem 0.5rem; font-size: 0.8rem; } /* Smaller format/algo buttons */

    /* Mode Containers Display Logic */
    .mode-content > div { display: none; }
    .mode-content > div.active { display: block; }

    /* Sliders (Compact) */
    .slider-row { display: flex; align-items: center; gap: 1rem; /* Reduced gap */ margin-bottom: 1rem; /* Reduced margin */ flex-wrap: wrap; }
    .slider-label { width: 100px; /* Narrower label */ text-align: left; font-size: 0.85rem; /* Slightly smaller */ color: var(--text-secondary); flex-shrink: 0; }
    .slider-wrapper { flex: 1; display: flex; align-items: center; gap: 0.8rem; min-width: 150px; }
    .value-display { font-weight: 500; min-width: 40px; text-align: right; font-family: 'Source Code Pro', monospace; color: var(--text-primary); font-size: 0.9rem; }
    input[type="range"] { -webkit-appearance: none; -moz-appearance: none; appearance: none; width: 100%; height: 6px; /* Slightly thinner */ background: var(--bg-tertiary); border-radius: var(--border-radius-full); outline: none; cursor: pointer; transition: background 0.2s; }
    input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 18px; height: 18px; border-radius: 50%; background: var(--white); border: none; box-shadow: 0 1px 4px rgba(0, 0, 0, 0.25); transition: transform 0.1s ease-out; }
    input[type="range"]::-moz-range-thumb { width: 18px; height: 18px; border-radius: 50%; background: var(--white); border: none; box-shadow: 0 1px 4px rgba(0, 0, 0, 0.25); transition: transform 0.1s ease-out; }
    input[type="range"]:active::-webkit-slider-thumb, input[type="range"]:active::-moz-range-thumb { transform: scale(1.1); }
    input[type="range"]:focus-visible { outline: 2px solid var(--accent-primary); outline-offset: 2px; }

    /* Notes & Buttons (Compact) */
    #pngNote, #pngNoteSmart { font-size: 0.8rem; /* Smaller */ color: var(--text-secondary); text-align: center; width: 100%; min-height: 30px; display: flex; align-items: center; justify-content: center; margin-bottom: 0.8rem; /* Reduced margin */ background-color: rgba(36, 44, 68, 0.5); border-radius: var(--border-radius-sm); padding: 0.2rem 0.4rem; }
    .button-group { display: flex; flex-direction: column; gap: 0.75rem; /* Reduced gap */ margin-top: 1.5rem; /* Reduced margin */ }
    .action-button { width: 100%; padding: 0.75rem 1.5rem; /* Reduced padding */ font-size: 0.95rem; /* Slightly smaller */ border: none; border-radius: var(--border-radius-md); color: var(--bg-primary); cursor: pointer; transition: background 0.3s ease, opacity 0.2s, color 0.2s, box-shadow 0.2s ease; text-align: center; font-weight: 600; background-size: 200% auto; box-shadow: 0 3px 5px rgba(0, 0, 0, 0.1); }
    .action-button:hover:enabled { box-shadow: 0 5px 10px rgba(0, 0, 0, 0.15); background-position: right center; }
    .action-button:active:enabled { transform: scale(0.98); box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); }
    .action-button:disabled { opacity: 0.5; cursor: not-allowed; box-shadow: none; background: var(--gradient-disabled); color: var(--text-secondary); }
    #processButton { background: var(--gradient-primary); }
    #processSmartButton { background: var(--gradient-secondary); }
    #processButton.cancel-active, #processSmartButton.cancel-active { background: var(--gradient-danger); color: var(--white); }
    #processButton.cancel-active:hover:enabled, #processSmartButton.cancel-active:hover:enabled { background: var(--gradient-danger); filter: brightness(1.1); }
    #downloadAllButton, #downloadAllSmartButton, #downloadManualButton { background: transparent; border: 1px solid var(--accent-tertiary); color: var(--accent-tertiary); padding: calc(0.75rem - 1px) calc(1.5rem - 1px); /* Adjust for 1px border */ box-shadow: none; }
    #downloadAllButton:hover:enabled, #downloadAllSmartButton:hover:enabled, #downloadManualButton:hover:enabled { background-color: rgba(255, 106, 193, 0.1); border-color: var(--accent-tertiary-dark); color: var(--accent-tertiary-dark); box-shadow: none; }
     #downloadAllButton:disabled, #downloadAllSmartButton:disabled, #downloadManualButton:disabled { background: transparent; border-color: var(--border-color); color: var(--text-secondary); opacity: 0.5; box-shadow: none; }

    #clearScreenshotsButton { margin-top: 1.5rem; /* Reduced margin */ padding: 0.6rem 1.2rem; font-size: 0.85rem; /* Slightly smaller */ background-color: transparent; border: 1px solid var(--border-dashed); color: var(--text-secondary); border-radius: var(--border-radius-md); cursor: pointer; transition: background-color 0.2s, color 0.2s, border-color 0.2s, box-shadow 0.2s; width: 100%; font-weight: 500; }
    #clearScreenshotsButton:hover:enabled { background-color: rgba(244, 63, 94, 0.1); color: var(--danger-color); border-color: var(--danger-color); box-shadow: 0 1px 4px rgba(244, 63, 94, 0.1); }
    #clearScreenshotsButton:disabled { opacity: 0.4; cursor: not-allowed; box-shadow: none; }

    /* Manual Mode (Compact) */
    #manualVideo { width: 100%; border-radius: var(--border-radius-lg); background-color: var(--black); margin-bottom: 1rem; /* Reduced margin */ aspect-ratio: 16 / 9; border: 1px solid var(--border-color); }
    .manual-buttons { display: flex; gap: 0.75rem; /* Reduced gap */ align-items: center; flex-wrap: wrap; }
    #extractManualButton { flex: 1 1 auto; padding: 0.65rem 1.1rem; /* Reduced padding */ font-size: 0.85rem; /* Slightly smaller */ background-color: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: var(--border-radius-md); color: var(--text-primary); cursor: pointer; transition: background-color 0.2s, border-color 0.2s, box-shadow 0.2s; font-weight: 500; min-width: 110px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
    #extractManualButton:hover { background-color: var(--border-color); border-color: var(--text-secondary); box-shadow: 0 2px 5px rgba(0,0,0,0.15); }
    /* Manual Download Button uses secondary outline style (handled above) */
    #addManualButton { width: 42px; height: 42px; /* Smaller */ background: var(--gradient-primary); border: none; border-radius: 50%; color: var(--bg-primary); font-size: 1.8rem; /* Slightly smaller '+' */ line-height: 1; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: background 0.3s ease, transform 0.1s, box-shadow 0.2s; flex-shrink: 0; box-shadow: 0 3px 6px rgba(0, 198, 255, 0.15); }
    #addManualButton:hover { background-position: right center; box-shadow: 0 5px 10px rgba(0, 198, 255, 0.25); }
    #addManualButton:active { transform: scale(0.95); box-shadow: 0 2px 4px rgba(0, 198, 255, 0.15); }

    /* Progress Bars (Compact) */
    .progress-bar-container { width: 100%; height: 8px; /* Thinner */ background-color: var(--bg-tertiary); border-radius: var(--border-radius-full); overflow: hidden; margin-top: 0.8rem; /* Reduced margin */ display: none; border: 1px solid var(--border-color); }
    .progress-bar-fill { height: 100%; width: 0%; background: var(--gradient-primary); border-radius: var(--border-radius-full); transition: width 0.3s ease-out; }
    #progressBarSmart .progress-bar-fill { background: var(--gradient-secondary); }

    /* Screenshots Grid (Compact) */
    .screenshot-container { position: relative; overflow: hidden; border-radius: var(--border-radius-md); border: 1px solid var(--border-color); background-color: var(--bg-secondary); transition: box-shadow 0.3s ease, border-color 0.3s ease; }
    .screenshot-container:hover { box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3); border-color: var(--accent-primary); }
    .screenshot-container a { display: block; line-height: 0; }
    .screenshot-container img { display: block; width: 100%; height: auto; object-fit: cover; border-radius: var(--border-radius-md); animation: fadeIn 0.5s ease-in-out; }
    .screenshot-overlay, .delete-btn { position: absolute; opacity: 0; transition: opacity 0.2s ease-in-out; pointer-events: none; }
    .screenshot-container:hover .screenshot-overlay, .screenshot-container:hover .delete-btn { opacity: 1; pointer-events: auto; }
    .screenshot-overlay { left: 0; bottom: 0; right: 0; background: linear-gradient(to top, rgba(10, 15, 31, 0.9), transparent); color: var(--white); font-size: 0.75rem; /* Smaller */ padding: 0.8rem 0.5rem 0.3rem; text-align: right; font-family: 'Source Code Pro', monospace; }
    .delete-btn { top: 6px; right: 6px; background: rgba(244, 63, 94, 0.7); border: none; color: var(--white); font-size: 0.9rem; width: 24px; height: 24px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; line-height: 1; backdrop-filter: blur(2px); transition: background-color 0.2s ease; }
    .delete-btn:hover { background: var(--danger-color); }
    @keyframes fadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }

    /* Hidden Elements */
    #video, #canvas { display: none; }
    #frameCanvas { display: none; }

    /* Responsive */
    @media (max-width: 800px) {
        body { overflow-y: auto; height: auto; }
        .app-container { flex-direction: column; height: auto; overflow: visible; }
        .vertical-separator { display: none; }
        .settings-column { flex-basis: auto; width: 100%; height: auto; max-height: none; border-right: none; overflow-y: visible; padding: 0; direction: ltr; background-color: var(--bg-secondary); border-bottom: 1px solid var(--border-color); /* Thinner border */ margin-bottom: 0; }
        .settings-content-wrapper { direction: ltr; padding: var(--content-padding); }
        .output-column { width: 100%; overflow-y: visible; background-color: var(--bg-primary); }
        #screenshots { padding: var(--content-padding); }
        h1 { margin-bottom: 1.25rem; border-bottom: 1px solid var(--border-color); }
    }
    @media (max-width: 600px) {
        :root { --content-padding: 1rem; /* Further reduced padding */ }
        body { font-size: 14px; } /* Smaller base font */
        .settings-content-wrapper { padding: 1rem; }
        #screenshots { padding: 1rem; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); /* Smaller grid items */ gap: 0.6rem; }
        .slider-label { width: 80px; } /* Even narrower */
        h1 { font-size: 1.8em; }
        .action-button { font-size: 0.9rem; padding: 0.7rem 1.2rem; }
        #dropZone { padding: 1.25rem 0.8rem; }
        #fileInfo { padding: 0.8rem 1rem; }
    }

    /* Toggle Switch (Compact) */
    .toggle-row { display: flex; align-items: center; margin-bottom: 1.25rem; /* Reduced margin */ background-color: var(--bg-tertiary); padding: 0.8rem 1rem; /* Reduced padding */ border-radius: var(--border-radius-md); border: 1px solid var(--border-color); }
    .toggle-label { flex: 1; font-size: 0.9rem; /* Slightly smaller */ color: var(--text-primary); font-weight: 500; margin-right: 0.8rem; }
    .toggle-switch { position: relative; display: inline-block; width: 48px; /* Smaller switch */ height: 24px; flex-shrink: 0; }
    .toggle-input { opacity: 0; width: 0; height: 0; }
    .toggle-label-switch { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--bg-primary); transition: .3s; border-radius: 24px; border: 1px solid var(--border-color); }
    .toggle-label-switch:before { position: absolute; content: ""; height: 18px; width: 18px; /* Smaller handle */ left: 2px; bottom: 2px; background-color: var(--text-secondary); transition: .3s; border-radius: 50%; box-shadow: 0 1px 2px rgba(0,0,0,0.15); }
    .toggle-input:checked + .toggle-label-switch { background: var(--gradient-primary); border-color: transparent; }
    .toggle-input:checked + .toggle-label-switch:before { transform: translateX(24px); background-color: var(--white); }
  </style>
</head>
<body>

  <div class="app-container">

    <div class="vertical-separator"></div>

    <div class="settings-column">
      <div class="settings-content-wrapper">
        <h1 id="pageTitle" data-text="Frame Capture Studio">Frame Capture Studio</h1>

        <div id="dropZone">
            <div id="uploadIcon"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM14 13v4h-4v-4H7l5-5 5 5h-3z"/></svg></div>
            <div id="dropZoneText">Drag & drop video file or</div>
            <button id="selectFileButton" type="button">Select File</button>
            <input type="file" id="videoInput" accept="video/*">
        </div>

        <div id="fileInfo">
            <div class="info-row"><div class="info-label">Resolution</div><div class="info-value" id="resolutionValue">-</div></div>
            <div class="info-row"><div class="info-label">Duration</div><div class="info-value" id="lengthValue">-</div></div>
            <div class="info-row"><div class="info-label">Aspect Ratio</div><div class="info-value" id="aspectRatioValue">-</div></div>
            <div class="info-row"><div class="info-label">Bitrate</div><div class="info-value" id="bitrateValue">-</div></div>
            <div class="info-row"><div class="info-label">Images</div><div class="info-value" id="imageCountValue">0</div></div>
        </div>

        <!-- Black Bars Removal Toggle -->
        <div class="toggle-row"><div class="toggle-label">Remove Black Bars</div><div class="toggle-switch"><input type="checkbox" id="removeBarsToggle" class="toggle-input"><label for="removeBarsToggle" class="toggle-label-switch"></label></div></div>

        <div class="segmented-controls mode-tabs">
            <button class="mode-tab active" data-mode="auto">Automated</button>
            <button class="mode-tab" data-mode="autoSmart">Smart Auto</button>
            <button class="mode-tab" data-mode="manual">Manual</button>
        </div>

        <div class="mode-content">
            <div id="autoMode" class="active">
              <div class="slider-row"><div class="slider-label">Interval</div><div class="slider-wrapper"><input type="range" id="intervalInput" min="1" max="30" value="10" step="1"><span id="intervalValue" class="value-display"></span></div></div>
              <div class="segmented-controls format-tabs"><button class="format-tab active" data-format="png">PNG</button><button class="format-tab" data-format="jpeg">JPEG</button><button class="format-tab" data-format="webp">WEBP</button></div>
              <div id="pngNote">Lossless quality, largest file size.</div>
              <div class="slider-row" id="jpegSettings" style="display:none;"><div class="slider-label">JPEG Quality</div><div class="slider-wrapper"><input type="range" id="jpegQuality" min="10" max="100" value="85" step="5"><span id="jpegQualityValue" class="value-display"></span></div></div>
              <div class="slider-row" id="webpSettings" style="display:none;"><div class="slider-label">WEBP Quality</div><div class="slider-wrapper"><input type="range" id="webpQuality" min="10" max="100" value="85" step="5"><span id="webpQualityValue" class="value-display"></span></div></div>

              <div class="button-group"><button id="processButton" class="action-button">Extract Screenshots</button><button id="downloadAllButton" class="action-button" disabled>Download All (.zip)</button></div>
              <div id="progressBar" class="progress-bar-container"><div id="progressBarFill" class="progress-bar-fill"></div></div>
            </div>
            <div id="autoSmartMode">
               <div class="segmented-controls smart-algo-tabs"><button class="smart-tab active" data-algo="histogram">Histogram Diff</button><button class="smart-tab" data-algo="pixeldiff">Pixel Diff</button><button class="smart-tab" data-algo="ssim">Low SSIM</button></div>
               <div class="segmented-controls format-tabs" id="smartFormatTabs"><button class="format-tab active" data-format="png">PNG</button><button class="format-tab" data-format="jpeg">JPEG</button><button class="format-tab" data-format="webp">WEBP</button></div>
               <div id="pngNoteSmart">Lossless quality, largest file size.</div>

               <!-- Smart Threshold Sliders -->
               <div class="slider-row" id="histThresholdSettings"><div class="slider-label">Hist Thresh</div><div class="slider-wrapper"><input type="range" id="histThresholdInput" min="0.05" max="0.75" value="0.35" step="0.05"><span id="histThresholdValue" class="value-display"></span></div></div>
               <div class="slider-row" id="pixelThresholdSettings" style="display:none;"><div class="slider-label">Pixel Thresh</div><div class="slider-wrapper"><input type="range" id="pixelThresholdInput" min="5" max="100" value="35" step="5"><span id="pixelThresholdValue" class="value-display"></span></div></div>
               <div class="slider-row" id="ssimThresholdSettings" style="display:none;"><div class="slider-label">SSIM Thresh</div><div class="slider-wrapper"><input type="range" id="ssimThresholdInput" min="0.5" max="0.99" value="0.90" step="0.01"><span id="ssimThresholdValue" class="value-display"></span></div></div>

               <div class="slider-row" id="jpegSettingsSmart" style="display:none;"><div class="slider-label">JPEG Quality</div><div class="slider-wrapper"><input type="range" id="jpegQualitySmart" min="10" max="100" value="85" step="5"><span id="jpegQualityValueSmart" class="value-display"></span></div></div>
               <div class="slider-row" id="webpSettingsSmart" style="display:none;"><div class="slider-label">WEBP Quality</div><div class="slider-wrapper"><input type="range" id="webpQualitySmart" min="10" max="100" value="85" step="5"><span id="webpQualityValueSmart" class="value-display"></span></div></div>

               <div class="button-group"><button id="processSmartButton" class="action-button">Extract Smart Shots</button><button id="downloadAllSmartButton" class="action-button" disabled>Download All (.zip)</button></div>
               <div id="progressBarSmart" class="progress-bar-container"><div id="progressBarFillSmart" class="progress-bar-fill"></div></div>
            </div>
            <div id="manualMode">
              <video id="manualVideo" controls></video>
              <div class="manual-buttons"><button id="extractManualButton" type="button">Quick Save Frame</button><button id="downloadManualButton" type="button" disabled>Download Added</button><button id="addManualButton" title="Add current frame to download list" type="button">+</button></div>
            </div>
        </div>

        <button id="clearScreenshotsButton" type="button" disabled>Clear All Screenshots</button>

      </div> <!-- End Settings Content Wrapper -->
    </div> <!-- End Settings Column -->

    <!-- Right Column: Output Area -->
    <div class="output-column">
      <div id="screenshots">
        <!-- Screenshot previews will be appended here -->
      </div>
    </div>

  </div> <!-- End App Container -->

  <!-- Hidden elements -->
  <video id="video" style="display:none;"></video>
  <canvas id="canvas"></canvas>
  <canvas id="frameCanvas" style="display:none;"></canvas>

  <script>
    // Strict mode helps catch common errors
    'use strict';

    // Global variables that will be initialized in DOMContentLoaded
    let verticalSeparatorElement = null; // Reference to the vertical separator element
    let cropData = null; // Will store crop boundaries data
    let removeBarsEnabled = false; // Flag to track if remove black bars is enabled

    document.addEventListener('DOMContentLoaded', () => {
      try {
        // --- DOM Element References ---
        const pageTitle = document.getElementById('pageTitle');
        const dropZone = document.getElementById('dropZone');
        const dropZoneText = document.getElementById('dropZoneText');
        const uploadIcon = document.getElementById('uploadIcon');
        const selectFileButton = document.getElementById('selectFileButton');
        const videoInput = document.getElementById('videoInput');

        const resolutionValue = document.getElementById('resolutionValue');
        const lengthValue = document.getElementById('lengthValue');
        const aspectRatioValue = document.getElementById('aspectRatioValue');
        const bitrateValue = document.getElementById('bitrateValue');
        const imageCountValue = document.getElementById('imageCountValue');

        const modeTabs = document.querySelectorAll('.mode-tab');
        const modeContentDiv = document.querySelector('.mode-content');
        const autoModeDiv = document.getElementById('autoMode');
        const autoSmartModeDiv = document.getElementById('autoSmartMode');
        const manualModeDiv = document.getElementById('manualMode');

        const intervalInput = document.getElementById('intervalInput');
        const intervalValue = document.getElementById('intervalValue');
        const jpegQualityAuto = document.getElementById('jpegQuality');
        const jpegQualityValueAuto = document.getElementById('jpegQualityValue');
        const webpQualityAuto = document.getElementById('webpQuality');
        const webpQualityValueAuto = document.getElementById('webpQualityValue');
        const jpegQualitySmart = document.getElementById('jpegQualitySmart');
        const jpegQualityValueSmart = document.getElementById('jpegQualityValueSmart');
        const webpQualitySmart = document.getElementById('webpQualitySmart');
        const webpQualityValueSmart = document.getElementById('webpQualityValueSmart');

        const formatTabsAuto = document.querySelectorAll('#autoMode .format-tab');
        const pngNoteAuto = document.getElementById('pngNote');
        const jpegSettingsAuto = document.getElementById('jpegSettings');
        const webpSettingsAuto = document.getElementById('webpSettings');
        const formatTabsSmart = document.querySelectorAll('#smartFormatTabs .format-tab');
        const pngNoteSmart = document.getElementById('pngNoteSmart');
        const jpegSettingsSmart = document.getElementById('jpegSettingsSmart');
        const webpSettingsSmart = document.getElementById('webpSettingsSmart');

        const processButton = document.getElementById('processButton');
        const downloadAllButton = document.getElementById('downloadAllButton');
        const progressBarAuto = document.getElementById('progressBar');
        const progressBarFillAuto = document.getElementById('progressBarFill');
        const processSmartButton = document.getElementById('processSmartButton');
        const downloadAllSmartButton = document.getElementById('downloadAllSmartButton');
        const progressBarSmart = document.getElementById('progressBarSmart');
        const progressBarFillSmart = document.getElementById('progressBarFillSmart');

        const smartAlgoTabs = document.querySelectorAll('.smart-tab');

        const histThresholdSettings = document.getElementById('histThresholdSettings');
        const pixelThresholdSettings = document.getElementById('pixelThresholdSettings');
        const ssimThresholdSettings = document.getElementById('ssimThresholdSettings');

        const manualVideo = document.getElementById('manualVideo');
        const frameCanvas = document.getElementById('frameCanvas');
        const extractManualButton = document.getElementById('extractManualButton');
        const addManualButton = document.getElementById('addManualButton');
        const downloadManualButton = document.getElementById('downloadManualButton');

        const removeBarsToggle = document.getElementById('removeBarsToggle');
        const screenshotsDiv = document.getElementById('screenshots');
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const clearScreenshotsButton = document.getElementById('clearScreenshotsButton');

        // Get reference to vertical separator
        verticalSeparatorElement = document.querySelector('.vertical-separator');
        console.log('Vertical separator element found:', !!verticalSeparatorElement);

        // --- Check if Core Elements Exist ---
        if (!dropZone || !videoInput || !selectFileButton || !video || !manualVideo || !canvas || !modeContentDiv || !screenshotsDiv || !clearScreenshotsButton) {
            throw new Error("One or more critical HTML elements are missing. Check IDs.");
        }

        // --- State Variables ---
        let currentMode = 'auto';
        let currentFormat = 'png';
        let smartAlgorithm = 'histogram';
        let uploadedFile = null;
        let currentVideoDuration = 0;
        let processingActive = false;
        let cancelExtractionRequested = false;
        let screenshotBlobs = []; // { blob, timestamp }
        let manualScreenshotBlobs = []; // { blob, timestamp }
        let currentAnimationFrameId = null; // To cancel extraction loops

        // --- Helper Functions ---
        const updateSliderBackground = (slider) => {
            if (!slider) return;
            const val = slider.value;
            const min = slider.min || 0; // Default min if not set
            const max = slider.max || 100; // Default max if not set
            const pct = ((val - min) * 100) / (max - min);

            // Determine color based on slider context (Auto vs Smart)
            let color = 'var(--accent-primary)'; // Default to primary (cyan)
            if (slider.closest('#autoSmartMode')) { // Check if inside smart mode div
                color = 'var(--accent-secondary)'; // Use secondary (teal) for smart mode sliders
            }
            slider.style.background = `linear-gradient(to right, ${color} 0%, ${color} ${pct}%, var(--bg-tertiary) ${pct}%, var(--bg-tertiary) 100%)`;
        };

        const formatTime = (seconds) => { if (isNaN(seconds) || seconds < 0) return "0:00"; const s = Math.floor(seconds); const m = Math.floor(s / 60); const sec = s % 60; return m + ":" + (sec < 10 ? "0" + sec : sec); };
        const gcd = (a, b) => { return b ? gcd(b, a % b) : a; };
        const updateFileInfoDisplay = () => { if (!video?.duration || !video?.videoWidth || !video?.videoHeight || !resolutionValue || !lengthValue || !aspectRatioValue || !bitrateValue) return; currentVideoDuration = video.duration; const width = video.videoWidth; const height = video.videoHeight; resolutionValue.textContent = `${width}x${height}`; lengthValue.textContent = formatTime(currentVideoDuration); const divisor = gcd(width, height); aspectRatioValue.textContent = `${width / divisor}:${height / divisor}`; if (uploadedFile && uploadedFile.size > 0 && currentVideoDuration > 0) { const bitrateKbps = Math.round((uploadedFile.size * 8) / currentVideoDuration / 1000); bitrateValue.textContent = `${bitrateKbps} kbps`; } else { bitrateValue.textContent = "N/A"; } };
        const updateImageCount = () => { const autoSmartCount = screenshotBlobs.length; const manualCount = manualScreenshotBlobs.length; const totalCount = screenshotsDiv ? screenshotsDiv.childElementCount : 0; if(imageCountValue) imageCountValue.textContent = totalCount; if(downloadAllButton) downloadAllButton.disabled = currentMode !== 'auto' || autoSmartCount === 0 || processingActive; if(downloadAllSmartButton) downloadAllSmartButton.disabled = currentMode !== 'autoSmart' || autoSmartCount === 0 || processingActive; if(downloadManualButton) downloadManualButton.disabled = currentMode !== 'manual' || manualCount === 0 || processingActive; if(clearScreenshotsButton) clearScreenshotsButton.disabled = totalCount === 0; };

        // --- UI State Management ---
        const resetProcessingUI = (mode = 'all') => {
            console.log(`[Reset UI] Resetting for mode: ${mode}`);
            processingActive = false;
            cancelExtractionRequested = false;

            if (verticalSeparatorElement) {
                verticalSeparatorElement.classList.remove('loading');
                verticalSeparatorElement.classList.remove('loading-smart');
            }

            if (currentAnimationFrameId) {
                cancelAnimationFrame(currentAnimationFrameId);
                currentAnimationFrameId = null;
            }

            if ((mode === 'auto' || mode === 'all') && processButton) {
                if(progressBarAuto) progressBarAuto.style.display = 'none';
                if(progressBarFillAuto) progressBarFillAuto.style.width = '0%';
                processButton.disabled = !video?.src;
                processButton.textContent = 'Extract Screenshots';
                processButton.classList.remove('cancel-active');
                processButton.removeEventListener('click', handleCancelClick);
                processButton.addEventListener('click', startAutoExtraction);
                if(downloadAllButton) downloadAllButton.disabled = currentMode !== 'auto' || screenshotBlobs.length === 0;
            }

            if ((mode === 'autoSmart' || mode === 'all') && processSmartButton) {
                if(progressBarSmart) progressBarSmart.style.display = 'none';
                if(progressBarFillSmart) progressBarFillSmart.style.width = '0%';
                processSmartButton.disabled = !video?.src;
                processSmartButton.textContent = 'Extract Smart Shots';
                processSmartButton.classList.remove('cancel-active');
                processSmartButton.removeEventListener('click', handleCancelClick);
                processSmartButton.addEventListener('click', startSmartExtraction);
                if(downloadAllSmartButton) downloadAllSmartButton.disabled = currentMode !== 'autoSmart' || screenshotBlobs.length === 0;
            }

            if (mode === 'manual' || mode === 'all') {
                if(addManualButton) addManualButton.disabled = !video?.src;
                if(extractManualButton) extractManualButton.disabled = !video?.src;
                if(downloadManualButton) downloadManualButton.disabled = currentMode !== 'manual' || manualScreenshotBlobs.length === 0;
            }

            if (video?.src) {
                if(processButton && currentMode !== 'auto') processButton.disabled = false;
                if(processSmartButton && currentMode !== 'autoSmart') processSmartButton.disabled = false;
            }

            updateImageCount();
        };

        const setProcessingUI = (mode = 'auto') => {
             console.log(`[Set UI] Setting processing state for mode: ${mode}`);
             processingActive = true;
             cancelExtractionRequested = false;

             if (verticalSeparatorElement) {
                 if (mode === 'auto') {
                     verticalSeparatorElement.classList.add('loading');
                 } else if (mode === 'autoSmart') {
                     verticalSeparatorElement.classList.add('loading-smart');
                 }
             }

             if(processButton) processButton.disabled = true;
             if(processSmartButton) processSmartButton.disabled = true;
             if(addManualButton) addManualButton.disabled = true;
             if(extractManualButton) extractManualButton.disabled = true;
             if(downloadAllButton) downloadAllButton.disabled = true;
             if(downloadAllSmartButton) downloadAllSmartButton.disabled = true;
             if(downloadManualButton) downloadManualButton.disabled = true;
             if(clearScreenshotsButton) clearScreenshotsButton.disabled = true;

             if (mode === 'auto' && processButton) {
                 if(progressBarAuto) progressBarAuto.style.display = 'block';
                 processButton.textContent = 'Cancel Extraction';
                 processButton.classList.add('cancel-active');
                 processButton.removeEventListener('click', startAutoExtraction);
                 processButton.addEventListener('click', handleCancelClick, { once: true });
                 processButton.disabled = false;
             } else if (mode === 'autoSmart' && processSmartButton) {
                 if(progressBarSmart) progressBarSmart.style.display = 'block';
                 processSmartButton.textContent = 'Cancel Extraction';
                 processSmartButton.classList.add('cancel-active');
                 processSmartButton.removeEventListener('click', startSmartExtraction);
                 processSmartButton.addEventListener('click', handleCancelClick, { once: true });
                 processSmartButton.disabled = false;
             }
         };

        const handleCancelClick = () => {
            console.log("[Cancel Action] Cancel requested by user.");
            cancelExtractionRequested = true;
        };

        // --- Helper Functions (Cont.) ---
        const computeHistogram = (imageData, sampleFactor = 4) => { const data = imageData.data; const hist = new Array(256).fill(0); let count = 0; for (let i = 0; i < data.length; i += 4 * sampleFactor) { const gray = Math.round(0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]); hist[gray]++; count++; } if (count === 0) return hist; return hist.map(val => val / count); };
        const histogramDifference = (hist1, hist2) => { if (!hist1 || !hist2 || hist1.length !== hist2.length) return 1; return hist1.reduce((acc, val, i) => acc + Math.abs(val - hist2[i]), 0); };
        const computePixelDiff = (data1, data2, sampleFactor = 4) => { let diff = 0; let count = 0; const step = 4 * sampleFactor; for (let i = 0; i < data1.length; i += step) { diff += Math.abs(data1[i] - data2[i]); diff += Math.abs(data1[i+1] - data2[i+1]); diff += Math.abs(data1[i+2] - data2[i+2]); count++; } return count > 0 ? (diff / (count * 3)) : 0; };
        const computeSSIM = (imageData1, imageData2, sampleFactor = 4) => { const data1 = imageData1.data; const data2 = imageData2.data; let sum1 = 0, sum2 = 0, count = 0; const step = 4 * sampleFactor; for (let i = 0; i < data1.length; i += step) { sum1 += (0.299 * data1[i] + 0.587 * data1[i + 1] + 0.114 * data1[i + 2]); sum2 += (0.299 * data2[i] + 0.587 * data2[i + 1] + 0.114 * data2[i + 2]); count++; } if (count === 0) return 1; const avg1 = sum1 / count; const avg2 = sum2 / count; const maxDiff = 255; const avgDiff = Math.abs(avg1 - avg2); return Math.max(0, 1 - (avgDiff / maxDiff)); };
        const createScreenshotElement = (blob, timestamp, blobArrayRef) => { if(!screenshotsDiv || !blob) return null; const container = document.createElement('div'); container.className = "screenshot-container"; const blobUrl = URL.createObjectURL(blob); container.dataset.blobUrl = blobUrl; container.dataset.timestamp = String(timestamp); const a = document.createElement('a'); a.href = blobUrl; a.target = "_blank"; const img = document.createElement('img'); img.src = blobUrl; img.alt = `Screenshot at ${formatTime(timestamp)}`; a.appendChild(img); container.appendChild(a); if (timestamp >= 0) { const overlay = document.createElement('div'); overlay.className = "screenshot-overlay"; overlay.textContent = formatTime(timestamp); container.appendChild(overlay); } const delBtn = document.createElement('button'); delBtn.className = "delete-btn"; delBtn.innerHTML = "×"; delBtn.title = "Remove this screenshot"; delBtn.addEventListener('click', (e) => { e.stopPropagation(); const urlToRemove = container.dataset.blobUrl; const timeToRemove = parseFloat(container.dataset.timestamp); const indexToRemove = blobArrayRef.findIndex(item => item.timestamp === timeToRemove && item.blob.size === blob.size); if (indexToRemove > -1) { blobArrayRef.splice(indexToRemove, 1); } else { console.warn("Could not find blob to remove."); } URL.revokeObjectURL(urlToRemove); container.remove(); updateImageCount(); }); container.appendChild(delBtn); return container; };

        // --- Updated getCurrentFormatSettings to determine format based on active mode ---
        const getCurrentFormatSettings = () => {
            let format = 'png'; // Default
            let qualitySlider = null;
            let qualityValue = 1.0; // Default quality for PNG

            // Determine active format based on the currently selected mode's tabs
            const activeModeId = document.querySelector('.mode-content > div.active')?.id;
            const activeFormatTab = document.querySelector(`#${activeModeId} .format-tab.active`);

            if (activeFormatTab) {
                format = activeFormatTab.getAttribute('data-format') || 'png';
            }

            // Find the correct quality slider based on mode and format
            if (format === 'jpeg') {
                qualitySlider = (activeModeId === 'autoSmartMode') ? jpegQualitySmart : jpegQualityAuto;
                qualityValue = qualitySlider ? parseFloat(qualitySlider.value) / 100 : 0.85; // Default JPEG quality
            } else if (format === 'webp') {
                qualitySlider = (activeModeId === 'autoSmartMode') ? webpQualitySmart : webpQualityAuto;
                qualityValue = qualitySlider ? parseFloat(qualitySlider.value) / 100 : 0.85; // Default WebP quality
            }

            const type = `image/${format}`;
            return { type, quality: qualityValue };
        };

        const downloadBlobsAsZip = (blobDataArray, baseFilename = "screenshots") => { if (!blobDataArray || blobDataArray.length === 0) { alert("No screenshots to download."); return; } if (!window.JSZip) { alert("Error: JSZip library not loaded."); return; } const zip = new JSZip(); const { type } = getCurrentFormatSettings(); // Use current settings for consistency
            const extension = type.split('/')[1] === 'jpeg' ? 'jpg' : type.split('/')[1]; blobDataArray.forEach((item, index) => { const timeSuffix = (item.timestamp !== undefined && item.timestamp >= 0) ? `_${formatTime(item.timestamp).replace(':','-')}` : `_${index + 1}`; const filename = `${baseFilename}${timeSuffix}.${extension}`; zip.file(filename, item.blob); }); zip.generateAsync({ type: "blob" }).then((content) => { const tempLink = document.createElement('a'); const url = URL.createObjectURL(content); tempLink.href = url; tempLink.download = `${baseFilename}.zip`; document.body.appendChild(tempLink); tempLink.click(); document.body.removeChild(tempLink); URL.revokeObjectURL(url); }).catch((err) => { console.error("Error generating ZIP:", err); alert("Error creating ZIP file: " + err.message); }); };
        const handleFileLoad = (file) => { if (!video || !manualVideo || !file) return; uploadedFile = file; const fileURL = URL.createObjectURL(file); video.src = fileURL; manualVideo.src = fileURL; updateDropZoneUI(true, file.name); resetUIOnNewVideo(); };
        const resetUIOnNewVideo = () => { if(screenshotsDiv) screenshotsDiv.innerHTML = ''; screenshotBlobs = []; manualScreenshotBlobs = []; updateImageCount(); resetProcessingUI('all'); if(resolutionValue) resolutionValue.textContent = "Loading..."; if(lengthValue) lengthValue.textContent = "-"; if(aspectRatioValue) aspectRatioValue.textContent = "-"; if(bitrateValue) bitrateValue.textContent = "-"; };
        const updateDropZoneUI = (isFileLoaded, text) => { if(!dropZone || !dropZoneText || !selectFileButton || !uploadIcon) return; dropZoneText.textContent = text; if (isFileLoaded) { dropZone.classList.add('file-loaded'); selectFileButton.textContent = "File Loaded"; selectFileButton.classList.add('file-selected'); uploadIcon.innerHTML = `<svg viewBox="0 0 24 24" fill="var(--accent-secondary)"><path d="M9 16.17l-3.88-3.88L4 13.41 9 18.41l12-12-1.41-1.42z"/></svg>`; } else { dropZone.classList.remove('file-loaded'); selectFileButton.textContent = "Select File"; selectFileButton.classList.remove('file-selected'); uploadIcon.innerHTML = `<svg viewBox="0 0 24 24" fill="currentColor"><path d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM14 13v4h-4v-4H7l5-5 5 5h-3z"/></svg>`; dropZoneText.textContent = "Drag & drop video file or"; } };
        const captureFrameAtTime = (time, callback) => {
            if (!video || !canvas || !video.src || video.readyState < 1 ) {
                console.error("Video/Canvas not ready for captureFrameAtTime");
                callback(null);
                return;
            }
            const videoElement = video;
            let seekTimeout = setTimeout(() => {
                console.warn(`[captureFrameAtTime] Seek timed out for ${time.toFixed(2)}s`);
                videoElement.removeEventListener('seeked', onSeeked);
                videoElement.removeEventListener('error', onError);
                callback(null);
            }, 5000);

            const onSeeked = () => {
                clearTimeout(seekTimeout);
                videoElement.removeEventListener('error', onError);
                try {
                    if (!canvas) throw new Error('Canvas element not found');
                    const ctx = canvas.getContext('2d');
                    if (!ctx) throw new Error('Could not get 2d context');

                    // Apply cropping if enabled and data exists
                    if (removeBarsEnabled && cropData && cropData.cropWidth > 0 && cropData.cropHeight > 0) {
                        canvas.width = cropData.cropWidth;
                        canvas.height = cropData.cropHeight;
                        ctx.drawImage(
                            videoElement,
                            cropData.cropX, cropData.cropY, cropData.cropWidth, cropData.cropHeight,
                            0, 0, cropData.cropWidth, cropData.cropHeight
                        );
                    } else {
                        // Fallback to full frame if no crop data or invalid crop dimensions
                        canvas.width = videoElement.videoWidth;
                        canvas.height = videoElement.videoHeight;
                         if (canvas.width === 0 || canvas.height === 0) {
                            console.warn("[captureFrameAtTime] Video dimensions are zero during draw.");
                            callback(null); // Don't proceed if dimensions are bad
                            return;
                        }
                        ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
                    }

                    const { type, quality } = getCurrentFormatSettings(); // Get format/quality based on active mode
                    canvas.toBlob((blob) => {
                        if (blob) {
                            callback(blob);
                        } else {
                            console.error("[captureFrameAtTime] canvas.toBlob failed - callback received null blob.");
                            callback(null);
                        }
                    }, type, quality);
                } catch (error) {
                    console.error("[captureFrameAtTime] Error during drawing/blob creation:", error);
                    callback(null);
                }
            };

            const onError = (e) => {
                clearTimeout(seekTimeout);
                videoElement.removeEventListener('seeked', onSeeked);
                console.error(`[captureFrameAtTime] Video error during seek/load for time ${time.toFixed(2)}s:`, e);
                callback(null);
            };

            videoElement.addEventListener('seeked', onSeeked, { once: true });
            videoElement.addEventListener('error', onError, { once: true });

            try {
                const targetTime = Math.max(0, Math.min(time, currentVideoDuration));
                 // Add a check to prevent setting currentTime if it's already very close
                 if (Math.abs(videoElement.currentTime - targetTime) > 0.01) {
                    videoElement.currentTime = targetTime;
                 } else {
                    // If already at the target time, trigger the seeked logic directly
                     onSeeked();
                 }
            } catch (error) {
                console.error(`[captureFrameAtTime] Error setting video currentTime:`, error);
                clearTimeout(seekTimeout);
                videoElement.removeEventListener('seeked', onSeeked);
                videoElement.removeEventListener('error', onError);
                callback(null);
            }
        };


        // --- Event Listeners Setup ---

        if (pageTitle) pageTitle.addEventListener('click', () => { if (confirm("Reload the application? Any unsaved screenshots will be lost.")) window.location.reload(); });
        if (video) video.addEventListener('loadedmetadata', () => {
            updateFileInfoDisplay();
            resetProcessingUI('all');
            cropData = null; // Reset crop data
            if (removeBarsEnabled) {
                detectCropBoundariesMulti(() => console.log("Black bar detection on new video load complete."));
            }
        });
        if (manualVideo) manualVideo.addEventListener('loadedmetadata', updateFileInfoDisplay);

        // File Upload Listeners
        if (videoInput) videoInput.addEventListener('change', (event) => { const file = event.target.files[0]; if (file) handleFileLoad(file); });
        if (dropZone) {
            dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('hover'); });
            dropZone.addEventListener('dragleave', (e) => { e.preventDefault(); dropZone.classList.remove('hover'); });
            dropZone.addEventListener('drop', (e) => { e.preventDefault(); dropZone.classList.remove('hover'); const file = e.dataTransfer.files[0]; if (file && file.type.startsWith('video/')) handleFileLoad(file); else alert("Please drop a valid video file."); });
            dropZone.addEventListener('click', (e) => { if (selectFileButton && !selectFileButton.contains(e.target) && videoInput) videoInput.click(); });
        }
        if (selectFileButton) selectFileButton.addEventListener('click', (e) => { e.stopPropagation(); if(videoInput) videoInput.click(); });

        // Mode Tab Switching
        if (modeTabs.length > 0 && modeContentDiv) {
            modeTabs.forEach(tab => {
                tab.addEventListener('click', () => {
                  if (processingActive) return;
                  const newMode = tab.getAttribute('data-mode');
                  if (!newMode || !modeContentDiv) return;
                  currentMode = newMode; // Update global mode state
                  modeTabs.forEach(t => t.classList.remove('active'));
                  tab.classList.add('active');
                  Array.from(modeContentDiv.children).forEach(contentDiv => {
                      contentDiv.classList.toggle('active', contentDiv.id === `${newMode}Mode`);
                  });
                   // Re-apply correct background to sliders in the newly active mode
                   document.querySelectorAll(`#${newMode}Mode input[type="range"]`).forEach(updateSliderBackground);
                  updateImageCount(); // Update button states based on new mode/counts
                });
            });
        }

        // Slider Setup
        const setupSlider = (slider, displaySpan, suffix) => { if (!slider || !displaySpan) return; const updateSliderUI = () => { displaySpan.textContent = slider.value + suffix; updateSliderBackground(slider); }; slider.addEventListener('input', updateSliderUI); updateSliderUI(); };
        setupSlider(intervalInput, intervalValue, 's');
        setupSlider(jpegQualityAuto, jpegQualityValueAuto, '%');
        setupSlider(webpQualityAuto, webpQualityValueAuto, '%');
        setupSlider(jpegQualitySmart, jpegQualityValueSmart, '%');
        setupSlider(webpQualitySmart, webpQualityValueSmart, '%');
        const histThresholdInput = document.getElementById('histThresholdInput');
        const histThresholdValue = document.getElementById('histThresholdValue');
        const pixelThresholdInput = document.getElementById('pixelThresholdInput');
        const pixelThresholdValue = document.getElementById('pixelThresholdValue');
        const ssimThresholdInput = document.getElementById('ssimThresholdInput');
        const ssimThresholdValue = document.getElementById('ssimThresholdValue');
        setupSlider(histThresholdInput, histThresholdValue, '');
        setupSlider(pixelThresholdInput, pixelThresholdValue, '');
        setupSlider(ssimThresholdInput, ssimThresholdValue, '');

        // Black Bars Detection and Removal
        const detectCropBoundariesMulti = (callback) => {
          if (!video.duration || !isFinite(video.duration) || video.videoWidth === 0 || video.videoHeight === 0) {
            console.warn("Video not ready/valid for crop detection.");
            cropData = { cropX: 0, cropY: 0, cropWidth: video.videoWidth || 1, cropHeight: video.videoHeight || 1 };
            callback(); return;
          }
          const samplePercents = [0.3, 0.5, 0.7];
          const sampleTimes = samplePercents.map(p => Math.min(Math.max(p * video.duration, 0.1), video.duration - 0.1));
          let sampleResults = []; let currentSample = 0;

          function analyzeFrame(callbackFrame) {
            if (!frameCanvas || video.videoWidth === 0 || video.videoHeight === 0) {
                console.warn("Frame canvas or video dimensions invalid during analysis.");
                callbackFrame({ topCrop: 0, bottomCrop: (video.videoHeight || 1) - 1, leftCrop: 0, rightCrop: (video.videoWidth || 1) - 1 });
                return;
            }
            frameCanvas.width = video.videoWidth; frameCanvas.height = video.videoHeight;
            const ctx = frameCanvas.getContext("2d", { willReadFrequently: true });
            if (!ctx) {
                 console.error("Could not get frameCanvas context for analysis.");
                 callbackFrame({ topCrop: 0, bottomCrop: video.videoHeight - 1, leftCrop: 0, rightCrop: video.videoWidth - 1 });
                 return;
            }
            ctx.drawImage(video, 0, 0, video.videoWidth, video.videoHeight);
            const imageData = ctx.getImageData(0, 0, video.videoWidth, video.videoHeight);
            const data = imageData.data, width = video.videoWidth, height = video.videoHeight;
            const pixelThreshold = 15, lineRatioThreshold = 0.98;
            let topCrop = 0, bottomCrop = height - 1, leftCrop = 0, rightCrop = width - 1;

            // Top
            for (let y = 0; y < height / 2; y++) { let blackPxCount = 0; for (let x = 0; x < width; x++) { const i = (y * width + x) * 4; if (data[i] < pixelThreshold && data[i + 1] < pixelThreshold && data[i + 2] < pixelThreshold) blackPxCount++; } if (blackPxCount / width < lineRatioThreshold) { topCrop = y; break; } if (y === Math.floor(height / 2) - 1) topCrop = y; }
            // Bottom
            for (let y = height - 1; y >= height / 2; y--) { let blackPxCount = 0; for (let x = 0; x < width; x++) { const i = (y * width + x) * 4; if (data[i] < pixelThreshold && data[i + 1] < pixelThreshold && data[i + 2] < pixelThreshold) blackPxCount++; } if (blackPxCount / width < lineRatioThreshold) { bottomCrop = y; break; } if (y === Math.ceil(height / 2)) bottomCrop = y; }
            // Left
            for (let x = 0; x < width / 2; x++) { let blackPxCount = 0; for (let y = topCrop; y <= bottomCrop; y++) { const i = (y * width + x) * 4; if (data[i] < pixelThreshold && data[i + 1] < pixelThreshold && data[i + 2] < pixelThreshold) blackPxCount++; } if (blackPxCount / (bottomCrop - topCrop + 1) < lineRatioThreshold) { leftCrop = x; break; } if (x === Math.floor(width / 2) - 1) leftCrop = x; }
            // Right
            for (let x = width - 1; x >= width / 2; x--) { let blackPxCount = 0; for (let y = topCrop; y <= bottomCrop; y++) { const i = (y * width + x) * 4; if (data[i] < pixelThreshold && data[i + 1] < pixelThreshold && data[i + 2] < pixelThreshold) blackPxCount++; } if (blackPxCount / (bottomCrop - topCrop + 1) < lineRatioThreshold) { rightCrop = x; break; } if (x === Math.ceil(width / 2)) rightCrop = x; }

            callbackFrame({ topCrop, bottomCrop, leftCrop, rightCrop });
          }
          function median(arr) { const sorted = arr.slice().sort((a, b) => a - b); return sorted[Math.floor(sorted.length / 2)]; }

          function processNextSample() {
            if (currentSample >= sampleTimes.length) {
              const finalTop = median(sampleResults.map(r => r.topCrop)); const finalBottom = median(sampleResults.map(r => r.bottomCrop)); const finalLeft = median(sampleResults.map(r => r.leftCrop)); const finalRight = median(sampleResults.map(r => r.rightCrop));
              const finalCropWidth = Math.max(1, finalRight - finalLeft + 1); const finalCropHeight = Math.max(1, finalBottom - finalTop + 1);
              cropData = { cropX: finalLeft, cropY: finalTop, cropWidth: finalCropWidth, cropHeight: finalCropHeight };
              console.log("Detected black bars crop data:", cropData); callback(); return;
            }
            const sampleTime = sampleTimes[currentSample];
            const seekHandler = () => { video.removeEventListener("seeked", seekHandler); analyzeFrame((boundaries) => { sampleResults.push(boundaries); currentSample++; processNextSample(); }); };
            const errorHandler = (e) => { console.error("Seek error during crop detection:", e); video.removeEventListener("error", errorHandler); sampleResults.push({ topCrop: 0, bottomCrop: (video.videoHeight || 1) - 1, leftCrop: 0, rightCrop: (video.videoWidth || 1) - 1 }); currentSample++; processNextSample(); };
            video.addEventListener("seeked", seekHandler, { once: true }); video.addEventListener("error", errorHandler, { once: true });
            if (Math.abs(video.currentTime - sampleTime) > 0.01) video.currentTime = sampleTime; else seekHandler(); // Trigger if already there
          }
          processNextSample();
        };

        if (removeBarsToggle) removeBarsToggle.addEventListener('change', (e) => {
          removeBarsEnabled = e.target.checked;
          if (removeBarsEnabled && !cropData && video?.src) { // Only detect if needed and video exists
            detectCropBoundariesMulti(() => console.log("Black bar detection completed after toggle."));
          }
        });

        // Setup Format Tabs - Handles PNG Note & Quality Slider Visibility per Mode
        const setupFormatTabs = (tabsNodeList, pngNoteEl, jpegSettingsEl, webpSettingsEl) => {
            if (tabsNodeList.length === 0 || !pngNoteEl || !jpegSettingsEl || !webpSettingsEl) return;
            const updateFormatVisibility = (format) => {
                pngNoteEl.style.display = (format === 'png') ? 'flex' : 'none';
                jpegSettingsEl.style.display = (format === 'jpeg') ? 'flex' : 'none';
                webpSettingsEl.style.display = (format === 'webp') ? 'flex' : 'none';
            };
            let initialFormat = 'png';
            tabsNodeList.forEach(tab => {
                if (tab.classList.contains('active')) initialFormat = tab.getAttribute('data-format') || 'png';
                tab.addEventListener('click', () => {
                    if (processingActive) return;
                    const format = tab.getAttribute('data-format');
                    if (!format) return;
                    tabsNodeList.forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    updateFormatVisibility(format);
                    // Note: currentFormat is implicitly handled by getCurrentFormatSettings() now
                });
            });
            updateFormatVisibility(initialFormat); // Set initial visibility
        };
        setupFormatTabs(formatTabsAuto, pngNoteAuto, jpegSettingsAuto, webpSettingsAuto);
        setupFormatTabs(formatTabsSmart, pngNoteSmart, jpegSettingsSmart, webpSettingsSmart);


        // Smart Algo Tabs
        if (smartAlgoTabs.length > 0) {
            let initialAlgo = 'histogram';
            const updateThresholdSliders = (algo) => {
                if(histThresholdSettings) histThresholdSettings.style.display = (algo === 'histogram') ? 'flex' : 'none';
                if(pixelThresholdSettings) pixelThresholdSettings.style.display = (algo === 'pixeldiff') ? 'flex' : 'none';
                if(ssimThresholdSettings) ssimThresholdSettings.style.display = (algo === 'ssim') ? 'flex' : 'none';
            };
            smartAlgoTabs.forEach(tab => {
                if (tab.classList.contains('active')) initialAlgo = tab.getAttribute('data-algo') || 'histogram';
                tab.addEventListener('click', () => {
                    if (processingActive) return;
                    const algo = tab.getAttribute('data-algo');
                    if(!algo) return;
                    smartAlgorithm = algo; // Update global state
                    smartAlgoTabs.forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    updateThresholdSliders(algo);
                });
            });
            smartAlgorithm = initialAlgo;
            updateThresholdSliders(initialAlgo);
        }

        // --- Processing Logic ---

        // AUTOMATED EXTRACTION
        const startAutoExtraction = () => {
            if (!video?.src || processingActive || !intervalInput) return;
            setProcessingUI('auto');
            if(screenshotsDiv) screenshotsDiv.innerHTML = '';
            screenshotBlobs = [];
            updateImageCount();

            const interval = parseFloat(intervalInput.value);
            if (isNaN(interval) || interval <= 0) { resetProcessingUI('auto'); return; }
            let currentTime = 0; const totalDuration = currentVideoDuration;

            function processNextFrame() {
                if (cancelExtractionRequested || currentTime > totalDuration + 0.1) { resetProcessingUI('auto'); return; }
                const timestamp = currentTime;
                captureFrameAtTime(timestamp, (blob) => {
                    if (!cancelExtractionRequested && blob) {
                        const blobData = { blob, timestamp }; screenshotBlobs.push(blobData);
                        const container = createScreenshotElement(blob, timestamp, screenshotBlobs);
                        if(container && screenshotsDiv) screenshotsDiv.appendChild(container); updateImageCount();
                    }
                    if (!cancelExtractionRequested) {
                        currentTime += interval;
                        const progress = Math.min((currentTime / totalDuration) * 100, 100);
                        if(progressBarFillAuto) progressBarFillAuto.style.width = `${progress}%`;
                        currentAnimationFrameId = requestAnimationFrame(processNextFrame);
                    } else { resetProcessingUI('auto'); }
                });
            }
            currentAnimationFrameId = requestAnimationFrame(processNextFrame);
        };

        // SMART EXTRACTION
        const startSmartExtraction = () => {
            if (!video?.src || processingActive) return;
             setProcessingUI('autoSmart');
             if(screenshotsDiv) screenshotsDiv.innerHTML = '';
             screenshotBlobs = []; updateImageCount();
             const smartInterval = 1.0; const sampleFactor = 8;
             const histThreshold = histThresholdInput ? parseFloat(histThresholdInput.value) : 0.35;
             const pixelThreshold = pixelThresholdInput ? parseFloat(pixelThresholdInput.value) : 35;
             const ssimThreshold = ssimThresholdInput ? parseFloat(ssimThresholdInput.value) : 0.90;
             let currentTime = 0; const totalDuration = currentVideoDuration;
             let previousImageData = null; let previousHist = null; let previousPixelData = null;

             function processNextSmartFrame() {
                 if (cancelExtractionRequested || currentTime > totalDuration + 0.1) { resetProcessingUI('autoSmart'); return; }
                 const timestamp = currentTime;
                 captureFrameAtTime(timestamp, (blob) => {
                     if (cancelExtractionRequested) { resetProcessingUI('autoSmart'); return; }
                     if (!blob) { currentTime += smartInterval; const progress = Math.min((currentTime / totalDuration) * 100, 100); if(progressBarFillSmart) progressBarFillSmart.style.width = `${progress}%`; currentAnimationFrameId = requestAnimationFrame(processNextSmartFrame); return; }

                     const tempCanvas = document.createElement('canvas');
                     const tempCtx = tempCanvas.getContext('2d');
                     const img = new Image();
                     img.onload = () => {
                        if (cancelExtractionRequested) { resetProcessingUI('autoSmart'); return; }
                        try {
                             tempCanvas.width = img.width; tempCanvas.height = img.height;
                             if(!tempCtx) throw new Error("Could not get temp canvas context");
                             ctx.drawImage(img, 0, 0);
                             const currentImageData = ctx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                             URL.revokeObjectURL(img.src); // Revoke early

                             let captureThisFrame = false;
                             if (!previousImageData) { captureThisFrame = true; }
                             else if (currentImageData) {
                                 if (smartAlgorithm === "histogram") {
                                     const currentHist = computeHistogram(currentImageData, sampleFactor);
                                     if (!previousHist || histogramDifference(currentHist, previousHist) >= histThreshold) { captureThisFrame = true; }
                                     previousHist = currentHist; // Update regardless
                                 } else if (smartAlgorithm === "pixeldiff") {
                                     const diff = computePixelDiff(currentImageData.data, previousPixelData, sampleFactor);
                                     if (diff >= pixelThreshold) { captureThisFrame = true; }
                                 } else if (smartAlgorithm === "ssim") {
                                     const ssimValue = computeSSIM(previousImageData, currentImageData, sampleFactor);
                                     if (ssimValue < ssimThreshold) { captureThisFrame = true; }
                                 }
                             }

                             if (captureThisFrame) {
                                 const blobData = { blob, timestamp }; screenshotBlobs.push(blobData);
                                 const container = createScreenshotElement(blob, timestamp, screenshotBlobs);
                                 if(container && screenshotsDiv) screenshotsDiv.appendChild(container); updateImageCount();
                                 previousImageData = currentImageData; // Update reference for next comparison
                                 if (smartAlgorithm === 'pixeldiff' && currentImageData) previousPixelData = currentImageData.data.slice(); // Update pixel data only for pixel diff
                                 if (smartAlgorithm === 'histogram' && !previousHist && currentImageData) previousHist = computeHistogram(currentImageData, sampleFactor); // Ensure hist is set on first capture
                             } else {
                                 // Only update previous data if NOT capturing to avoid comparing identical frames consecutively in some modes
                                 // previousImageData = currentImageData; // Don't always update
                                 // if (smartAlgorithm === 'pixeldiff' && currentImageData) previousPixelData = currentImageData.data.slice(); // Don't always update
                             }

                             if (!cancelExtractionRequested) { currentTime += smartInterval; const progress = Math.min((currentTime / totalDuration) * 100, 100); if(progressBarFillSmart) progressBarFillSmart.style.width = `${progress}%`; currentAnimationFrameId = requestAnimationFrame(processNextSmartFrame); }
                             else { resetProcessingUI('autoSmart'); }

                        } catch (error) { console.error("[Process Smart] Error during image data processing:", error); URL.revokeObjectURL(img.src); if(!cancelExtractionRequested){ currentTime += smartInterval; const progress = Math.min((currentTime / totalDuration) * 100, 100); if(progressBarFillSmart) progressBarFillSmart.style.width = `${progress}%`; currentAnimationFrameId = requestAnimationFrame(processNextSmartFrame); } else {resetProcessingUI('autoSmart');} }
                     };
                     img.onerror = () => { console.error("[Process Smart] Failed to load blob into image."); URL.revokeObjectURL(img.src); if(!cancelExtractionRequested){ currentTime += smartInterval; const progress = Math.min((currentTime / totalDuration) * 100, 100); if(progressBarFillSmart) progressBarFillSmart.style.width = `${progress}%`; currentAnimationFrameId = requestAnimationFrame(processNextSmartFrame); } else {resetProcessingUI('autoSmart');} }
                     img.src = URL.createObjectURL(blob); // Create URL here
                 });
             }
             currentAnimationFrameId = requestAnimationFrame(processNextSmartFrame);
        };


        if(processButton) processButton.addEventListener('click', startAutoExtraction);
        if(processSmartButton) processSmartButton.addEventListener('click', startSmartExtraction);

        // Manual Mode Listeners
        if (extractManualButton) extractManualButton.addEventListener('click', () => {
            if (!manualVideo?.src || manualVideo.readyState < 1 || processingActive || !canvas) return;
            try {
                const { type, quality } = getCurrentFormatSettings(); // Use current settings
                const ctx = canvas.getContext('2d');
                if(!ctx) throw new Error("Canvas context not available");

                if (removeBarsEnabled && cropData && cropData.cropWidth > 0 && cropData.cropHeight > 0) {
                    canvas.width = cropData.cropWidth; canvas.height = cropData.cropHeight;
                    ctx.drawImage(manualVideo, cropData.cropX, cropData.cropY, cropData.cropWidth, cropData.cropHeight, 0, 0, cropData.cropWidth, cropData.cropHeight);
                } else {
                    canvas.width = manualVideo.videoWidth; canvas.height = manualVideo.videoHeight;
                     if (canvas.width === 0 || canvas.height === 0) throw new Error("Video dimensions are zero for manual extract.");
                    ctx.drawImage(manualVideo, 0, 0, canvas.width, canvas.height);
                }

                canvas.toBlob((blob) => {
                    if (blob) {
                        const tempLink = document.createElement('a');
                        const url = URL.createObjectURL(blob);
                        tempLink.href = url;
                        const extension = type.split('/')[1] === 'jpeg' ? 'jpg' : type.split('/')[1];
                        tempLink.download = `quick_frame_${formatTime(manualVideo.currentTime).replace(':','-')}.${extension}`;
                        document.body.appendChild(tempLink); tempLink.click(); document.body.removeChild(tempLink); URL.revokeObjectURL(url);
                    }
                }, type, quality);
            } catch(error) { console.error("[Manual Quick Save] Error:", error); alert("An error occurred during Quick Save."); }
        });

        if (addManualButton) addManualButton.addEventListener('click', () => {
            if (!manualVideo?.src || manualVideo.readyState < 1 || processingActive || !canvas) return;
            try {
                const { type, quality } = getCurrentFormatSettings(); // Use current settings
                const ctx = canvas.getContext('2d');
                if(!ctx) throw new Error("Canvas context not available");

                if (removeBarsEnabled && cropData && cropData.cropWidth > 0 && cropData.cropHeight > 0) {
                    canvas.width = cropData.cropWidth; canvas.height = cropData.cropHeight;
                    ctx.drawImage(manualVideo, cropData.cropX, cropData.cropY, cropData.cropWidth, cropData.cropHeight, 0, 0, cropData.cropWidth, cropData.cropHeight);
                } else {
                    canvas.width = manualVideo.videoWidth; canvas.height = manualVideo.videoHeight;
                     if (canvas.width === 0 || canvas.height === 0) throw new Error("Video dimensions are zero for manual add.");
                    ctx.drawImage(manualVideo, 0, 0, canvas.width, canvas.height);
                }

                const timestamp = manualVideo.currentTime;
                canvas.toBlob((blob) => {
                    if (blob) {
                        const blobData = { blob, timestamp }; manualScreenshotBlobs.push(blobData);
                        const container = createScreenshotElement(blob, timestamp, manualScreenshotBlobs);
                        if(container && screenshotsDiv) screenshotsDiv.appendChild(container); updateImageCount();
                    }
                }, type, quality);
            } catch(error) { console.error("[Manual Add] Error:", error); alert("An error occurred while adding the frame."); }
        });

        // Download & Clear Listeners
        if(downloadAllButton) downloadAllButton.addEventListener('click', () => { if (!processingActive) downloadBlobsAsZip(screenshotBlobs, "auto_screenshots"); });
        if(downloadAllSmartButton) downloadAllSmartButton.addEventListener('click', () => { if (!processingActive) downloadBlobsAsZip(screenshotBlobs, "smart_screenshots"); });
        if(downloadManualButton) downloadManualButton.addEventListener('click', () => { if (!processingActive) downloadBlobsAsZip(manualScreenshotBlobs, "manual_screenshots"); });
        if (clearScreenshotsButton) clearScreenshotsButton.addEventListener('click', () => { if (processingActive) return; if (screenshotsDiv && (screenshotBlobs.length > 0 || manualScreenshotBlobs.length > 0)) { if (confirm("Are you sure you want to remove all generated screenshots?")) { screenshotsDiv.querySelectorAll('.screenshot-container').forEach(container => { if (container.dataset.blobUrl) URL.revokeObjectURL(container.dataset.blobUrl); }); screenshotsDiv.innerHTML = ''; screenshotBlobs = []; manualScreenshotBlobs = []; updateImageCount(); } } });

        // --- Final Initial Setup ---
        currentMode = document.querySelector('.mode-tab.active')?.getAttribute('data-mode') || 'auto';
        // currentFormat is now determined dynamically by getCurrentFormatSettings
        smartAlgorithm = document.querySelector('.smart-tab.active')?.getAttribute('data-algo') || 'histogram';

        // Initial setup of sliders background for the default active mode
        document.querySelectorAll(`#${currentMode}Mode input[type="range"]`).forEach(updateSliderBackground);

        resetProcessingUI('all');
        updateDropZoneUI(false, "Drag & drop video file or");
        updateImageCount();

        console.log("Initial setup complete.");

      } catch (error) {
          console.error("Error during script execution:", error);
          // Provide more user-friendly error feedback
          const errorDisplay = document.createElement('div');
          errorDisplay.textContent = `Initialization Error: ${error.message}. Please refresh or check console (F12).`;
          errorDisplay.style.color = 'var(--danger-color)';
          errorDisplay.style.padding = '1rem';
          errorDisplay.style.backgroundColor = 'var(--bg-secondary)';
          errorDisplay.style.border = '1px solid var(--danger-color)';
          errorDisplay.style.margin = '1rem';
          document.body.prepend(errorDisplay); // Add error message to top of body
      }
    }); // End DOMContentLoaded
  </script>

</body>
</html>