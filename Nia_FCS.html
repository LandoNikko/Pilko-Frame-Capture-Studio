<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Frame Capture Studio</title>
  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Doto&family=Inter:wght@400;500;600&family=Source+Code+Pro:wght@400&display=swap" rel="stylesheet">
  <!-- JSZip -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    :root {
      /* --- Dark Theme: Deep Ocean (Compact Version) --- */
      --bg-primary: #0a0f1f;
      --bg-secondary: #161d31;
      --bg-tertiary: #242c44;
      --text-primary: #e0e6f7;
      --text-secondary: #8a94b6;
      --border-color: #3a4466;
      --border-dashed: #525c8f;

      /* Accents */
      --accent-primary: #00c6ff;
      --accent-primary-dark: #00a5d9;
      --accent-secondary: #2dd4bf;
      --accent-secondary-dark: #14b8a6;
      --accent-tertiary: #ff6ac1;   /* Used for Contact Sheet mode */
      --accent-tertiary-dark: #f53aab;
      --danger-color: #f43f5e;
      --danger-color-dark: #e11d48;

      /* Gradients */
      --gradient-primary: linear-gradient(90deg, var(--accent-primary), #00a8ff);
      --gradient-secondary: linear-gradient(90deg, var(--accent-secondary), #5eead4);
      --gradient-tertiary: linear-gradient(90deg, var(--accent-tertiary), #ff8cdc);
      --gradient-danger: linear-gradient(90deg, var(--danger-color), #fb7185);
      --gradient-disabled: linear-gradient(90deg, var(--bg-tertiary), #2f3958);

      /* Base Styles */
      --white: #ffffff;
      --black: #000000;
      --glitch-cyan: rgba(0, 255, 255, 0.7);
      --glitch-magenta: rgba(255, 0, 255, 0.7);

      /* Layout & Sizing (Compact) */
      --border-radius-sm: 3px;
      --border-radius-md: 6px;
      --border-radius-lg: 10px;
      --border-radius-full: 9999px;
      --content-padding: 1.25rem;
      --settings-column-width: 460px;
      --scrollbar-width: 8px;
      --separator-width: 2px;
    }

    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    body { background-color: var(--bg-primary); color: var(--text-primary); font-family: 'Inter', "Helvetica Neue", Arial, sans-serif; line-height: 1.5; font-size: 15px; min-height: 100vh; display: flex; overflow: hidden; }
    html, body { margin: 0; padding: 0; width: 100%; height: 100%; }

    /* Scrollbar Styling */
    ::-webkit-scrollbar { width: var(--scrollbar-width); height: var(--scrollbar-width); }
    ::-webkit-scrollbar-track { background: var(--bg-secondary); border-radius: var(--border-radius-full); }
    ::-webkit-scrollbar-thumb { background-color: var(--bg-tertiary); border-radius: var(--border-radius-full); border: 1px solid var(--bg-secondary); }
    ::-webkit-scrollbar-thumb:hover { background-color: var(--border-color); }
    * { scrollbar-width: thin; scrollbar-color: var(--bg-tertiary) var(--bg-secondary); }

    /* Layout */
    .app-container { flex: 1; display: flex; position: relative; width: 100%; height: 100%; overflow: hidden; }
    .vertical-separator { position: absolute; top: 0; bottom: 0; left: var(--settings-column-width); width: var(--separator-width); background-image: linear-gradient(to bottom, var(--border-dashed) 60%, transparent 40%); background-size: 100% 8px; background-repeat: repeat-y; z-index: 10; pointer-events: none; transition: background-image 0.3s ease; }
    .vertical-separator.loading { background-image: linear-gradient(to bottom, var(--accent-primary) 60%, transparent 40%); background-size: 100% 12px; animation: loadingAnimation 10s linear infinite; }
    .vertical-separator.loading-smart { background-image: linear-gradient(to bottom, var(--accent-secondary) 60%, transparent 40%); background-size: 100% 12px; animation: loadingAnimation 10s linear infinite; }
    .vertical-separator.loading-contact-sheet { background-image: linear-gradient(to bottom, var(--accent-tertiary) 60%, transparent 40%); background-size: 100% 12px; animation: loadingAnimation 8s linear infinite; }
    @keyframes loadingAnimation { 0% { background-position: 0 100vh; } 100% { background-position: 0 0; } }

    /* Settings Column */
    .settings-column { flex: 0 0 var(--settings-column-width); position: relative; height: 100%; overflow-y: auto; overflow-x: hidden; direction: rtl; background-color: var(--bg-secondary); padding: 0; border-right: 1px solid var(--border-color); }
    .settings-content-wrapper { direction: ltr; width: 100%; padding: var(--content-padding); display: flex; flex-direction: column; height: 100%; }

    /* Output Column */
    .output-column { flex: 1; display: flex; flex-direction: column; background-color: var(--bg-primary); overflow-y: auto; padding: var(--content-padding); }
    #screenshots { display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 0.8rem; align-content: start; }

    /* Hide screenshot grid when contact sheet preview is shown */
    .output-column.show-contact-sheet #screenshots { display: none; }
    .output-column:not(.show-contact-sheet) #contactSheetPreview { display: none; }


    /* H1 */
    h1 { font-family: 'Doto', sans-serif; text-align: center; padding-bottom: 1rem; margin-bottom: 1.25rem; font-weight: 400; font-size: 2em; color: var(--white); position: relative; cursor: pointer; user-select: none; transition: color 0.3s ease; border-bottom: 1px solid var(--border-color); flex-shrink: 0; }
    h1::before, h1::after { content: attr(data-text); position: absolute; top: 0; left: 0; right: 0; padding-bottom: 1rem; overflow: hidden; color: var(--white); background: var(--bg-secondary); transition: transform 0.05s ease-in-out, color 0.1s ease; opacity: 0; }
    h1:hover::before { color: var(--glitch-magenta); transform: translate(-2px, -1px) skewX(-5deg); opacity: 1; animation: glitchAnim 0.8s infinite linear alternate-reverse; }
    h1:hover::after { color: var(--glitch-cyan); transform: translate(2px, 1px) skewX(5deg); opacity: 1; animation: glitchAnim 0.8s infinite linear alternate; }
    h1:active { transform: scale(0.98); }
    @keyframes glitchAnim { /* ... */ 0% { clip-path: polygon(0 0, 100% 0, 100% 45%, 0 45%); } 20% { clip-path: polygon(0 20%, 100% 20%, 100% 25%, 0 25%); } 40% { clip-path: polygon(0 60%, 100% 60%, 100% 70%, 0 70%); } 60% { clip-path: polygon(0 85%, 100% 85%, 100% 90%, 0 90%); } 80% { clip-path: polygon(0 40%, 100% 40%, 100% 55%, 0 55%); } 100% { clip-path: polygon(0 0, 100% 0, 100% 10%, 0 10%); } }

    /* Combined Drop Zone / File Info Area */
    #dropZone { border: 2px dashed var(--border-dashed); border-radius: var(--border-radius-lg); background: linear-gradient(145deg, var(--bg-tertiary), var(--bg-secondary)); cursor: pointer; transition: background 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease, padding 0.3s ease; margin-bottom: 1.5rem; box-shadow: 0 3px 8px rgba(0, 0, 0, 0.15); display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; padding: 1.5rem 1rem; flex-shrink: 0; }
    #dropZone:hover { border-color: var(--accent-primary); box-shadow: 0 5px 12px rgba(0, 198, 255, 0.15); }
    #dropZone #uploadIcon { margin-bottom: 0.75rem; color: var(--text-secondary); transition: color 0.3s ease, transform 0.3s ease; display: block; }
    #dropZone:hover #uploadIcon { color: var(--accent-primary); transform: scale(1.1); }
    #dropZone #uploadIcon svg { width: 44px; height: 44px; fill: currentColor; }
    #dropZone #dropZoneText { margin-bottom: 1rem; font-size: 0.95rem; color: var(--text-secondary); display: block; }
    #dropZone #loadedFileInfo { display: none; }
    #dropZone.file-loaded { padding: 1rem 1.25rem 0.75rem; align-items: stretch; text-align: left; justify-content: flex-start; cursor: default; }
    #dropZone.file-loaded #uploadIcon, #dropZone.file-loaded #dropZoneText { display: none; }
    #dropZone.file-loaded #loadedFileInfo { display: block; width: 100%; }
    #loadedFileName { font-size: 0.95rem; font-weight: 500; color: var(--text-primary); margin-bottom: 0.75rem; display: flex; align-items: center; word-break: break-all; }
    #loadedFileName::before { content: 'âœ“'; color: var(--accent-secondary); font-size: 1.2em; margin-right: 0.5rem; font-weight: bold; }
    #loadedFileStats { font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 1rem; }
    #loadedFileStats .info-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.5rem; white-space: nowrap; }
    #loadedFileStats .info-row:last-child { margin-bottom: 0; }
    #loadedFileStats .info-label { font-weight: 500; color: var(--text-primary); margin-right: 1rem; }
    #loadedFileStats .info-value { font-family: 'Source Code Pro', monospace; text-align: right; color: var(--accent-primary); font-weight: 500; font-size: 0.9rem; }
    #loadedFileStats .leader { display: none; }
    #selectFileButton { padding: 0.6rem 1.5rem; font-size: 0.9rem; background-color: rgba(255, 255, 255, 0.05); border: 1px solid var(--border-color); border-radius: var(--border-radius-md); color: var(--text-primary); cursor: pointer; transition: background-color 0.2s, border-color 0.2s, color 0.2s, box-shadow 0.2s; font-weight: 500; width: fit-content; align-self: center; }
    #dropZone.file-loaded #selectFileButton { margin-top: auto; align-self: flex-end; background-color: transparent; border: 1px solid var(--accent-secondary); color: var(--accent-secondary); }
    #dropZone.file-loaded #selectFileButton:hover { background-color: rgba(45, 212, 191, 0.1); }
    #dropZone:not(.file-loaded):hover #selectFileButton { background-color: rgba(255, 255, 255, 0.1); border-color: var(--text-secondary); box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1); }
    #videoInput { display: none; }

    /* Image Count Display */
    #imageCountDisplay { text-align: center; font-size: 0.9rem; color: var(--text-secondary); margin-top: 1.5rem; margin-bottom: 0.75rem; padding: 0.4rem 0; background-color: var(--bg-tertiary); border-radius: var(--border-radius-md); border: 1px solid var(--border-color); flex-shrink: 0; }
    #imageCountDisplay span { font-weight: 600; color: var(--accent-primary); font-family: 'Source Code Pro', monospace; margin-left: 0.5ch; }

    /* Black Bars Toggle */
    .toggle-row { display: flex; align-items: center; margin-bottom: 1.25rem; background-color: var(--bg-tertiary); padding: 0.8rem 1rem; border-radius: var(--border-radius-md); border: 1px solid var(--border-color); flex-shrink: 0; }
    .toggle-label { flex: 1; font-size: 0.9rem; color: var(--text-primary); font-weight: 500; margin-right: 0.8rem; }
    .toggle-switch { position: relative; display: inline-block; width: 48px; height: 24px; flex-shrink: 0; }
    .toggle-input { opacity: 0; width: 0; height: 0; }
    .toggle-label-switch { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--bg-primary); transition: .3s; border-radius: 24px; border: 1px solid var(--border-color); }
    .toggle-label-switch:before { position: absolute; content: ""; height: 18px; width: 18px; left: 2px; bottom: 2px; background-color: var(--text-secondary); transition: .3s; border-radius: 50%; box-shadow: 0 1px 2px rgba(0,0,0,0.15); }
    .toggle-input:checked + .toggle-label-switch { background: var(--gradient-primary); border-color: transparent; }
    .toggle-input:checked + .toggle-label-switch:before { transform: translateX(24px); background-color: var(--white); }

    /* Tabs */
    .segmented-controls { display: flex; border-radius: var(--border-radius-md); overflow: hidden; background-color: var(--bg-tertiary); margin-bottom: 1.25rem; border: 1px solid var(--border-color); flex-shrink: 0; }
    .segmented-controls button { flex: 1; background-color: transparent; text-align: center; border: none; padding: 0.65rem 0.5rem; color: var(--text-secondary); cursor: pointer; transition: background 0.2s, color 0.3s, box-shadow 0.2s; font-family: inherit; font-size: 0.85rem; font-weight: 500; border-left: 1px solid var(--border-color); position: relative; white-space: nowrap; }
    .segmented-controls button:first-child { border-left: none; }
    .segmented-controls button:hover:not(.active) { background-color: var(--border-color); color: var(--text-primary); }
    .mode-tabs button[data-mode="auto"].active { background: var(--gradient-primary); }
    .mode-tabs button[data-mode="autoSmart"].active { background: var(--gradient-secondary); }
    .mode-tabs button[data-mode="manual"].active { background: var(--gradient-primary); }
    .mode-tabs button[data-mode="contactSheet"].active { background: var(--gradient-tertiary); }
    .mode-tabs button.active { color: var(--bg-primary); font-weight: 600; box-shadow: inset 0 1px 3px rgba(0,0,0,0.2); }
    .format-tabs button.active { background: var(--gradient-primary); color: var(--bg-primary); font-weight: 600; box-shadow: inset 0 1px 2px rgba(0,0,0,0.15); }
    .smart-algo-tabs button.active { background: var(--gradient-secondary); color: var(--bg-primary); font-weight: 600; box-shadow: inset 0 1px 2px rgba(0,0,0,0.15); }
    .grid-size-tabs button.active { background: var(--gradient-tertiary); color: var(--bg-primary); font-weight: 600; box-shadow: inset 0 1px 2px rgba(0,0,0,0.15); }
    .grid-size-tabs button { 
        position: relative; 
        padding-right: 24px; /* Ensure space for the checkmark */
    }
    .grid-size-tabs button.completed::after { 
        content: "âœ“"; 
        position: absolute;
        right: 8px;
        top: 50%;
        transform: translateY(-50%);
        font-weight: bold;
        color: var(--accent-tertiary);
    }
    .grid-size-tabs button.active.completed::after { 
        color: var(--bg-primary);
    }
    .format-tabs, .smart-algo-tabs, .grid-size-tabs { margin-bottom: 0.8rem; }
    .format-tabs button, .smart-algo-tabs button, .grid-size-tabs button { padding: 0.5rem 0.5rem; font-size: 0.8rem; }

    /* Mode Containers */
    .mode-content { flex-grow: 1; overflow-y: auto; /* Allow scrolling within the mode content area */ padding-right: 5px; /* Space for scrollbar */}
    .mode-content > div { display: none; }
    .mode-content > div.active { display: block; }

    /* Sliders */
    .slider-row { display: flex; align-items: center; gap: 1rem; margin-bottom: 1rem; flex-wrap: wrap; }
    .slider-label { width: 100px; text-align: left; font-size: 0.85rem; color: var(--text-secondary); flex-shrink: 0; }
    .slider-wrapper { flex: 1; display: flex; align-items: center; gap: 0.8rem; min-width: 150px; }
    .value-display { font-weight: 500; min-width: 40px; text-align: right; font-family: 'Source Code Pro', monospace; color: var(--text-primary); font-size: 0.9rem; }
    input[type="range"] { /* ... */ -webkit-appearance: none; -moz-appearance: none; appearance: none; width: 100%; height: 6px; background: var(--bg-tertiary); border-radius: var(--border-radius-full); outline: none; cursor: pointer; transition: background 0.2s; }
    input[type="range"]::-webkit-slider-thumb { /* ... */ -webkit-appearance: none; width: 18px; height: 18px; border-radius: 50%; background: var(--white); border: none; box-shadow: 0 1px 4px rgba(0, 0, 0, 0.25); transition: transform 0.1s ease-out; }
    input[type="range"]::-moz-range-thumb { /* ... */ width: 18px; height: 18px; border-radius: 50%; background: var(--white); border: none; box-shadow: 0 1px 4px rgba(0, 0, 0, 0.25); transition: transform 0.1s ease-out; }
    input[type="range"]:active::-webkit-slider-thumb, input[type="range"]:active::-moz-range-thumb { transform: scale(1.1); }
    input[type="range"]:focus-visible { outline: 2px solid var(--accent-primary); outline-offset: 2px; }

    /* Notes & Buttons */
    #pngNote, #pngNoteSmart { font-size: 0.8rem; color: var(--text-secondary); text-align: center; width: 100%; min-height: 30px; display: flex; align-items: center; justify-content: center; margin-bottom: 0.8rem; background-color: rgba(36, 44, 68, 0.5); border-radius: var(--border-radius-sm); padding: 0.2rem 0.4rem; }
    .button-group { display: flex; flex-direction: column; gap: 0.75rem; margin-top: 1rem; }
    .action-button { width: 100%; padding: 0.75rem 1.5rem; font-size: 0.95rem; border: none; border-radius: var(--border-radius-md); color: var(--bg-primary); cursor: pointer; transition: background 0.3s ease, opacity 0.2s, color 0.2s, box-shadow 0.2s ease; text-align: center; font-weight: 600; background-size: 200% auto; box-shadow: 0 3px 5px rgba(0, 0, 0, 0.1); }
    .action-button:hover:enabled { box-shadow: 0 5px 10px rgba(0, 0, 0, 0.15); background-position: right center; }
    .action-button:active:enabled { transform: scale(0.98); box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); }
    .action-button:disabled { opacity: 0.5; cursor: not-allowed; box-shadow: none; background: var(--gradient-disabled); color: var(--text-secondary); }
    #processButton { background: var(--gradient-primary); }
    #processSmartButton { background: var(--gradient-secondary); }
    #processContactSheetButton { background: var(--gradient-tertiary); }
    #processButton.cancel-active, #processSmartButton.cancel-active, #processContactSheetButton.cancel-active { background: var(--gradient-danger); color: var(--white); }
    #processButton.cancel-active:hover:enabled, #processSmartButton.cancel-active:hover:enabled, #processContactSheetButton.cancel-active:hover:enabled { background: var(--gradient-danger); filter: brightness(1.1); }
    #downloadAllButton, #downloadAllSmartButton, #downloadManualButton, #downloadContactSheetButton { background: transparent; border: 1px solid var(--accent-tertiary); color: var(--accent-tertiary); padding: calc(0.75rem - 1px) calc(1.5rem - 1px); box-shadow: none; }
    #downloadAllButton { border-color: var(--accent-primary); color: var(--accent-primary); }
    #downloadAllButton:hover:enabled { background-color: rgba(0, 198, 255, 0.1); border-color: var(--accent-primary-dark); color: var(--accent-primary-dark); }
    #downloadAllSmartButton { border-color: var(--accent-secondary); color: var(--accent-secondary); }
    #downloadAllSmartButton:hover:enabled { background-color: rgba(45, 212, 191, 0.1); border-color: var(--accent-secondary-dark); color: var(--accent-secondary-dark); }
    #downloadManualButton { border-color: var(--accent-primary); color: var(--accent-primary); }
    #downloadManualButton:hover:enabled { background-color: rgba(0, 198, 255, 0.1); border-color: var(--accent-primary-dark); color: var(--accent-primary-dark); }
    #downloadContactSheetButton { border-color: var(--accent-tertiary); color: var(--accent-tertiary); }
    #downloadContactSheetButton:hover:enabled { background-color: rgba(255, 106, 193, 0.1); border-color: var(--accent-tertiary-dark); color: var(--accent-tertiary-dark); box-shadow: none; }
     #downloadAllButton:disabled, #downloadAllSmartButton:disabled, #downloadManualButton:disabled, #downloadContactSheetButton:disabled { background: transparent; border-color: var(--border-color); color: var(--text-secondary); opacity: 0.5; box-shadow: none; }

    #clearScreenshotsButton { margin-top: 1rem; padding: 0.6rem 1.2rem; font-size: 0.85rem; background-color: transparent; border: 1px solid var(--border-dashed); color: var(--text-secondary); border-radius: var(--border-radius-md); cursor: pointer; transition: background-color 0.2s, color 0.2s, border-color 0.2s, box-shadow 0.2s; width: 100%; font-weight: 500; flex-shrink: 0; }
    #clearScreenshotsButton:hover:enabled { background-color: rgba(244, 63, 94, 0.1); color: var(--danger-color); border-color: var(--danger-color); box-shadow: 0 1px 4px rgba(244, 63, 94, 0.1); }
    #clearScreenshotsButton:disabled { opacity: 0.4; cursor: not-allowed; box-shadow: none; }

    /* Manual Mode */
    #manualVideo { width: 100%; border-radius: var(--border-radius-lg); background-color: var(--black); margin-bottom: 1rem; aspect-ratio: 16 / 9; border: 1px solid var(--border-color); }
    .manual-buttons { display: flex; gap: 0.75rem; align-items: center; flex-wrap: wrap; }
    #extractManualButton { flex: 1 1 auto; padding: 0.65rem 1.1rem; font-size: 0.85rem; background-color: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: var(--border-radius-md); color: var(--text-primary); cursor: pointer; transition: background-color 0.2s, border-color 0.2s, box-shadow 0.2s; font-weight: 500; min-width: 110px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
    #extractManualButton:hover { background-color: var(--border-color); border-color: var(--text-secondary); box-shadow: 0 2px 5px rgba(0,0,0,0.15); }
    #addManualButton { width: 42px; height: 42px; background: var(--gradient-primary); border: none; border-radius: 50%; color: var(--bg-primary); font-size: 1.8rem; line-height: 1; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: background 0.3s ease, transform 0.1s, box-shadow 0.2s; flex-shrink: 0; box-shadow: 0 3px 6px rgba(0, 198, 255, 0.15); }
    #addManualButton:hover { background-position: right center; box-shadow: 0 5px 10px rgba(0, 198, 255, 0.25); }
    #addManualButton:active { transform: scale(0.95); box-shadow: 0 2px 4px rgba(0, 198, 255, 0.15); }

    /* Progress Bars */
    .progress-bar-container { width: 100%; height: 8px; background-color: var(--bg-tertiary); border-radius: var(--border-radius-full); overflow: hidden; margin-top: 0.8rem; display: none; border: 1px solid var(--border-color); }
    .progress-bar-fill { height: 100%; width: 0%; border-radius: var(--border-radius-full); transition: width 0.3s ease-out; }
    #progressBarAuto .progress-bar-fill { background: var(--gradient-primary); }
    #progressBarSmart .progress-bar-fill { background: var(--gradient-secondary); }
    #progressBarContactSheet .progress-bar-fill { background: var(--gradient-tertiary); }

    /* Screenshots Grid Item */
    .screenshot-container { position: relative; overflow: hidden; border-radius: var(--border-radius-md); border: 1px solid var(--border-color); background-color: var(--bg-secondary); transition: box-shadow 0.3s ease, border-color 0.3s ease; }
    .screenshot-container:hover { box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3); border-color: var(--accent-primary); }
    .screenshot-container a { display: block; line-height: 0; }
    .screenshot-container img { display: block; width: 100%; height: auto; object-fit: cover; border-radius: var(--border-radius-md); animation: fadeIn 0.5s ease-in-out; }
    .screenshot-overlay, .delete-btn { position: absolute; opacity: 0; transition: opacity 0.2s ease-in-out; pointer-events: none; }
    .screenshot-container:hover .screenshot-overlay, .screenshot-container:hover .delete-btn { opacity: 1; pointer-events: auto; }
    .screenshot-overlay { left: 0; bottom: 0; right: 0; background: linear-gradient(to top, rgba(10, 15, 31, 0.9), transparent); color: var(--white); font-size: 0.75rem; padding: 0.8rem 0.5rem 0.3rem; text-align: right; font-family: 'Source Code Pro', monospace; }
    .delete-btn { top: 6px; right: 6px; background: rgba(244, 63, 94, 0.7); border: none; color: var(--white); font-size: 0.9rem; width: 24px; height: 24px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; line-height: 1; backdrop-filter: blur(2px); transition: background-color 0.2s ease; }
    .delete-btn:hover { background: var(--danger-color); }
    @keyframes fadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }

    /* Hidden Elements */
    #video, #canvas, #contactSheetCanvas { display: none; }
    #frameCanvas { display: none; }

    /* Contact Sheet Mode Specific */
    #contactSheetMode p { color: var(--text-secondary); font-size: 0.9rem; margin-bottom: 1rem; background-color: rgba(36, 44, 68, 0.5); border-radius: var(--border-radius-sm); padding: 0.5rem 0.8rem; }
    #contactSheetVideo { width: 100%; border-radius: var(--border-radius-lg); background-color: var(--black); margin-bottom: 1rem; aspect-ratio: 16 / 9; border: 1px solid var(--border-color); }
    .fine-tune-message { color: var(--accent-tertiary); font-size: 0.85rem; margin: 0.5rem 0 1rem; text-align: center; display: none; }
    .contact-sheet-controls { display: none; /* Hidden by default */ grid-template-columns: repeat(5, 1fr); gap: 0.75rem; margin-bottom: 1rem; }
    .time-input-container { display: flex; flex-direction: column; gap: 0.3rem; position: relative; }
    .time-input-wrapper {
        position: relative;
        display: inline-block;
        width: 100%;
        height: 2rem;
    }
    .time-input {
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        opacity: 0;
        z-index: 1;
        pointer-events: none;
    }
    .time-formatted {
        width: 100%;
        height: 100%;
        font-family: monospace;
        text-align: center;
        position: relative;
        padding: 0.4rem;
        border-radius: var(--border-radius-sm);
        border: 1px solid var(--border-color);
        background-color: var(--input-bg);
        color: var(--text-color);
        box-sizing: border-box;
        cursor: ns-resize; /* Show up/down cursor to indicate draggable */
        user-select: none; /* Prevent text selection during drag */
        transition: background-color 0.15s ease;
    }
    .time-formatted:hover {
        background-color: var(--bg-tertiary);
        border-color: var(--accent-primary);
    }
    .time-formatted:focus {
        outline: none;
        border-color: var(--primary-color);
    }
    .time-formatted::after {
        content: "â†•";
        position: absolute;
        right: 0.5rem;
        top: 50%;
        transform: translateY(-50%);
        color: var(--text-secondary);
        font-size: 0.9rem;
        opacity: 0.6;
    }
    .time-formatted:hover::after {
        opacity: 1;
        color: var(--accent-primary);
    }

    /* Contact Sheet Preview Grid */
    #contactSheetPreview { 
        width: 100%;
        margin: 0 auto;
        display: grid;
        grid-template: repeat(var(--grid-rows, 4), 1fr) / repeat(var(--grid-cols, 5), 1fr);
        gap: 2px;
        overflow: hidden;
        background-color: var(--border-color);
        border: 1px solid var(--border-color);
        border-radius: var(--border-radius-md);
    }
    .grid-cell { 
        background-color: var(--bg-secondary); 
        position: relative; 
        overflow: hidden;
        border: none;
        display: flex;
        width: 100%;
        height: 100%;
        align-items: center; 
        justify-content: center;
    }
    .grid-cell.filled {
        cursor: pointer;
    }
    .grid-cell img { 
        max-width: 100%; 
        min-width: none;
        max-height: 100%; 
        min-height: max-content;
        object-fit: contain;
        display: block; 
        opacity: 0; 
        transition: opacity 0.3s ease; 
    }
    .grid-cell.filled img { 
        opacity: 1; 
        animation: fadeIn 0.3s ease-in-out;
    }
    .grid-cell .screenshot-overlay { 
        opacity: 0; 
        transition: opacity 0.2s ease-in-out; 
        pointer-events: none; 
        position: absolute; 
        left: 0; 
        bottom: 0; 
        right: 0; 
        background: linear-gradient(to top, rgba(10, 15, 31, 0.8), transparent); 
        color: var(--white); 
        font-size: 0.7rem; 
        padding: 0.6rem 0.4rem 0.2rem; 
        text-align: right; 
        font-family: 'Source Code Pro', monospace; 
    }
    .grid-cell:hover .screenshot-overlay { opacity: 1; pointer-events: auto; }
    .contact-sheet-label { color: var(--accent-tertiary); font-size: 0.9rem; font-weight: 500; margin: 1rem 0 0.5rem; text-align: center; width: 100%; }


    /* Responsive */
    @media (max-width: 800px) {
        body { overflow-y: auto; height: auto; }
        .app-container { flex-direction: column; height: auto; overflow: visible; }
        .vertical-separator { display: none; }
        .settings-column { flex-basis: auto; width: 100%; height: auto; max-height: none; border-right: none; overflow-y: visible; padding: 0; direction: ltr; background-color: var(--bg-secondary); border-bottom: 1px solid var(--border-color); margin-bottom: 0; }
        .settings-content-wrapper { direction: ltr; padding: var(--content-padding); height: auto; } /* Reset height */
        .output-column { width: 100%; overflow-y: visible; background-color: var(--bg-primary); padding: var(--content-padding); }
        #screenshots { padding: 0; } /* Remove padding if output col has it */
        h1 { margin-bottom: 1.25rem; border-bottom: 1px solid var(--border-color); }
        .mode-content { overflow: visible; } /* Allow content to determine height */
    }
    @media (max-width: 600px) {
        :root { --content-padding: 1rem; }
        body { font-size: 14px; }
        .settings-content-wrapper { padding: 1rem; }
        .output-column { padding: 1rem; }
        #screenshots { grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 0.5rem; }
        .slider-label { width: 80px; }
        h1 { font-size: 1.8em; }
        .action-button { font-size: 0.9rem; padding: 0.7rem 1.2rem; }
        #dropZone { padding: 1.25rem 0.8rem; }
        #dropZone.file-loaded { padding: 0.8rem 1rem 0.6rem; }
        #loadedFileStats { font-size: 0.8rem; }
        #loadedFileStats .info-value { font-size: 0.85rem; }
        .segmented-controls button { font-size: 0.75rem; padding: 0.5rem 0.3rem; } /* Further reduce padding */
        #contactSheetPreview { gap: 1px; }
        .contact-sheet-controls { grid-template-columns: repeat(3, 1fr); } /* Adjust layout for smaller screens */
        .time-input-wrapper { height: 1.8rem; }
        .time-input { font-size: 0.8rem; }
        .time-formatted { font-size: 0.8rem; padding: 0.3rem; padding-right: 1.5rem; }
    }

    /* Highlight styles for contact sheet cells and time inputs */
    .time-input-container .time-formatted {
        transition: border-color 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease;
    }
    .time-input-container.highlight .time-formatted {
        border-color: var(--accent-primary);
        box-shadow: 0 0 0 2px rgba(0, 198, 255, 0.3);
        background-color: rgba(0, 198, 255, 0.05);
    }
    .grid-cell {
        transition: outline 0.2s ease;
    }
    .grid-cell.highlight {
        outline: 2px solid var(--accent-primary);
        outline-offset: 1px;
        position: relative;
        z-index: 2;
    }
    .grid-cell.highlight img {
        opacity: 1;
    }
    /* Frame adjustment buttons */
    .frame-adjust-buttons {
        position: absolute;
        bottom: 8px;
        left: 8px;
        display: none;
        gap: 6px;
        z-index: 5;
        background: transparent;
        padding: 0;
        width: auto;
        justify-content: flex-start;
    }
    .grid-cell.highlight .frame-adjust-buttons {
        display: flex;
    }
    /* Make sure not to show buttons when hovering time inputs */
    .time-input-container.highlight ~ #contactSheetPreview .grid-cell.highlight .frame-adjust-buttons {
        display: none;
    }
    .frame-adjust-btn {
        width: 28px;
        height: 28px;
        border-radius: 4px;
        background-color: rgba(0, 0, 0, 0.75);
        color: white;
        border: 1px solid rgba(255, 255, 255, 0.6);
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        font-size: 16px;
        cursor: pointer;
        transition: background-color 0.15s ease, transform 0.15s ease;
        user-select: none;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.4);
    }
    .frame-adjust-btn:hover {
        background-color: var(--accent-primary);
        transform: scale(1.1);
    }
    .frame-adjust-btn:active {
        transform: scale(0.95);
        background-color: var(--primary-color);
    }

    #contactSheetMode .video-container, #contactSheetMode #contactSheetVideo {
        display: none; /* Hide video player in contact sheet mode */
    }

    /* Sticky Button Container */
    .sticky-button-container {
        position: sticky;
        bottom: 0;
        background-color: var(--bg-secondary);
        padding-top: 1rem;
        margin-top: auto;
        border-top: 1px solid var(--border-color);
        z-index: 10;
        display: flex;
        flex-direction: column;
    }
    
    .sticky-button-container .button-group {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        margin-bottom: 1rem;
    }
    
    .sticky-button-container .manual-buttons {
        display: flex;
        gap: 0.75rem;
        align-items: center;
        flex-wrap: wrap;
    }
    
    /* Status Row */
    .status-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0.5rem;
    }
    
    .status-row #clearScreenshotsButton {
        margin-top: 0;
        flex: 0 0 auto;
        width: auto;
        margin-right: 0.75rem;
    }
    
    .status-row #imageCountDisplay {
        flex: 1;
        margin-top: 0;
        margin-bottom: 0;
    }
    
    /* Show only the active progress bar */
    .sticky-button-container #progressBarAuto,
    .sticky-button-container #progressBarSmart,
    .sticky-button-container #progressBarContactSheet {
        margin-top: 0;
    }
    
    /* Progress Bar Wrapper - Maintains consistent height */
    .progress-bar-wrapper {
        height: 12px;
        margin-bottom: 0.75rem;
        position: relative;
    }
    
    .progress-bar-container {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 100%;
        background-color: var(--bg-tertiary);
        border-radius: var(--border-radius-sm);
        overflow: hidden;
    }
    
    .progress-bar-fill {
        height: 100%;
        width: 0%;
        background: var(--gradient-primary);
        border-radius: var(--border-radius-sm);
        transition: width 0.1s ease;
    }
    
    #progressBarSmart .progress-bar-fill {
        background: var(--gradient-secondary);
    }
    
    #progressBarContactSheet .progress-bar-fill {
        background: var(--gradient-tertiary);
    }

    .grid-size-title {
        font-size: 0.9rem;
        color: var(--text-primary);
        font-weight: 500;
        margin-bottom: 0.5rem;
        text-align: center;
    }
    
    /* Action Button Row for equal width buttons */
    .action-button-row {
        display: flex;
        gap: 0.75rem;
        width: 100%;
    }
    .action-button-row .action-button {
        flex: 1;
    }
    
    /* Secondary action buttons */
    .secondary-button {
        background: transparent;
        border: 1px solid var(--accent-tertiary);
        color: var(--accent-tertiary);
        padding: calc(0.75rem - 1px) calc(1.5rem - 1px);
        box-shadow: none;
    }
    .secondary-button:hover:enabled {
        background-color: rgba(255, 106, 193, 0.1);
        border-color: var(--accent-tertiary-dark);
        color: var(--accent-tertiary-dark);
        box-shadow: none;
    }
    
    #processButton { background: var(--gradient-primary); }
  </style>
</head>
<body>

  <div class="app-container">

    <div class="vertical-separator"></div>

    <div class="settings-column">
      <div class="settings-content-wrapper">
        <h1 id="pageTitle" data-text="Frame Capture Studio">Frame Capture Studio</h1>

        <div id="dropZone">
            <div id="uploadIcon"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM14 13v4h-4v-4H7l5-5 5 5h-3z"/></svg></div>
            <div id="dropZoneText">Drag & drop video file or</div>
            <div id="loadedFileInfo">
                <div id="loadedFileName">Filename goes here</div>
                <div id="loadedFileStats">
                    <div class="info-row"><div class="info-label">Resolution</div><div class="info-value" id="resolutionValue">-</div></div>
                    <div class="info-row"><div class="info-label">Duration</div><div class="info-value" id="lengthValue">-</div></div>
                    <div class="info-row"><div class="info-label">Aspect Ratio</div><div class="info-value" id="aspectRatioValue">-</div></div>
                    <div class="info-row"><div class="info-label">Bitrate</div><div class="info-value" id="bitrateValue">-</div></div>
                </div>
            </div>
            <button id="selectFileButton" type="button">Select File</button>
            <input type="file" id="videoInput" accept="video/*">
        </div>

        <div class="toggle-row"><div class="toggle-label">Remove Black Bars</div><div class="toggle-switch"><input type="checkbox" id="removeBarsToggle" class="toggle-input"><label for="removeBarsToggle" class="toggle-label-switch"></label></div></div>

        <div class="segmented-controls mode-tabs">
            <button class="mode-tab active" data-mode="auto">Interval</button>
            <button class="mode-tab" data-mode="autoSmart">Smart Auto</button>
            <button class="mode-tab" data-mode="manual">Manual</button>
            <button class="mode-tab" data-mode="contactSheet">Contact Sheet</button>
        </div>

        <div class="mode-content">
            <div id="autoMode" class="active">
              <div class="slider-row"><div class="slider-label">Interval</div><div class="slider-wrapper"><input type="range" id="intervalInput" min="1" max="30" value="10" step="1"><span id="intervalValue" class="value-display"></span></div></div>
              <div class="segmented-controls format-tabs"><button class="format-tab active" data-format="png">PNG</button><button class="format-tab" data-format="jpeg">JPEG</button><button class="format-tab" data-format="webp">WEBP</button></div>
              <div id="pngNote">Lossless quality, largest file size.</div>
              <div class="slider-row" id="jpegSettings" style="display:none;"><div class="slider-label">JPEG Quality</div><div class="slider-wrapper"><input type="range" id="jpegQuality" min="10" max="100" value="85" step="5"><span id="jpegQualityValue" class="value-display"></span></div></div>
              <div class="slider-row" id="webpSettings" style="display:none;"><div class="slider-label">WEBP Quality</div><div class="slider-wrapper"><input type="range" id="webpQuality" min="10" max="100" value="85" step="5"><span id="webpQualityValue" class="value-display"></span></div></div>
            </div>
            <div id="autoSmartMode">
               <div class="segmented-controls smart-algo-tabs"><button class="smart-tab active" data-algo="histogram">Histogram Diff</button><button class="smart-tab" data-algo="pixeldiff">Pixel Diff</button><button class="smart-tab" data-algo="ssim">Low SSIM</button></div>
               <div class="segmented-controls format-tabs" id="smartFormatTabs"><button class="format-tab active" data-format="png">PNG</button><button class="format-tab" data-format="jpeg">JPEG</button><button class="format-tab" data-format="webp">WEBP</button></div>
               <div id="pngNoteSmart">Lossless quality, largest file size.</div>
               <div class="slider-row" id="histThresholdSettings"><div class="slider-label">Hist Thresh</div><div class="slider-wrapper"><input type="range" id="histThresholdInput" min="0.05" max="0.75" value="0.35" step="0.05"><span id="histThresholdValue" class="value-display"></span></div></div>
               <div class="slider-row" id="pixelThresholdSettings" style="display:none;"><div class="slider-label">Pixel Thresh</div><div class="slider-wrapper"><input type="range" id="pixelThresholdInput" min="5" max="100" value="35" step="5"><span id="pixelThresholdValue" class="value-display"></span></div></div>
               <div class="slider-row" id="ssimThresholdSettings" style="display:none;"><div class="slider-label">SSIM Thresh</div><div class="slider-wrapper"><input type="range" id="ssimThresholdInput" min="0.5" max="0.99" value="0.90" step="0.01"><span id="ssimThresholdValue" class="value-display"></span></div></div>
               <div class="slider-row" id="jpegSettingsSmart" style="display:none;"><div class="slider-label">JPEG Quality</div><div class="slider-wrapper"><input type="range" id="jpegQualitySmart" min="10" max="100" value="85" step="5"><span id="jpegQualityValueSmart" class="value-display"></span></div></div>
               <div class="slider-row" id="webpSettingsSmart" style="display:none;"><div class="slider-label">WEBP Quality</div><div class="slider-wrapper"><input type="range" id="webpQualitySmart" min="10" max="100" value="85" step="5"><span id="webpQualityValueSmart" class="value-display"></span></div></div>
            </div>
            <div id="manualMode">
              <video id="manualVideo" controls></video>
            </div>
            <div id="contactSheetMode">
                <p>Generate a grid of screenshots. Choose a grid size and adjust times below to fine-tune.</p>
                <div class="grid-size-title">Grid Size:</div>
                <div class="segmented-controls grid-size-tabs">
                    <button class="grid-size-tab active" data-rows="4" data-cols="5">5Ã—4</button>
                    <button class="grid-size-tab" data-rows="3" data-cols="4">4Ã—3</button>
                    <button class="grid-size-tab" data-rows="2" data-cols="3">3Ã—2</button>
                </div>
                <div class="video-container">
                <video id="contactSheetVideo" controls></video>
                </div>
                <div id="fineTuneMessage" class="fine-tune-message">
                    Drag up/down on time values to adjust frames, or click to enter time manually.
                    Hover over thumbnails to use -/+ buttons for quick 1-second adjustments.
                    Click "Update Sheet Image" when finished.
                </div>
                <div class="contact-sheet-controls">
                    <!-- Inputs generated by JS -->
                </div>
            </div>
        </div>

        <div class="sticky-button-container">
            <!-- Auto Mode Buttons -->
            <div class="button-group" id="autoModeButtons">
                <button id="processButton" class="action-button">Extract Screenshots</button>
                <button id="downloadAllButton" class="action-button" disabled>Download All (.zip)</button>
            </div>
            
            <!-- Smart Auto Mode Buttons -->
            <div class="button-group" id="smartModeButtons" style="display:none;">
                <button id="processSmartButton" class="action-button">Extract Smart Shots</button>
                <button id="downloadAllSmartButton" class="action-button" disabled>Download All (.zip)</button>
            </div>
            
            <!-- Manual Mode Buttons -->
            <div class="button-group" id="manualModeButtons" style="display:none;">
                <div class="manual-buttons">
                    <button id="extractManualButton" type="button">Quick Save Frame</button>
                    <button id="downloadManualButton" type="button" disabled>Download Added</button>
                    <button id="addManualButton" title="Add current frame to download list" type="button">+</button>
                </div>
            </div>
            
            <!-- Contact Sheet Mode Buttons -->
            <div class="button-group" id="contactSheetModeButtons" style="display:none;">
                <button id="processContactSheetButton" class="action-button">Generate/Update Sheet</button>
                <div class="action-button-row">
                    <button id="previewContactSheetButton" class="action-button secondary-button" disabled>Preview Sheet Image</button>
                    <button id="downloadContactSheetButton" class="action-button secondary-button" disabled>Download Sheet Image</button>
                </div>
            </div>
            
            <!-- Progress Bars -->
            <div class="progress-bar-wrapper">
                <div id="progressBarAuto" class="progress-bar-container" style="display:none;"><div id="progressBarFillAuto" class="progress-bar-fill"></div></div>
                <div id="progressBarSmart" class="progress-bar-container" style="display:none;"><div id="progressBarFillSmart" class="progress-bar-fill"></div></div>
                <div id="progressBarContactSheet" class="progress-bar-container" style="display:none;"><div id="progressBarFillContactSheet" class="progress-bar-fill"></div></div>
            </div>
            
            <div class="status-row">
                <button id="clearScreenshotsButton" type="button" disabled>Clear Output</button>
                <div id="imageCountDisplay">Generated Images:<span id="imageCountValue">0</span></div>
            </div>
        </div>

      </div> <!-- End Settings Content Wrapper -->
    </div> <!-- End Settings Column -->

    <!-- Right Column: Output Area -->
    <div class="output-column" id="outputColumn">
      <div id="screenshots">
        <!-- Screenshot previews will be appended here -->
      </div>
      <!-- Contact Sheet Preview -->
      <div id="contactSheetPreview">
        <!-- Grid cells generated by JS -->
      </div>
    </div>

  </div> <!-- End App Container -->

  <!-- Hidden elements -->
  <video id="video" style="display:none;"></video>
  <canvas id="canvas"></canvas>
  <canvas id="frameCanvas" style="display:none;"></canvas>
  <canvas id="contactSheetCanvas" style="display:none;"></canvas>


  <script>
    'use strict';

    let verticalSeparatorElement = null;
    let cropData = null;
    let removeBarsEnabled = false;
    // Grid caches to store state for each grid size
    let gridCache = {
      '5x4': { data: null, blob: null, completed: false },
      '4x3': { data: null, blob: null, completed: false },
      '3x2': { data: null, blob: null, completed: false }
    };

    // --- Debounce Helper ---
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    };


    document.addEventListener('DOMContentLoaded', () => {
      try {
        // --- DOM Element References ---
        const pageTitle = document.getElementById('pageTitle');
        const dropZone = document.getElementById('dropZone');
        const uploadIcon = document.getElementById('uploadIcon');
        const dropZoneText = document.getElementById('dropZoneText');
        const loadedFileInfo = document.getElementById('loadedFileInfo');
        const loadedFileName = document.getElementById('loadedFileName');
        const selectFileButton = document.getElementById('selectFileButton');
        const videoInput = document.getElementById('videoInput');

        const resolutionValue = document.getElementById('resolutionValue');
        const lengthValue = document.getElementById('lengthValue');
        const aspectRatioValue = document.getElementById('aspectRatioValue');
        const bitrateValue = document.getElementById('bitrateValue');

        const imageCountDisplay = document.getElementById('imageCountDisplay');
        const imageCountValue = document.getElementById('imageCountValue');

        const modeTabs = document.querySelectorAll('.mode-tab');
        const modeContentDiv = document.querySelector('.mode-content');
        const contactSheetModeDiv = document.getElementById('contactSheetMode');
        
        // Button groups in sticky container
        const autoModeButtons = document.getElementById('autoModeButtons');
        const smartModeButtons = document.getElementById('smartModeButtons');
        const contactSheetModeButtons = document.getElementById('contactSheetModeButtons');
        const manualModeButtons = document.getElementById('manualModeButtons');
        
        // Initialize button groups visibility
        if (autoModeButtons) autoModeButtons.style.display = 'flex'; // Default mode is 'auto'
        if (smartModeButtons) smartModeButtons.style.display = 'none';
        if (contactSheetModeButtons) contactSheetModeButtons.style.display = 'none';
        if (manualModeButtons) manualModeButtons.style.display = 'none';

        const intervalInput = document.getElementById('intervalInput');
        const intervalValue = document.getElementById('intervalValue');
        const jpegQualityAuto = document.getElementById('jpegQuality');
        const jpegQualityValueAuto = document.getElementById('jpegQualityValue');
        const webpQualityAuto = document.getElementById('webpQuality');
        const webpQualityValueAuto = document.getElementById('webpQualityValue');
        const jpegQualitySmart = document.getElementById('jpegQualitySmart');
        const jpegQualityValueSmart = document.getElementById('jpegQualityValueSmart');
        const webpQualitySmart = document.getElementById('webpQualitySmart');
        const webpQualityValueSmart = document.getElementById('webpQualityValueSmart');

        const formatTabsAuto = document.querySelectorAll('#autoMode .format-tab');
        const pngNoteAuto = document.getElementById('pngNote');
        const jpegSettingsAuto = document.getElementById('jpegSettings');
        const webpSettingsAuto = document.getElementById('webpSettings');
        const formatTabsSmart = document.querySelectorAll('#smartFormatTabs .format-tab');
        const pngNoteSmart = document.getElementById('pngNoteSmart');
        const jpegSettingsSmart = document.getElementById('jpegSettingsSmart');
        const webpSettingsSmart = document.getElementById('webpSettingsSmart');

        const processButton = document.getElementById('processButton');
        const downloadAllButton = document.getElementById('downloadAllButton');
        const progressBarAuto = document.getElementById('progressBarAuto');
        const progressBarFillAuto = document.getElementById('progressBarFillAuto');

        const processSmartButton = document.getElementById('processSmartButton');
        const downloadAllSmartButton = document.getElementById('downloadAllSmartButton');
        const progressBarSmart = document.getElementById('progressBarSmart');
        const progressBarFillSmart = document.getElementById('progressBarFillSmart');

        const smartAlgoTabs = document.querySelectorAll('.smart-tab');
        const histThresholdSettings = document.getElementById('histThresholdSettings');
        const pixelThresholdSettings = document.getElementById('pixelThresholdSettings');
        const ssimThresholdSettings = document.getElementById('ssimThresholdSettings');

        const manualVideo = document.getElementById('manualVideo');
        const extractManualButton = document.getElementById('extractManualButton');
        const addManualButton = document.getElementById('addManualButton');
        const downloadManualButton = document.getElementById('downloadManualButton');

        const contactSheetVideo = document.getElementById('contactSheetVideo');
        const contactSheetControlsElement = document.querySelector('.contact-sheet-controls');
        const fineTuneMessageElement = document.getElementById('fineTuneMessage');
        const processContactSheetButton = document.getElementById('processContactSheetButton');
        const downloadContactSheetButton = document.getElementById('downloadContactSheetButton');
        const previewContactSheetButton = document.getElementById('previewContactSheetButton');
        const progressBarContactSheet = document.getElementById('progressBarContactSheet');
        const progressBarFillContactSheet = document.getElementById('progressBarFillContactSheet');
        const contactSheetCanvas = document.getElementById('contactSheetCanvas'); // For final download generation
        const contactSheetPreviewElement = document.getElementById('contactSheetPreview'); // The grid container

        const removeBarsToggle = document.getElementById('removeBarsToggle');
        const screenshotsDiv = document.getElementById('screenshots');
        const video = document.getElementById('video'); // Hidden processing video
        const canvas = document.getElementById('canvas'); // General purpose canvas
        const frameCanvas = document.getElementById('frameCanvas'); // Hidden canvas for processing steps if needed
        const clearScreenshotsButton = document.getElementById('clearScreenshotsButton');
        const outputColumn = document.getElementById('outputColumn');

        verticalSeparatorElement = document.querySelector('.vertical-separator');

        // --- Check if Core Elements Exist ---
        if (!dropZone || !videoInput || !selectFileButton || !video || !manualVideo || !canvas || !frameCanvas || !contactSheetCanvas || !modeContentDiv || !screenshotsDiv || !clearScreenshotsButton || !processContactSheetButton || !downloadContactSheetButton || !previewContactSheetButton || !progressBarContactSheet || !loadedFileInfo || !loadedFileName || !imageCountDisplay || !imageCountValue || !contactSheetVideo || !contactSheetControlsElement || !fineTuneMessageElement || !contactSheetPreviewElement || !outputColumn) {
            throw new Error("One or more critical HTML elements are missing. Check IDs.");
        }

        // --- State Variables ---
        let currentMode = 'auto';
        let smartAlgorithm = 'histogram';
        let uploadedFile = null;
        let currentVideoDuration = 0;
        let processingActive = false;
        let cancelExtractionRequested = false;
        let screenshotBlobs = []; // Auto/Smart mode blobs { blob, timestamp }
        let manualScreenshotBlobs = []; // Manual mode blobs { blob, timestamp }
        let contactSheetBlob = null; // Final downloadable contact sheet blob
        let contactSheetPreviewData = new Array(20).fill(null); // Store { blob, timestamp } for each cell preview
        let currentSamplingProcess = null; // Ref to cancel sampling
        let fineTuneCaptureTimeout = null; // Timeout for debounced fine-tune captures


        // --- Helper Functions ---
        const updateSliderBackground = (slider) => { /* ... */ if (!slider) return; const val = slider.value; const min = slider.min || 0; const max = slider.max || 100; const pct = max > min ? ((val - min) * 100) / (max - min) : 0; let color = 'var(--accent-primary)'; if (slider.closest('#autoSmartMode')) color = 'var(--accent-secondary)'; slider.style.background = `linear-gradient(to right, ${color} 0%, ${color} ${pct}%, var(--bg-tertiary) ${pct}%, var(--bg-tertiary) 100%)`; };
        const formatTime = (seconds) => {
            if (isNaN(seconds)) seconds = 0;
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            const ms = Math.floor((seconds % 1) * 100);  // Get 2 decimal places for milliseconds
            
            if (h > 0) {
                return `${h}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
            } else {
                return `${m}:${s.toString().padStart(2, '0')}`;
            }
        };
        
        // Parse a time string in the format "h:mm:ss" or "m:ss" to seconds
        const parseTimeString = (timeStr) => {
            try {
                // Handle direct number input (like "45.5")
                if (!timeStr.includes(':')) {
                    const directSeconds = parseFloat(timeStr);
                    if (!isNaN(directSeconds)) {
                        return directSeconds;
                    }
                }
                
                // Handle time format with colons
                const parts = timeStr.trim().split(':');
                
                if (parts.length === 2) {
                    // Format: m:ss or m:ss.ms
                    const minutes = parseInt(parts[0], 10);
                    const seconds = parseFloat(parts[1]);
                    
                    if (!isNaN(minutes) && !isNaN(seconds)) {
                        return minutes * 60 + seconds;
                    }
                }
                else if (parts.length === 3) {
                    // Format: h:mm:ss or h:mm:ss.ms
                    const hours = parseInt(parts[0], 10);
                    const minutes = parseInt(parts[1], 10);
                    const seconds = parseFloat(parts[2]);
                    
                    if (!isNaN(hours) && !isNaN(minutes) && !isNaN(seconds)) {
                        return hours * 3600 + minutes * 60 + seconds;
                    }
                }
                
                // Fallback for invalid input
                console.warn("Invalid time format:", timeStr);
                return 0;
            } catch (error) {
                console.error("Error parsing time string:", error);
                return 0;
            }
        };
        const gcd = (a, b) => { /* ... */ return b ? gcd(b, a % b) : a; };
        const updateFileInfoDisplay = () => { /* ... */ if (!video?.duration || !video?.videoWidth || !video?.videoHeight || !resolutionValue || !lengthValue || !aspectRatioValue || !bitrateValue) return; currentVideoDuration = video.duration; const width = video.videoWidth; const height = video.videoHeight; resolutionValue.textContent = `${width}x${height}`; lengthValue.textContent = formatTime(currentVideoDuration); const divisor = gcd(width, height); aspectRatioValue.textContent = `${width / divisor}:${height / divisor}`; if (uploadedFile && uploadedFile.size > 0 && currentVideoDuration > 0) { const bitrateKbps = Math.round((uploadedFile.size * 8) / currentVideoDuration / 1000); bitrateValue.textContent = `${bitrateKbps} kbps`; } else { bitrateValue.textContent = "N/A"; } };
        const updateImageCount = () => { /* ... */ const autoSmartCount = screenshotBlobs.length; const manualCount = manualScreenshotBlobs.length; const totalCount = screenshotsDiv ? screenshotsDiv.childElementCount : 0; if (imageCountValue) imageCountValue.textContent = totalCount; if(downloadAllButton) downloadAllButton.disabled = currentMode !== 'auto' || autoSmartCount === 0 || processingActive; if(downloadAllSmartButton) downloadAllSmartButton.disabled = currentMode !== 'autoSmart' || autoSmartCount === 0 || processingActive; if(downloadManualButton) downloadManualButton.disabled = currentMode !== 'manual' || manualCount === 0 || processingActive; if(downloadContactSheetButton) downloadContactSheetButton.disabled = currentMode !== 'contactSheet' || !contactSheetBlob || processingActive; if(previewContactSheetButton) previewContactSheetButton.disabled = currentMode !== 'contactSheet' || !contactSheetBlob || processingActive; if(clearScreenshotsButton) clearScreenshotsButton.disabled = totalCount === 0 && !contactSheetPreviewData.some(d => d !== null); }; // Clear enabled if grid has content
        const updateDropZoneUI = (isFileLoaded, filename) => { /* ... */ if(!dropZone || !selectFileButton || !loadedFileName) return; if (isFileLoaded && filename) { dropZone.classList.add('file-loaded'); loadedFileName.textContent = filename; selectFileButton.textContent = "Change File"; selectFileButton.classList.add('file-selected'); updateFileInfoDisplay(); } else { dropZone.classList.remove('file-loaded'); loadedFileName.textContent = ''; selectFileButton.textContent = "Select File"; selectFileButton.classList.remove('file-selected'); if(resolutionValue) resolutionValue.textContent = '-'; if(lengthValue) lengthValue.textContent = '-'; if(aspectRatioValue) aspectRatioValue.textContent = '-'; if(bitrateValue) bitrateValue.textContent = '-'; } };

        // --- UI State Management ---
        const resetProcessingUI = (mode = 'all') => { /* ... */ 
            console.log(`[Reset UI] Resetting for mode: ${mode}`); 
            processingActive = false; 
            cancelExtractionRequested = false; 
            currentSamplingProcess = null; 
            
            if (verticalSeparatorElement) 
                verticalSeparatorElement.classList.remove('loading', 'loading-smart', 'loading-contact-sheet'); 
                
            const resetButton = (btn, text, startHandler) => { 
                if (!btn) return; 
                btn.disabled = !video?.src; 
                btn.textContent = text; 
                btn.classList.remove('cancel-active'); 
                btn.removeEventListener('click', handleCancelClick); 
                btn.removeEventListener('click', startHandler); 
                btn.addEventListener('click', startHandler); 
            }; 
            
            if ((mode === 'auto' || mode === 'all') && processButton) { 
                if(progressBarAuto) progressBarAuto.style.display = 'none'; 
                if(progressBarFillAuto) progressBarFillAuto.style.width = '0%'; 
                resetButton(processButton, 'Extract Screenshots', startAutoExtraction); 
                if(downloadAllButton) downloadAllButton.disabled = currentMode !== 'auto' || screenshotBlobs.length === 0; 
            } 
            
            if ((mode === 'autoSmart' || mode === 'all') && processSmartButton) { 
                if(progressBarSmart) progressBarSmart.style.display = 'none'; 
                if(progressBarFillSmart) progressBarFillSmart.style.width = '0%'; 
                resetButton(processSmartButton, 'Extract Smart Shots', startSmartExtraction); 
                if(downloadAllSmartButton) downloadAllSmartButton.disabled = currentMode !== 'autoSmart' || screenshotBlobs.length === 0; 
            } 
            
            if ((mode === 'contactSheet' || mode === 'all') && processContactSheetButton) { 
                if(progressBarContactSheet) progressBarContactSheet.style.display = 'none'; 
                if(progressBarFillContactSheet) progressBarFillContactSheet.style.width = '0%'; 
                resetButton(processContactSheetButton, 'Generate/Update Sheet', generateContactSheet); 
                if(downloadContactSheetButton) downloadContactSheetButton.disabled = currentMode !== 'contactSheet' || !contactSheetBlob;
                if(previewContactSheetButton) previewContactSheetButton.disabled = currentMode !== 'contactSheet' || !contactSheetBlob;
            } 
            
            if (mode === 'manual' || mode === 'all') { 
                if(addManualButton) addManualButton.disabled = !video?.src; 
                if(extractManualButton) extractManualButton.disabled = !video?.src; 
                if(downloadManualButton) downloadManualButton.disabled = currentMode !== 'manual' || manualScreenshotBlobs.length === 0 || processingActive; 
            } 
            
            if (video?.src) { 
                if(processButton && currentMode !== 'auto') processButton.disabled = false; 
                if(processSmartButton && currentMode !== 'autoSmart') processSmartButton.disabled = false; 
                if(processContactSheetButton && currentMode !== 'contactSheet') processContactSheetButton.disabled = false; 
                if(addManualButton && currentMode !== 'manual') addManualButton.disabled = false; 
                if(extractManualButton && currentMode !== 'manual') extractManualButton.disabled = false; 
            } 
            
            updateImageCount(); 
        };
        
        const setProcessingUI = (mode) => { /* ... */ 
            console.log(`[Set UI] Setting processing state for mode: ${mode}`); 
            processingActive = true; 
            cancelExtractionRequested = false; 
            
            [processButton, processSmartButton, processContactSheetButton, downloadAllButton, downloadAllSmartButton, downloadManualButton, downloadContactSheetButton, addManualButton, extractManualButton, clearScreenshotsButton].forEach(btn => { 
                if (btn) btn.disabled = true; 
            }); 
            
            let processBtn, progressBar, progressBarFill, startHandler, loadingClass; 
            
            if (mode === 'auto' && processButton) { 
                processBtn = processButton; 
                progressBar = progressBarAuto; 
                progressBarFill = progressBarFillAuto; 
                startHandler = startAutoExtraction; 
                loadingClass = 'loading'; 
            } else if (mode === 'autoSmart' && processSmartButton) { 
                processBtn = processSmartButton; 
                progressBar = progressBarSmart; 
                progressBarFill = progressBarFillSmart; 
                startHandler = startSmartExtraction; 
                loadingClass = 'loading-smart'; 
            } else if (mode === 'contactSheet' && processContactSheetButton) { 
                processBtn = processContactSheetButton; 
                progressBar = progressBarContactSheet; 
                progressBarFill = progressBarFillContactSheet; 
                startHandler = generateContactSheet; 
                loadingClass = 'loading-contact-sheet'; 
            } else { 
                return; 
            } 
            
            if (verticalSeparatorElement && loadingClass) 
                verticalSeparatorElement.classList.add(loadingClass); 
                
            if (progressBar) 
                progressBar.style.display = 'block'; 
                
            if (progressBarFill) 
                progressBarFill.style.width = '0%'; 
                
            processBtn.textContent = 'Cancel Extraction'; 
            processBtn.classList.add('cancel-active'); 
            processBtn.removeEventListener('click', startHandler); 
            processBtn.addEventListener('click', handleCancelClick, { once: true }); 
            processBtn.disabled = false; 
        };

        const handleCancelClick = () => { /* ... */ console.log("[Cancel Action] Cancel requested by user."); cancelExtractionRequested = true; if (currentSamplingProcess && typeof currentSamplingProcess.cancel === 'function') currentSamplingProcess.cancel(); if (currentMode === 'contactSheet') clearContactSheetPreview(false); /* Don't clear time inputs on cancel */ resetProcessingUI(currentMode); };

        // --- Helper Functions (Cont.) ---
        const computeHistogram = (imageData, sampleFactor = 4) => { /* ... */ const data = imageData.data; const hist = new Array(256).fill(0); let count = 0; for (let i = 0; i < data.length; i += 4 * sampleFactor) { const gray = Math.round(0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]); hist[gray]++; count++; } if (count === 0) return hist; return hist.map(val => val / count); };
        const histogramDifference = (hist1, hist2) => { /* ... */ if (!hist1 || !hist2 || hist1.length !== hist2.length) return 1; return hist1.reduce((acc, val, i) => acc + Math.abs(val - hist2[i]), 0); };
        const computePixelDiff = (data1, data2, sampleFactor = 4) => { /* ... */ let diff = 0; let count = 0; const step = 4 * sampleFactor; for (let i = 0; i < data1.length; i += step) { diff += Math.abs(data1[i] - data2[i]); diff += Math.abs(data1[i+1] - data2[i+1]); diff += Math.abs(data1[i+2] - data2[i+2]); count++; } return count > 0 ? (diff / (count * 3)) : 0; };
        const computeSSIM = (imageData1, imageData2, sampleFactor = 4) => { /* ... */ const data1 = imageData1.data; const data2 = imageData2.data; let sum1 = 0, sum2 = 0, count = 0; const step = 4 * sampleFactor; for (let i = 0; i < data1.length; i += step) { sum1 += (0.299 * data1[i] + 0.587 * data1[i + 1] + 0.114 * data1[i + 2]); sum2 += (0.299 * data2[i] + 0.587 * data2[i + 1] + 0.114 * data2[i + 2]); count++; } if (count === 0) return 1; const avg1 = sum1 / count; const avg2 = sum2 / count; const maxDiff = 255; const avgDiff = Math.abs(avg1 - avg2); return Math.max(0, 1 - (avgDiff / maxDiff)); };
        const createScreenshotElement = (blob, timestamp, blobArrayRef) => { /* ... */ if(!screenshotsDiv || !blob) return null; const container = document.createElement('div'); container.className = "screenshot-container"; const blobUrl = URL.createObjectURL(blob); container.dataset.blobUrl = blobUrl; container.dataset.timestamp = String(timestamp); const a = document.createElement('a'); a.href = blobUrl; a.target = "_blank"; const img = document.createElement('img'); img.src = blobUrl; img.alt = `Screenshot at ${formatTime(timestamp)}`; a.appendChild(img); container.appendChild(a); if (timestamp >= 0) { const overlay = document.createElement('div'); overlay.className = "screenshot-overlay"; overlay.textContent = formatTime(timestamp); container.appendChild(overlay); } const delBtn = document.createElement('button'); delBtn.className = "delete-btn"; delBtn.innerHTML = "Ã—"; delBtn.title = "Remove this screenshot"; delBtn.addEventListener('click', (e) => { e.stopPropagation(); const urlToRemove = container.dataset.blobUrl; const timeToRemove = parseFloat(container.dataset.timestamp); const indexToRemove = blobArrayRef.findIndex(item => item.timestamp === timeToRemove && item.blob?.size === blob.size); if (indexToRemove > -1) { blobArrayRef.splice(indexToRemove, 1); } else { console.warn("Could not find blob to remove."); } URL.revokeObjectURL(urlToRemove); container.remove(); updateImageCount(); }); container.appendChild(delBtn); return container; };
        const getCurrentFormatSettings = () => { /* ... */ let format = 'png'; let qualitySlider = null; let qualityValue = 1.0; const activeModeId = document.querySelector('.mode-content > div.active')?.id; const formatTabsContainerId = (activeModeId === 'manualMode' || activeModeId === 'contactSheetMode') ? 'autoMode' : activeModeId; const activeFormatTab = document.querySelector(`#${formatTabsContainerId} .format-tab.active`); if (activeFormatTab) format = activeFormatTab.getAttribute('data-format') || 'png'; if (format === 'jpeg') { qualitySlider = (activeModeId === 'autoSmartMode') ? jpegQualitySmart : jpegQualityAuto; qualityValue = qualitySlider ? parseFloat(qualitySlider.value) / 100 : 0.85; } else if (format === 'webp') { qualitySlider = (activeModeId === 'autoSmartMode') ? webpQualitySmart : webpQualityAuto; qualityValue = qualitySlider ? parseFloat(qualitySlider.value) / 100 : 0.85; } const type = `image/${format}`; return { type, quality: qualityValue }; };
        const downloadBlobsAsZip = (blobDataArray, baseFilename = "screenshots") => { /* ... */ if (!blobDataArray || blobDataArray.length === 0) { alert("No screenshots to download."); return; } if (!window.JSZip) { alert("Error: JSZip library not loaded."); return; } const zip = new JSZip(); const { type } = getCurrentFormatSettings(); const extension = type.split('/')[1] === 'jpeg' ? 'jpg' : type.split('/')[1]; blobDataArray.forEach((item, index) => { if (!item || !item.blob) return; const timeSuffix = (item.timestamp !== undefined && item.timestamp >= 0) ? `_${formatTime(item.timestamp).replace(':','-')}` : `_${index + 1}`; const filename = `${baseFilename}${timeSuffix}.${extension}`; zip.file(filename, item.blob); }); zip.generateAsync({ type: "blob" }).then((content) => { const tempLink = document.createElement('a'); const url = URL.createObjectURL(content); tempLink.href = url; tempLink.download = `${baseFilename}.zip`; document.body.appendChild(tempLink); tempLink.click(); document.body.removeChild(tempLink); URL.revokeObjectURL(url); }).catch((err) => { console.error("Error generating ZIP:", err); alert("Error creating ZIP file: " + err.message); }); };
        const handleFileLoad = (file) => { /* ... */ if (!video || !manualVideo || !contactSheetVideo || !file) return; uploadedFile = file; const fileURL = URL.createObjectURL(file); video.src = fileURL; manualVideo.src = fileURL; contactSheetVideo.src = fileURL; updateDropZoneUI(true, file.name); resetUIOnNewVideo(); };
        const resetUIOnNewVideo = () => { /* ... */ 
            if(screenshotsDiv) screenshotsDiv.innerHTML = ''; 
            screenshotBlobs = []; 
            manualScreenshotBlobs = []; 
            contactSheetBlob = null; 
            cropData = null; 
            clearContactSheetPreview(true);
            
            // Reset grid cache for new video
            gridCache = {
                '5x4': { data: null, blob: null, completed: false },
                '4x3': { data: null, blob: null, completed: false },
                '3x2': { data: null, blob: null, completed: false }
            };
            
            // Clear completion markers
            document.querySelectorAll('.grid-size-tab').forEach(tab => {
                tab.classList.remove('completed');
            });
            
            updateImageCount(); 
            resetProcessingUI('all'); 
        };

        // --- Refactored Sampling Logic ---
        const sampleVideoFrames = (options) => {
            const { videoElement = video, // Allow specifying which video element
                    sampleTimestamps, // Provide timestamps directly
                    outputType, useCrop,
                    processFrameCallback, onCompleteCallback, onProgressCallback, onErrorCallback } = options;

            let localCancelRequested = false; let currentSampleIndex = 0; const collectedData = [];
            if (!videoElement || !videoElement.src || videoElement.readyState < videoElement.HAVE_METADATA || videoElement.duration <= 0) { const error = new Error("Video not ready for sampling."); if (onErrorCallback) onErrorCallback(error); else console.error(error); onCompleteCallback(); return { cancel: () => {} }; }
            if (!sampleTimestamps || sampleTimestamps.length === 0) { const error = new Error("No timestamps provided for sampling."); if (onErrorCallback) onErrorCallback(error); else console.error(error); onCompleteCallback(); return { cancel: () => {} }; }

            const totalSamples = sampleTimestamps.length;

            const processNext = () => {
                if (localCancelRequested || currentSampleIndex >= totalSamples) { onCompleteCallback(collectedData); return; }
                const timestamp = sampleTimestamps[currentSampleIndex];
                if (onProgressCallback) onProgressCallback(((currentSampleIndex + 1) / totalSamples) * 100); // Progress based on completion

                const captureCurrentFrame = (callback) => {
                    if (!videoElement || !frameCanvas || videoElement.readyState < 1) { callback(null); return; }
                    let seekTimeout = setTimeout(() => { videoElement.removeEventListener('seeked', onSeeked); videoElement.removeEventListener('error', onError); callback(null, "Seek timeout"); }, 5000);

                    const onSeeked = () => {
                        clearTimeout(seekTimeout); videoElement.removeEventListener('error', onError);
                        try {
                            const ctx = frameCanvas.getContext('2d', { willReadFrequently: outputType === 'imageData' }); if (!ctx) throw new Error("Could not get frameCanvas context");
                            const sourceX = (useCrop && cropData) ? cropData.cropX : 0; const sourceY = (useCrop && cropData) ? cropData.cropY : 0; const sourceWidth = (useCrop && cropData && cropData.cropWidth > 0) ? cropData.cropWidth : videoElement.videoWidth; const sourceHeight = (useCrop && cropData && cropData.cropHeight > 0) ? cropData.cropHeight : videoElement.videoHeight;
                            if (sourceWidth <= 0 || sourceHeight <= 0) { console.warn("Invalid source dimensions for drawing:", sourceWidth, sourceHeight); callback(null, "Invalid source dimensions"); return; }
                            frameCanvas.width = sourceWidth; frameCanvas.height = sourceHeight;
                            ctx.drawImage(videoElement, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, sourceWidth, sourceHeight);
                            if (outputType === 'imageData') { const imgData = ctx.getImageData(0, 0, frameCanvas.width, frameCanvas.height); callback(imgData); }
                            else { const { type, quality } = getCurrentFormatSettings(); frameCanvas.toBlob((blob) => callback(blob), type, quality); }
                        } catch (error) { callback(null, error); }
                    };
                    const onError = (e) => { clearTimeout(seekTimeout); videoElement.removeEventListener('seeked', onSeeked); callback(null, e); };

                    videoElement.addEventListener('seeked', onSeeked, { once: true }); videoElement.addEventListener('error', onError, { once: true });
                    try {
                         const targetTime = Math.max(0, Math.min(timestamp, videoElement.duration - 0.01));
                         if (Math.abs(videoElement.currentTime - targetTime) > 0.01) { videoElement.currentTime = targetTime; }
                         else { onSeeked(); } // Already there
                    } catch (error) { clearTimeout(seekTimeout); videoElement.removeEventListener('seeked', onSeeked); videoElement.removeEventListener('error', onError); callback(null, error); }
                };

                captureCurrentFrame((frameData, error) => {
                    if (localCancelRequested) { onCompleteCallback(collectedData); return; } // Check again
                    if (error || !frameData) { console.warn(`[sampleVideoFrames] Failed to capture frame at ${timestamp.toFixed(2)}s`, error || ''); }
                    else {
                         try {
                             // Pass the index along with the data and timestamp
                             processFrameCallback(frameData, timestamp, currentSampleIndex);
                             collectedData[currentSampleIndex] = { data: frameData, timestamp }; // Store successful data
                         } catch (processError) { console.error(`[sampleVideoFrames] Error in processFrameCallback at ${timestamp.toFixed(2)}s:`, processError); if (onErrorCallback) onErrorCallback(processError); }
                     }
                    currentSampleIndex++; requestAnimationFrame(processNext); // Use rAF for next step
                });
            };
            requestAnimationFrame(processNext); // Start the process
            return { cancel: () => { console.log("[sampleVideoFrames] Cancellation requested."); localCancelRequested = true; } };
        };


        // --- Black Bars Detection (Uses Sampler with calculated times) ---
        const detectCropBoundariesMulti = (callback) => {
             if (!video || !video.src || video.readyState < video.HAVE_METADATA || currentVideoDuration <= 0) { console.warn("Video not ready for crop detection."); cropData = { cropX: 0, cropY: 0, cropWidth: video.videoWidth || 1, cropHeight: video.videoHeight || 1 }; if (callback) callback(); return; }
             let sampleResults = []; console.log("Starting black bar detection sampling...");

             // Calculate timestamps for detection
             const numSamples = 3; const startPercent = 0.3; const endPercent = 0.7;
             const sampleTimestamps = [];
             const step = (endPercent - startPercent) / (numSamples > 1 ? numSamples - 1 : 1);
             for (let i = 0; i < numSamples; i++) {
                 const percent = startPercent + (i * step);
                 const time = Math.max(0.01, Math.min(percent * currentVideoDuration, currentVideoDuration - 0.01));
                 if (!isNaN(time)) sampleTimestamps.push(time);
             }

             currentSamplingProcess = sampleVideoFrames({
                 sampleTimestamps: sampleTimestamps, outputType: 'imageData', useCrop: false,
                 processFrameCallback: (imageData, timestamp) => {
                     if (!imageData) return; console.log(`Analyzing frame for black bars at ${timestamp.toFixed(2)}s`);
                     // ... (analysis logic remains the same) ...
                     const data = imageData.data, width = imageData.width, height = imageData.height; const pixelThreshold = 15, lineRatioThreshold = 0.98; let topCrop = 0, bottomCrop = height - 1, leftCrop = 0, rightCrop = width - 1;
                     for (let y = 0; y < height / 2; y++) { let blackPxCount = 0; for (let x = 0; x < width; x++) { const i = (y * width + x) * 4; if (data[i] < pixelThreshold && data[i + 1] < pixelThreshold && data[i + 2] < pixelThreshold) blackPxCount++; } if (blackPxCount / width < lineRatioThreshold) { topCrop = y; break; } if (y === Math.floor(height / 2) - 1) topCrop = y; }
                     for (let y = height - 1; y >= height / 2; y--) { let blackPxCount = 0; for (let x = 0; x < width; x++) { const i = (y * width + x) * 4; if (data[i] < pixelThreshold && data[i + 1] < pixelThreshold && data[i + 2] < pixelThreshold) blackPxCount++; } if (blackPxCount / width < lineRatioThreshold) { bottomCrop = y; break; } if (y === Math.ceil(height / 2)) bottomCrop = y; }
                     for (let x = 0; x < width / 2; x++) { let blackPxCount = 0; for (let y = topCrop; y <= bottomCrop; y++) { const i = (y * width + x) * 4; if (data[i] < pixelThreshold && data[i + 1] < pixelThreshold && data[i + 2] < pixelThreshold) blackPxCount++; } if (blackPxCount / (bottomCrop - topCrop + 1 || 1) < lineRatioThreshold) { leftCrop = x; break; } if (x === Math.floor(width / 2) - 1) leftCrop = x; }
                     for (let x = width - 1; x >= width / 2; x--) { let blackPxCount = 0; for (let y = topCrop; y <= bottomCrop; y++) { const i = (y * width + x) * 4; if (data[i] < pixelThreshold && data[i + 1] < pixelThreshold && data[i + 2] < pixelThreshold) blackPxCount++; } if (blackPxCount / (bottomCrop - topCrop + 1 || 1) < lineRatioThreshold) { rightCrop = x; break; } if (x === Math.ceil(width / 2)) rightCrop = x; }
                     sampleResults.push({ topCrop, bottomCrop, leftCrop, rightCrop });
                 },
                 onCompleteCallback: () => { /* ... (median calculation remains the same) ... */ console.log("Black bar detection sampling complete."); if (sampleResults.length > 0) { const median = (arr) => arr.length ? arr.slice().sort((a, b) => a - b)[Math.floor(arr.length / 2)] : 0; const finalTop = median(sampleResults.map(r => r.topCrop)); const finalBottom = median(sampleResults.map(r => r.bottomCrop)); const finalLeft = median(sampleResults.map(r => r.leftCrop)); const finalRight = median(sampleResults.map(r => r.rightCrop)); const finalCropWidth = Math.max(1, finalRight - finalLeft + 1); const finalCropHeight = Math.max(1, finalBottom - finalTop + 1); cropData = { cropX: finalLeft, cropY: finalTop, cropWidth: finalCropWidth, cropHeight: finalCropHeight }; } else { cropData = { cropX: 0, cropY: 0, cropWidth: video.videoWidth || 1, cropHeight: video.videoHeight || 1 }; console.warn("Black bar detection failed to get samples, using default full frame."); } console.log("Detected black bars crop data:", cropData); if (callback) callback(); currentSamplingProcess = null; },
                 onErrorCallback: (error) => { console.error("Error during black bar detection sampling:", error); cropData = { cropX: 0, cropY: 0, cropWidth: video.videoWidth || 1, cropHeight: video.videoHeight || 1 }; }
             });
         };


        // --- Event Listeners Setup ---
        if (pageTitle) pageTitle.addEventListener('click', () => window.location.reload());
        if (video) video.addEventListener('loadedmetadata', () => {
             updateFileInfoDisplay(); // Update stats in the dropzone
             resetProcessingUI('all');
             if (removeBarsEnabled) detectCropBoundariesMulti(() => console.log("Initial black bar detection complete."));
         });
        // Sync contactSheetVideo playback time if user scrubs it
        if (contactSheetVideo) {
            contactSheetVideo.addEventListener('timeupdate', () => {
                if (!processingActive && currentMode === 'contactSheet') {
                   // Optional: Update an input field if needed, or just use for playback
                }
            });
        }

        // File Upload Listeners
        if (videoInput) videoInput.addEventListener('change', (event) => { const file = event.target.files[0]; if (file) handleFileLoad(file); });
        if (dropZone) { /* ... */ dropZone.addEventListener('dragover', (e) => { e.preventDefault(); if (!dropZone.classList.contains('file-loaded')) dropZone.classList.add('hover'); }); dropZone.addEventListener('dragleave', (e) => { e.preventDefault(); dropZone.classList.remove('hover'); }); dropZone.addEventListener('drop', (e) => { e.preventDefault(); dropZone.classList.remove('hover'); const file = e.dataTransfer.files[0]; if (file && file.type.startsWith('video/')) handleFileLoad(file); else alert("Please drop a valid video file."); }); dropZone.addEventListener('click', (e) => { if (!dropZone.classList.contains('file-loaded') && selectFileButton && !selectFileButton.contains(e.target) && videoInput) videoInput.click(); }); }
        if (selectFileButton) selectFileButton.addEventListener('click', (e) => { e.stopPropagation(); if(videoInput) videoInput.click(); });

        // --- Mode Tabs Listener ---
        if (modeTabs.length > 0 && modeContentDiv) {
             modeTabs.forEach(tab => {
                 tab.addEventListener('click', () => {
                   if (processingActive) return; const newMode = tab.getAttribute('data-mode'); if (!newMode || !modeContentDiv) return; currentMode = newMode; modeTabs.forEach(t => t.classList.remove('active')); tab.classList.add('active');
                   Array.from(modeContentDiv.children).forEach(contentDiv => { contentDiv.classList.toggle('active', contentDiv.id === `${newMode}Mode`); });

                   const showPreview = (newMode === 'contactSheet');
                   outputColumn.classList.toggle('show-contact-sheet', showPreview);
                   
                   // Toggle the correct button groups
                   const autoModeButtons = document.getElementById('autoModeButtons');
                   const smartModeButtons = document.getElementById('smartModeButtons');
                   const contactSheetModeButtons = document.getElementById('contactSheetModeButtons');
                   const manualModeButtons = document.getElementById('manualModeButtons');
                   
                   if (autoModeButtons) autoModeButtons.style.display = (newMode === 'auto') ? 'flex' : 'none';
                   if (smartModeButtons) smartModeButtons.style.display = (newMode === 'autoSmart') ? 'flex' : 'none';
                   if (contactSheetModeButtons) contactSheetModeButtons.style.display = (newMode === 'contactSheet') ? 'flex' : 'none';
                   if (manualModeButtons) manualModeButtons.style.display = (newMode === 'manual') ? 'flex' : 'none';
                   
                   // Toggle the correct progress bars - keep them hidden initially
                   const progressBarAuto = document.getElementById('progressBarAuto');
                   const progressBarSmart = document.getElementById('progressBarSmart');
                   const progressBarContactSheet = document.getElementById('progressBarContactSheet');
                   
                   if (progressBarAuto) progressBarAuto.style.display = 'none';
                   if (progressBarSmart) progressBarSmart.style.display = 'none';
                   if (progressBarContactSheet) progressBarContactSheet.style.display = 'none';

                   if (showPreview) {
                       initContactSheetPreview(); // Ensure grid is ready
                       generateTimeInputs(); // Initialize time inputs if needed
                   } else {
                       contactSheetBlob = null; // Reset blob if switching away
                       if(downloadContactSheetButton) downloadContactSheetButton.disabled = true;
                       if (contactSheetControlsElement) contactSheetControlsElement.style.display = 'none';
                       if (fineTuneMessageElement) fineTuneMessageElement.style.display = 'none';
                   }
                   // Clear regular screenshots if switching to contact sheet or manual
                   if (newMode === 'contactSheet' || newMode === 'manual') { if (screenshotsDiv) screenshotsDiv.innerHTML = ''; screenshotBlobs = []; manualScreenshotBlobs = []; }

                   document.querySelectorAll(`#${newMode}Mode input[type="range"]`).forEach(updateSliderBackground); updateImageCount();
                 });
             });
         }

        // --- Grid Size Tabs Listener ---
        const gridSizeTabs = document.querySelectorAll('.grid-size-tab');
        if (gridSizeTabs.length > 0) {
            gridSizeTabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    if (processingActive) return;
                    
                    const rows = parseInt(tab.getAttribute('data-rows'));
                    const cols = parseInt(tab.getAttribute('data-cols'));
                    
                    if (isNaN(rows) || isNaN(cols)) return;
                    
                    // Save current state if we have data
                    const previousTab = document.querySelector('.grid-size-tab.active');
                    if (previousTab) {
                        const prevRows = parseInt(previousTab.getAttribute('data-rows'));
                        const prevCols = parseInt(previousTab.getAttribute('data-cols'));
                        const cacheKey = `${prevCols}x${prevRows}`;
                        
                        if (contactSheetPreviewData.some(item => item !== null)) {
                            gridCache[cacheKey] = {
                                data: [...contactSheetPreviewData],
                                blob: contactSheetBlob,
                                completed: previousTab.classList.contains('completed')
                            };
                        }
                    }
                    
                    // Update active tab styling
                    gridSizeTabs.forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    
                    // Check if we have cached data for this grid size
                    const cacheKey = `${cols}x${rows}`;
                    const cachedGrid = gridCache[cacheKey];
                    
                    if (cachedGrid && cachedGrid.data && cachedGrid.data.some(item => item !== null)) {
                        // Restore from cache
                        clearContactSheetPreview(true); // Clear existing
                        initContactSheetPreview(rows, cols);
                        generateTimeInputs(rows, cols);
                        
                        // Restore preview cells from cache
                        contactSheetPreviewData = cachedGrid.data;
                        contactSheetBlob = cachedGrid.blob;
                        
                        // Restore cell visuals
                        contactSheetPreviewData.forEach((data, index) => {
                            if (data && data.blob) {
                                updatePreviewCell(index, data.blob, data.timestamp);
                                
                                // Update time input values
                                const timeInput = document.getElementById(`timeInput_${index}`);
                                const timeFormatted = document.getElementById(`timeFormatted_${index}`);
                                if (timeInput) timeInput.value = data.timestamp.toFixed(2);
                                if (timeFormatted) timeFormatted.value = formatTime(data.timestamp);
                            }
                        });
                        
                        // Show controls if we have data
                        if (contactSheetControlsElement) contactSheetControlsElement.style.display = 'grid';
                        if (fineTuneMessageElement) fineTuneMessageElement.style.display = 'block';
                        if (downloadContactSheetButton) downloadContactSheetButton.disabled = !cachedGrid.blob;
                        if (previewContactSheetButton) previewContactSheetButton.disabled = !cachedGrid.blob;
                        
                        // Restore completed status
                        if (cachedGrid.completed) {
                            tab.classList.add('completed');
                        }
                    } else {
                        // No cache, initialize new grid
                        clearContactSheetPreview(true);
                        initContactSheetPreview(rows, cols);
                        generateTimeInputs(rows, cols);
                        
                        // Clear any completion marker
                        tab.classList.remove('completed');
                        
                        // Reset the final blob since we changed the grid
                        contactSheetBlob = null;
                        if (downloadContactSheetButton) downloadContactSheetButton.disabled = true;
                    }
                });
            });
        }

        // --- Sliders, Toggle, Format Tabs, Algo Tabs Setup --- (remain largely the same)
        const setupSlider = (slider, displaySpan, suffix) => { /* ... */ if (!slider || !displaySpan) return; const updateSliderUI = () => { displaySpan.textContent = slider.value + suffix; updateSliderBackground(slider); }; slider.addEventListener('input', updateSliderUI); updateSliderUI(); };
        setupSlider(intervalInput, intervalValue, 's'); setupSlider(jpegQualityAuto, jpegQualityValueAuto, '%'); setupSlider(webpQualityAuto, webpQualityValueAuto, '%'); setupSlider(jpegQualitySmart, jpegQualityValueSmart, '%'); setupSlider(webpQualitySmart, webpQualityValueSmart, '%'); setupSlider(histThresholdInput, histThresholdValue, ''); setupSlider(pixelThresholdInput, pixelThresholdValue, ''); setupSlider(ssimThresholdInput, ssimThresholdValue, '');
        if (removeBarsToggle) removeBarsToggle.addEventListener('change', (e) => { removeBarsEnabled = e.target.checked; if (removeBarsEnabled && !cropData && video?.src) detectCropBoundariesMulti(() => console.log("Black bar detection after toggle.")); });
        const setupFormatTabs = (tabsNodeList, pngNoteEl, jpegSettingsEl, webpSettingsEl) => { /* ... */ if (tabsNodeList.length === 0 || !pngNoteEl || !jpegSettingsEl || !webpSettingsEl) return; const updateFormatVisibility = (format) => { pngNoteEl.style.display = (format === 'png') ? 'flex' : 'none'; jpegSettingsEl.style.display = (format === 'jpeg') ? 'flex' : 'none'; webpSettingsEl.style.display = (format === 'webp') ? 'flex' : 'none'; }; let initialFormat = 'png'; tabsNodeList.forEach(tab => { if (tab.classList.contains('active')) initialFormat = tab.getAttribute('data-format') || 'png'; tab.addEventListener('click', () => { if (processingActive) return; const format = tab.getAttribute('data-format'); if (!format) return; tabsNodeList.forEach(t => t.classList.remove('active')); tab.classList.add('active'); updateFormatVisibility(format); }); }); updateFormatVisibility(initialFormat); };
        setupFormatTabs(formatTabsAuto, pngNoteAuto, jpegSettingsAuto, webpSettingsAuto); setupFormatTabs(formatTabsSmart, pngNoteSmart, jpegSettingsSmart, webpSettingsSmart);
        if (smartAlgoTabs.length > 0) { /* ... */ let initialAlgo = 'histogram'; const updateThresholdSliders = (algo) => { if(histThresholdSettings) histThresholdSettings.style.display = (algo === 'histogram') ? 'flex' : 'none'; if(pixelThresholdSettings) pixelThresholdSettings.style.display = (algo === 'pixeldiff') ? 'flex' : 'none'; if(ssimThresholdSettings) ssimThresholdSettings.style.display = (algo === 'ssim') ? 'flex' : 'none'; }; smartAlgoTabs.forEach(tab => { if (tab.classList.contains('active')) initialAlgo = tab.getAttribute('data-algo') || 'histogram'; tab.addEventListener('click', () => { if (processingActive) return; const algo = tab.getAttribute('data-algo'); if(!algo) return; smartAlgorithm = algo; smartAlgoTabs.forEach(t => t.classList.remove('active')); tab.classList.add('active'); updateThresholdSliders(algo); }); }); smartAlgorithm = initialAlgo; updateThresholdSliders(initialAlgo); }

        // --- Processing Logic (Auto/Smart/Manual) ---
        // Capture frame function for single frames (remains robust)
        const captureFrameAtTime = (time, callback) => {
            if (!video || !canvas || !video.src || video.readyState < 1) {
                callback(null);
                return;
            }

            const videoElement = video;
            let seekTimeout = setTimeout(() => {
                videoElement.removeEventListener('seeked', onSeeked);
                videoElement.removeEventListener('error', onError);
                callback(null);
            }, 5000);

            const onSeeked = () => {
                clearTimeout(seekTimeout);
                videoElement.removeEventListener('error', onError);
                try {
                    const ctx = canvas.getContext('2d');
                    if (!ctx) throw new Error('Could not get 2d context');

                    const sourceX = (removeBarsEnabled && cropData) ? cropData.cropX : 0;
                    const sourceY = (removeBarsEnabled && cropData) ? cropData.cropY : 0;
                    const sourceWidth = (removeBarsEnabled && cropData && cropData.cropWidth > 0) ? cropData.cropWidth : videoElement.videoWidth;
                    const sourceHeight = (removeBarsEnabled && cropData && cropData.cropHeight > 0) ? cropData.cropHeight : videoElement.videoHeight;

                    if (sourceWidth <= 0 || sourceHeight <= 0) {
                        throw new Error("Invalid source dimensions for drawing.");
                    }

                    canvas.width = sourceWidth;
                    canvas.height = sourceHeight;
                    ctx.drawImage(videoElement, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, sourceWidth, sourceHeight);
                    
                    const { type, quality } = getCurrentFormatSettings();
                    canvas.toBlob((blob) => callback(blob), type, quality);
                } catch (error) {
                    console.error("[captureFrameAtTime] Error:", error);
                    callback(null);
                }
            };

            const onError = (e) => {
                console.error("[captureFrameAtTime] Video Error:", e);
                clearTimeout(seekTimeout);
                videoElement.removeEventListener('seeked', onSeeked);
                callback(null);
            };

            videoElement.addEventListener('seeked', onSeeked, { once: true });
            videoElement.addEventListener('error', onError, { once: true });

            try {
                const targetTime = Math.max(0, Math.min(time, currentVideoDuration - 0.01));
                if (Math.abs(videoElement.currentTime - targetTime) > 0.01) {
                    videoElement.currentTime = targetTime;
                } else {
                    onSeeked();
                }
            } catch (error) {
                console.error("[captureFrameAtTime] Seek Error:", error);
                clearTimeout(seekTimeout);
                videoElement.removeEventListener('seeked', onSeeked);
                videoElement.removeEventListener('error', onError);
                callback(null);
            }
        };

        const startAutoExtraction = () => {
            if (!video?.src || processingActive || !intervalInput) return;
            
            setProcessingUI('auto');
            if (screenshotsDiv) screenshotsDiv.innerHTML = '';
            screenshotBlobs = [];
            updateImageCount();
            contactSheetBlob = null;

            const interval = parseFloat(intervalInput.value);
            if (isNaN(interval) || interval <= 0) {
                resetProcessingUI('auto');
                return;
            }

            let currentTime = 0;
            const totalDuration = currentVideoDuration;
            let frameRequestActive = false;

            const processNextFrame = () => {
                if (cancelExtractionRequested || currentTime > totalDuration + 0.1) {
                    resetProcessingUI('auto');
                    return;
                }

                if (frameRequestActive) {
                    requestAnimationFrame(processNextFrame);
                    return;
                }

                frameRequestActive = true;
                const timestamp = currentTime;
                const progress = Math.min((currentTime / totalDuration) * 100, 100);
                if (progressBarFillAuto) progressBarFillAuto.style.width = `${progress}%`;

                captureFrameAtTime(timestamp, (blob) => {
                    if (!cancelExtractionRequested && blob) {
                        const blobData = { blob, timestamp };
                        screenshotBlobs.push(blobData);
                        const container = createScreenshotElement(blob, timestamp, screenshotBlobs);
                        if (container && screenshotsDiv) screenshotsDiv.appendChild(container);
                        updateImageCount();
                    }

                    frameRequestActive = false;
                    if (!cancelExtractionRequested) {
                        currentTime += interval;
                        requestAnimationFrame(processNextFrame);
                    } else {
                        resetProcessingUI('auto');
                    }
                });
            };

            requestAnimationFrame(processNextFrame);
        };

        const startSmartExtraction = () => {
            if (!video?.src || processingActive) return;
            
            setProcessingUI('autoSmart');
            if (screenshotsDiv) screenshotsDiv.innerHTML = '';
            screenshotBlobs = [];
            updateImageCount();
            contactSheetBlob = null;

            const smartInterval = 1.0;
            const sampleFactor = 8;
            const histThreshold = histThresholdInput ? parseFloat(histThresholdInput.value) : 0.35;
            const pixelThreshold = pixelThresholdInput ? parseFloat(pixelThresholdInput.value) : 35;
            const ssimThreshold = ssimThresholdInput ? parseFloat(ssimThresholdInput.value) : 0.90;

            let currentTime = 0;
            const totalDuration = currentVideoDuration;
            let previousImageData = null;
            let previousHist = null;
            let previousPixelData = null;
            let frameRequestActive = false;

            const processNextSmartFrame = () => {
                if (cancelExtractionRequested || currentTime > totalDuration + 0.1) {
                    resetProcessingUI('autoSmart');
                    return;
                }

                if (frameRequestActive) {
                    requestAnimationFrame(processNextSmartFrame);
                    return;
                }

                frameRequestActive = true;
                const timestamp = currentTime;
                const progress = Math.min((currentTime / totalDuration) * 100, 100);
                if (progressBarFillSmart) progressBarFillSmart.style.width = `${progress}%`;

                captureFrameAtTime(timestamp, (blob) => {
                    if (cancelExtractionRequested) {
                        frameRequestActive = false;
                        resetProcessingUI('autoSmart');
                        return;
                    }

                    if (!blob) {
                        currentTime += smartInterval;
                        frameRequestActive = false;
                        requestAnimationFrame(processNextSmartFrame);
                        return;
                    }

                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    const img = new Image();

                    img.onload = () => {
                        if (cancelExtractionRequested) {
                            frameRequestActive = false;
                            resetProcessingUI('autoSmart');
                            return;
                        }

                        try {
                            tempCanvas.width = img.width;
                            tempCanvas.height = img.height;
                            if (!tempCtx) throw new Error("Could not get temp canvas context");
                            tempCtx.drawImage(img, 0, 0);
                            const currentImageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                            URL.revokeObjectURL(img.src);

                            let captureThisFrame = false;

                            if (!previousImageData) {
                                captureThisFrame = true;
                            } else if (currentImageData) {
                                if (smartAlgorithm === "histogram") {
                                    const currentHist = computeHistogram(currentImageData, sampleFactor);
                                    if (!previousHist || histogramDifference(currentHist, previousHist) >= histThreshold) {
                                        captureThisFrame = true;
                                    }
                                    previousHist = currentHist;
                                } else if (smartAlgorithm === "pixeldiff") {
                                    const diff = computePixelDiff(currentImageData.data, previousPixelData, sampleFactor);
                                    if (diff >= pixelThreshold) {
                                        captureThisFrame = true;
                                    }
                                } else if (smartAlgorithm === "ssim") {
                                    const ssimValue = computeSSIM(previousImageData, currentImageData, sampleFactor);
                                    if (ssimValue < ssimThreshold) {
                                        captureThisFrame = true;
                                    }
                                }
                            }

                            if (captureThisFrame) {
                                const blobData = { blob, timestamp };
                                screenshotBlobs.push(blobData);
                                const container = createScreenshotElement(blob, timestamp, screenshotBlobs);
                                if (container && screenshotsDiv) screenshotsDiv.appendChild(container);
                                updateImageCount();

                                previousImageData = currentImageData;
                                if (smartAlgorithm === 'pixeldiff' && currentImageData) {
                                    previousPixelData = currentImageData.data.slice();
                                }
                                if (smartAlgorithm === 'histogram' && !previousHist && currentImageData) {
                                    previousHist = computeHistogram(currentImageData, sampleFactor);
                                }
                            }

                            if (!cancelExtractionRequested) {
                                currentTime += smartInterval;
                                frameRequestActive = false;
                                requestAnimationFrame(processNextSmartFrame);
                            } else {
                                frameRequestActive = false;
                                resetProcessingUI('autoSmart');
                            }
                        } catch (error) {
                            console.error("[Process Smart] Error processing image data:", error);
                            URL.revokeObjectURL(img.src);
                            if (!cancelExtractionRequested) {
                                currentTime += smartInterval;
                                frameRequestActive = false;
                                requestAnimationFrame(processNextSmartFrame);
                            } else {
                                frameRequestActive = false;
                                resetProcessingUI('autoSmart');
                            }
                        }
                    };
                    img.onerror = () => { console.error("[Process Smart] Failed to load blob into image."); URL.revokeObjectURL(img.src); if (!cancelExtractionRequested) { currentTime += smartInterval; frameRequestActive = false; requestAnimationFrame(processNextSmartFrame); } else { frameRequestActive = false; resetProcessingUI('autoSmart'); } };
                    img.src = URL.createObjectURL(blob);
                });
                requestAnimationFrame(processNextSmartFrame);
            };
            
            requestAnimationFrame(processNextSmartFrame);
        };

        // --- Contact Sheet Preview & Generation ---
        const initContactSheetPreview = (rows = 4, cols = 5) => {
            if (!contactSheetPreviewElement) return;
            contactSheetPreviewElement.innerHTML = ''; // Clear existing
            
            // Set CSS variables for grid layout
            document.documentElement.style.setProperty('--grid-rows', rows);
            document.documentElement.style.setProperty('--grid-cols', cols);
            
            // Reset contactSheetPreviewData array to match grid size
            contactSheetPreviewData = new Array(rows * cols).fill(null);
            
            for (let i = 0; i < rows * cols; i++) {
                const cell = document.createElement('div'); 
                cell.className = 'grid-cell';
                
                // Create img element directly in the cell
                const img = document.createElement('img'); 
                img.alt = `Frame ${i+1}`; // Alt text for accessibility
                cell.appendChild(img);
                cell.dataset.index = i;
                
                // Make cell itself clickable
                cell.addEventListener('click', (e) => {
                    // Only trigger if we're not clicking on a button
                    if (!e.target.closest('.frame-adjust-btn') && cell.dataset.blobUrl) {
                        window.open(cell.dataset.blobUrl, '_blank');
                    }
                });
                
                // Create frame adjustment buttons container
                const btnContainer = document.createElement('div');
                btnContainer.className = 'frame-adjust-buttons';
                
                // Create minus button
                const minusBtn = document.createElement('div');
                minusBtn.className = 'frame-adjust-btn';
                minusBtn.textContent = '-';
                minusBtn.title = 'Go back 1 second';
                minusBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent other click handlers
                    adjustFrameTime(i, -1); // Adjust time by -1 second
                });
                
                // Create plus button
                const plusBtn = document.createElement('div');
                plusBtn.className = 'frame-adjust-btn';
                plusBtn.textContent = '+';
                plusBtn.title = 'Go forward 1 second';
                plusBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent other click handlers
                    adjustFrameTime(i, 1); // Adjust time by +1 second
                });
                
                // Add buttons to container
                btnContainer.appendChild(minusBtn);
                btnContainer.appendChild(plusBtn);
                
                // Add the container to the cell
                cell.appendChild(btnContainer);
                
                // Add highlighting interactions
                cell.addEventListener('mouseenter', () => {
                    cell.classList.add('highlight');
                    const timeInput = contactSheetControlsElement?.querySelector(`.time-input-container[data-index="${i}"]`);
                    if (timeInput) timeInput.classList.add('highlight');
                });
                
                cell.addEventListener('mouseleave', () => {
                    cell.classList.remove('highlight');
                    const timeInput = contactSheetControlsElement?.querySelector(`.time-input-container[data-index="${i}"]`);
                    if (timeInput) timeInput.classList.remove('highlight');
                });
                
                contactSheetPreviewElement.appendChild(cell);
            }
            console.log(`Contact sheet preview grid initialized with ${rows}Ã—${cols} grid.`);
        };
        
        // Function to adjust frame time by a given offset (in seconds)
        const adjustFrameTime = (index, offsetSeconds) => {
            // Get the current time value
            const timeInput = document.getElementById(`timeInput_${index}`);
            if (!timeInput) return;
            
            const currentValue = parseFloat(timeInput.value);
            if (isNaN(currentValue)) return;
            
            // Calculate new time with constraints
            const newValue = Math.max(0, Math.min(
                currentValue + offsetSeconds,
                currentVideoDuration - 0.01
            ));
            
            // Update the value in the input field
            const timeFormatted = document.getElementById(`timeFormatted_${index}`);
            
            if (timeInput) timeInput.value = newValue.toFixed(2);
            if (timeFormatted) timeFormatted.value = formatTime(newValue);
            
            // Trigger update of the frame
            handleFineTuneChange(index, newValue);
        };

        const clearContactSheetPreview = (clearInputs = true) => {
            contactSheetPreviewData.forEach((data, index) => {
                if (data?.blobUrl) URL.revokeObjectURL(data.blobUrl);
                const cell = contactSheetPreviewElement?.querySelector(`.grid-cell[data-index="${index}"]`);
                if (cell) {
                    cell.classList.remove('filled');
                    cell.style.cursor = 'default';
                    const img = cell.querySelector('img');
                    if (img) img.src = '';
                    const overlay = cell.querySelector('.screenshot-overlay');
                    if (overlay) overlay.remove();
                    delete cell.dataset.blobUrl;
                    delete cell.dataset.timestamp;
                }
            });
            
            // Don't use fill as the array length might have changed
            contactSheetPreviewData = new Array(contactSheetPreviewData.length).fill(null);
            
            if (clearInputs) {
                contactSheetControlsElement?.querySelectorAll('.time-input').forEach(input => input.value = '0');
                contactSheetControlsElement?.querySelectorAll('.time-formatted').forEach(input => input.value = '0:00');
            }
            // Hide fine-tuning controls
            if (contactSheetControlsElement) contactSheetControlsElement.style.display = 'none';
            if (fineTuneMessageElement) fineTuneMessageElement.style.display = 'none';
            if (downloadContactSheetButton) downloadContactSheetButton.disabled = true;
            if (previewContactSheetButton) previewContactSheetButton.disabled = true;
            console.log("Contact sheet preview cleared.");
        };

        const updatePreviewCell = (index, blob, timestamp) => {
            const cell = contactSheetPreviewElement?.querySelector(`.grid-cell[data-index="${index}"]`);
            if (!cell || !blob) return;

            // Revoke previous blob URL for this cell if it exists
            const existingData = contactSheetPreviewData[index];
            if (existingData?.blobUrl) {
                URL.revokeObjectURL(existingData.blobUrl);
            }

            // Create a single blob URL for the cell
            const blobUrl = URL.createObjectURL(blob);
            
            // Update image source
            const img = cell.querySelector('img');
            if (img) img.src = blobUrl;
            
            // Store URL directly on the cell for click handler
            cell.classList.add('filled');
            cell.dataset.blobUrl = blobUrl;
            cell.dataset.timestamp = String(timestamp);
            cell.style.cursor = 'pointer';

            // Update or add timestamp overlay
            let overlay = cell.querySelector('.screenshot-overlay');
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.className = 'screenshot-overlay';
                cell.appendChild(overlay);
            }
            overlay.textContent = formatTime(timestamp);

            // Store the data
            contactSheetPreviewData[index] = { blob, timestamp, blobUrl };
            updateImageCount(); // Update clear button state if needed
        };

        const generateContactSheet = async () => {
            if (!video?.src || processingActive) return;
            setProcessingUI('contactSheet');
            contactSheetBlob = null; // Reset final downloadable blob
            if(downloadContactSheetButton) downloadContactSheetButton.disabled = true;

            // Get current grid size
            const activeGridSizeTab = document.querySelector('.grid-size-tab.active');
            const rows = parseInt(activeGridSizeTab?.getAttribute('data-rows') || 4);
            const cols = parseInt(activeGridSizeTab?.getAttribute('data-cols') || 5);
            const numSamples = rows * cols;

            const startPercent = 0.1; const endPercent = 0.9;
            const sampleTimestamps = [];
            const step = (endPercent - startPercent) / (numSamples > 1 ? numSamples - 1 : 1);
            for (let i = 0; i < numSamples; i++) {
                 const percent = startPercent + (i * step);
                 const time = Math.max(0.01, Math.min(percent * currentVideoDuration, currentVideoDuration - 0.01));
                 if (!isNaN(time)) sampleTimestamps.push(time);
                 // Update corresponding input fields if they exist
                 const timeInput = document.getElementById(`timeInput_${i}`);
                 const timeFormatted = document.getElementById(`timeFormatted_${i}`);
                 if (timeInput) timeInput.value = time.toFixed(2);
                 if (timeFormatted) timeFormatted.value = formatTime(time);
            }

            if (sampleTimestamps.length !== numSamples) {
                console.warn(`Calculated ${sampleTimestamps.length} timestamps, expected ${numSamples}`);
                 if (sampleTimestamps.length === 0) {
                     alert("Error: Could not calculate timestamps for contact sheet.");
                     resetProcessingUI('contactSheet');
                     return;
                 }
            }

            // Clear previous preview and data before starting new generation
            clearContactSheetPreview(false); // Keep calculated input values

            try {
                currentSamplingProcess = sampleVideoFrames({
                    videoElement: video, // Use the hidden video for processing
                    sampleTimestamps: sampleTimestamps,
                    outputType: 'blob',
                    useCrop: removeBarsEnabled,
                    processFrameCallback: (blob, timestamp, index) => {
                        if (blob) {
                            updatePreviewCell(index, blob, timestamp); // Update grid cell live
                        } else {
                            console.warn(`Failed blob generation for cell ${index} at ${formatTime(timestamp)}`);
                        }
                    },
                    onProgressCallback: (progress) => {
                        if (progressBarFillContactSheet) progressBarFillContactSheet.style.width = `${progress}%`;
                    },
                    onCompleteCallback: async (collectedData) => {
                        if (cancelExtractionRequested) { console.log("Contact Sheet generation cancelled during sampling."); resetProcessingUI('contactSheet'); return; }
                        console.log("Contact Sheet sampling complete. Generating final image...");
                        if (progressBarFillContactSheet) progressBarFillContactSheet.style.width = `100%`; // Show 100% before final render

                        // Filter out any null entries if frames failed
                        const validPreviewData = contactSheetPreviewData.filter(data => data !== null);

                        if (validPreviewData.length === 0) {
                            throw new Error("Failed to collect any valid frames for final contact sheet render.");
                        }

                        // Render final image onto contactSheetCanvas
                        const cols = 5; const targetAspectRatio = 16 / 9;
                        const targetWidth = 1920; const targetHeight = Math.round(targetWidth / targetAspectRatio);
                        const cellWidth = Math.floor(targetWidth / cols); const cellHeight = Math.floor(targetHeight / Math.ceil(validPreviewData.length / cols));

                        const ctx = contactSheetCanvas.getContext('2d'); if (!ctx) throw new Error("Could not get contact sheet canvas context");
                        contactSheetCanvas.width = targetWidth; contactSheetCanvas.height = targetHeight; ctx.fillStyle = 'black'; ctx.fillRect(0, 0, targetWidth, targetHeight);

                        // Load images from preview data blobs
                        const imageLoadPromises = validPreviewData.map(({ blob }) => new Promise((resolve) => {
                            const img = new Image();
                             img.onload = () => resolve(img); // Keep blob URL until drawn
                             img.onerror = () => { console.warn("Failed to load preview blob into image for final render."); resolve(null); };
                             img.src = URL.createObjectURL(blob); // Use the blob directly
                        }));

                        const loadedImages = await Promise.all(imageLoadPromises);

                        // Draw onto final canvas
                        loadedImages.forEach((img, index) => {
                            if (!img) return;
                            const dataEntry = validPreviewData[index]; // Get corresponding data entry
                            const originalIndex = contactSheetPreviewData.findIndex(d => d === dataEntry); // Find original cell index

                            const row = Math.floor(originalIndex / cols);
                            const col = originalIndex % cols;
                            const drawX = col * cellWidth; const drawY = row * cellHeight;
                            const scale = Math.min(cellWidth / img.width, cellHeight / img.height);
                            const drawWidth = img.width * scale; const drawHeight = img.height * scale;
                            const offsetX = drawX + (cellWidth - drawWidth) / 2; const offsetY = drawY + (cellHeight - drawHeight) / 2;
                            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
                            URL.revokeObjectURL(img.src); // Revoke URL *after* drawing
                        });

                        contactSheetCanvas.toBlob((finalBlob) => {
                            if (finalBlob) { 
                                contactSheetBlob = finalBlob; 
                                console.log("Contact Sheet final image generated.");
                                
                                // Mark the current grid size as completed
                                const activeTab = document.querySelector('.grid-size-tab.active');
                                if (activeTab) {
                                    activeTab.classList.add('completed');
                                    
                                    // Update cache
                                    const rows = parseInt(activeTab.getAttribute('data-rows'));
                                    const cols = parseInt(activeTab.getAttribute('data-cols'));
                                    const cacheKey = `${cols}x${rows}`;
                                    
                                    gridCache[cacheKey] = {
                                        data: [...contactSheetPreviewData],
                                        blob: finalBlob,
                                        completed: true
                                    };
                                }
                            }
                            else { console.error("Failed to generate final contact sheet blob."); contactSheetBlob = null; }
                            resetProcessingUI('contactSheet'); // Finish UI reset
                            // Show fine-tuning controls
                            if (contactSheetControlsElement) contactSheetControlsElement.style.display = 'grid';
                            if (fineTuneMessageElement) fineTuneMessageElement.style.display = 'block';
                        }, 'image/jpeg', 0.9);
                    },
                    onErrorCallback: (error) => { console.error("Error during contact sheet frame sampling:", error); alert(`Error generating contact sheet: ${error.message}`); resetProcessingUI('contactSheet'); }
                });
            } catch (error) { console.error("Failed to start contact sheet generation:", error); alert(`Error starting contact sheet generation: ${error.message}`); resetProcessingUI('contactSheet'); }
        };

        // --- Fine-Tuning Contact Sheet Cell ---
        const handleFineTuneChange = debounce((index, newTime) => {
            if (isNaN(newTime) || newTime < 0) return;
            const clampedTime = Math.min(newTime, currentVideoDuration - 0.01); // Clamp time

            // Update the preview using the main video element
            captureFrameAtTime(clampedTime, (blob) => { // Use the reliable capture function
                 if (blob) {
                     updatePreviewCell(index, blob, clampedTime);
                     
                     // Invalidate the final blob - user needs to regenerate for download
                     contactSheetBlob = null;
                     if (downloadContactSheetButton) downloadContactSheetButton.disabled = true;
                     if (previewContactSheetButton) previewContactSheetButton.disabled = true;
                     if (processContactSheetButton) processContactSheetButton.textContent = 'Update Sheet Image'; // Change button text
                     
                     // Remove completed marker since content has changed
                     const activeTab = document.querySelector('.grid-size-tab.active');
                     if (activeTab) {
                         activeTab.classList.remove('completed');
                         
                         // Update cache to show incomplete state
                         const rows = parseInt(activeTab.getAttribute('data-rows'));
                         const cols = parseInt(activeTab.getAttribute('data-cols'));
                         const cacheKey = `${cols}x${rows}`;
                         
                         if (gridCache[cacheKey]) {
                             gridCache[cacheKey].completed = false;
                             gridCache[cacheKey].blob = null;
                         }
                     }
                 } else {
                     console.warn(`Fine-tuning failed for cell ${index} at ${clampedTime.toFixed(2)}s`);
                 }
            });
        }, 200); // Shorter debounce for more responsive dragging

        // --- Contact Sheet Time Input Generation & Listeners ---
        const generateTimeInputs = (rows = 4, cols = 5) => {
             if (!contactSheetControlsElement) return;
             contactSheetControlsElement.innerHTML = ''; // Clear previous
             
             // Update grid template for the controls
             contactSheetControlsElement.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;

             for (let i = 0; i < rows * cols; i++) {
                 const container = document.createElement('div'); 
                 container.className = 'time-input-container';
                 container.dataset.index = i; // Store index for highlighting

                 const wrapper = document.createElement('div');
                 wrapper.className = 'time-input-wrapper';

                 // Hidden number input to store the actual value
                 const timeInput = document.createElement('input');
                 timeInput.type = 'number';
                 timeInput.className = 'time-input';
                 timeInput.id = `timeInput_${i}`;
                 timeInput.value = contactSheetPreviewData[i]?.timestamp?.toFixed(2) || '0.00';
                 timeInput.min = '0';
                 timeInput.max = currentVideoDuration ? currentVideoDuration.toFixed(2) : '999';
                 timeInput.dataset.index = i;

                 // Visible formatted text input
                 const timeFormatted = document.createElement('input');
                 timeFormatted.type = 'text';
                 timeFormatted.className = 'time-formatted';
                 timeFormatted.id = `timeFormatted_${i}`;
                 timeFormatted.value = formatTime(parseFloat(timeInput.value));
                 timeFormatted.dataset.index = i;
                 timeFormatted.placeholder = "0:00";
                 timeFormatted.setAttribute('draggable', 'false'); // Prevent default drag

                 // Add highlighting interactions
                 // When time input is hovered, highlight both the input and corresponding cell
                 container.addEventListener('mouseenter', () => {
                     container.classList.add('highlight');
                     const cell = contactSheetPreviewElement?.querySelector(`.grid-cell[data-index="${i}"]`);
                     if (cell) cell.classList.add('highlight');
                 });
                 
                 container.addEventListener('mouseleave', () => {
                     container.classList.remove('highlight');
                     const cell = contactSheetPreviewElement?.querySelector(`.grid-cell[data-index="${i}"]`);
                     if (cell) cell.classList.remove('highlight');
                 });

                 // Add event listeners for direct editing of time text
                 timeFormatted.addEventListener('change', (e) => {
                     const index = parseInt(e.target.dataset.index);
                     const parsedSeconds = parseTimeString(e.target.value);
                     updateTimeValue(index, parsedSeconds);
                 });

                 // When user clicks on the text field, allow text editing
                 timeFormatted.addEventListener('focus', (e) => {
                     e.target.select();
                 });

                 // Implement drag-to-adjust functionality
                 let isDragging = false;
                 let startY = 0;
                 let startValue = 0;
                 let sensitivity = 0.05; // Seconds per pixel

                 timeFormatted.addEventListener('mousedown', (e) => {
                     isDragging = true;
                     startY = e.clientY;
                     startValue = parseFloat(timeInput.value);
                     document.body.style.cursor = 'ns-resize';
                     
                     // Add global event listeners to track drag even outside the element
                     document.addEventListener('mousemove', handleMouseMove);
                     document.addEventListener('mouseup', handleMouseUp);
                     
                     // Prevent text selection during drag
                     e.preventDefault();
                 });

                 const handleMouseMove = (e) => {
                     if (!isDragging) return;
                     
                     const deltaY = startY - e.clientY;
                     const newValue = Math.max(0, Math.min(
                         startValue + (deltaY * sensitivity),
                         currentVideoDuration - 0.01
                     ));
                     
                     // Update both inputs
                     timeInput.value = newValue.toFixed(2);
                     timeFormatted.value = formatTime(newValue);
                     
                     // Trigger frame update as user drags
                     handleFineTuneChange(parseInt(timeInput.dataset.index), newValue);
                 };

                 const handleMouseUp = () => {
                     isDragging = false;
                     document.body.style.cursor = '';
                     document.removeEventListener('mousemove', handleMouseMove);
                     document.removeEventListener('mouseup', handleMouseUp);
                 };

                 // Helper function to update time value
                 const updateTimeValue = (index, seconds) => {
                     if (isNaN(seconds)) seconds = 0;
                     const clampedTime = Math.min(Math.max(0, seconds), currentVideoDuration - 0.01);
                     
                     // Update the inputs
                     const numberInput = document.getElementById(`timeInput_${index}`);
                     const formatted = document.getElementById(`timeFormatted_${index}`);
                     
                     if (numberInput) numberInput.value = clampedTime.toFixed(2);
                     if (formatted) formatted.value = formatTime(clampedTime);
                     
                     // Update video and frame
                         if (contactSheetVideo && !contactSheetVideo.seeking) {
                         contactSheetVideo.currentTime = clampedTime;
                     }
                     
                     handleFineTuneChange(index, clampedTime);
                 };

                 wrapper.appendChild(timeInput);
                 wrapper.appendChild(timeFormatted);
                 container.appendChild(wrapper);
                 contactSheetControlsElement.appendChild(container);
             }
        };


        // --- Manual Mode Actions (Remain the same) ---
        if (extractManualButton) extractManualButton.addEventListener('click', () => { /* ... */ if (!manualVideo?.src || manualVideo.readyState < 1 || processingActive || !canvas) return; try { const { type, quality } = getCurrentFormatSettings(); const ctx = canvas.getContext('2d'); if(!ctx) throw new Error("Canvas context not available"); if (removeBarsEnabled && cropData && cropData.cropWidth > 0 && cropData.cropHeight > 0) { canvas.width = cropData.cropWidth; canvas.height = cropData.cropHeight; ctx.drawImage(manualVideo, cropData.cropX, cropData.cropY, cropData.cropWidth, cropData.cropHeight, 0, 0, cropData.cropWidth, cropData.cropHeight); } else { canvas.width = manualVideo.videoWidth; canvas.height = manualVideo.videoHeight; if (canvas.width === 0 || canvas.height === 0) throw new Error("Video dimensions are zero for manual extract."); ctx.drawImage(manualVideo, 0, 0, canvas.width, canvas.height); } canvas.toBlob((blob) => { if (blob) { const tempLink = document.createElement('a'); const url = URL.createObjectURL(blob); tempLink.href = url; const extension = type.split('/')[1] === 'jpeg' ? 'jpg' : type.split('/')[1]; tempLink.download = `quick_frame_${formatTime(manualVideo.currentTime).replace(':','-')}.${extension}`; document.body.appendChild(tempLink); tempLink.click(); document.body.removeChild(tempLink); URL.revokeObjectURL(url); } }, type, quality); } catch(error) { console.error("[Manual Quick Save] Error:", error); alert("An error occurred during Quick Save."); } });
        if (addManualButton) addManualButton.addEventListener('click', () => { /* ... */ if (!manualVideo?.src || manualVideo.readyState < 1 || processingActive || !canvas) return; try { const { type, quality } = getCurrentFormatSettings(); const ctx = canvas.getContext('2d'); if(!ctx) throw new Error("Canvas context not available"); if (removeBarsEnabled && cropData && cropData.cropWidth > 0 && cropData.cropHeight > 0) { canvas.width = cropData.cropWidth; canvas.height = cropData.cropHeight; ctx.drawImage(manualVideo, cropData.cropX, cropData.cropY, cropData.cropWidth, cropData.cropHeight, 0, 0, cropData.cropWidth, cropData.cropHeight); } else { canvas.width = manualVideo.videoWidth; canvas.height = manualVideo.videoHeight; if (canvas.width === 0 || canvas.height === 0) throw new Error("Video dimensions are zero for manual add."); ctx.drawImage(manualVideo, 0, 0, canvas.width, canvas.height); } const timestamp = manualVideo.currentTime; canvas.toBlob((blob) => { if (blob) { const blobData = { blob, timestamp }; manualScreenshotBlobs.push(blobData); const container = createScreenshotElement(blob, timestamp, manualScreenshotBlobs); if(container && screenshotsDiv) screenshotsDiv.appendChild(container); updateImageCount(); } }, type, quality); } catch(error) { console.error("[Manual Add] Error:", error); alert("An error occurred while adding the frame."); } });

        // --- Download & Clear Buttons ---
        if(downloadAllButton) downloadAllButton.addEventListener('click', () => { if (!processingActive) downloadBlobsAsZip(screenshotBlobs, "auto_screenshots"); });
        if(downloadAllSmartButton) downloadAllSmartButton.addEventListener('click', () => { if (!processingActive) downloadBlobsAsZip(screenshotBlobs, "smart_screenshots"); });
        if(downloadManualButton) downloadManualButton.addEventListener('click', () => { if (!processingActive) downloadBlobsAsZip(manualScreenshotBlobs, "manual_screenshots"); });
        
        // Preview Contact Sheet button
        if(previewContactSheetButton) previewContactSheetButton.addEventListener('click', () => {
            if (!processingActive && contactSheetBlob) {
                // Open the image in a new tab
                const url = URL.createObjectURL(contactSheetBlob);
                window.open(url, '_blank');
                // Don't revoke the URL since the browser will need it for the tab
            } else if (!contactSheetBlob) {
                alert("Please generate the contact sheet first or update it after fine-tuning.");
            }
        });
        
        // Download Contact Sheet button
        if(downloadContactSheetButton) downloadContactSheetButton.addEventListener('click', () => { 
            if (!processingActive && contactSheetBlob) { 
                const tempLink = document.createElement('a'); 
                const url = URL.createObjectURL(contactSheetBlob); 
                tempLink.href = url; 
                tempLink.download = `contact_sheet_${uploadedFile?.name.split('.')[0] || 'video'}.jpg`; 
                document.body.appendChild(tempLink); 
                tempLink.click(); 
                document.body.removeChild(tempLink); 
                URL.revokeObjectURL(url); 
            } else if (!contactSheetBlob) { 
                alert("Please generate the contact sheet first or update it after fine-tuning."); 
            } 
        });

        if (clearScreenshotsButton) clearScreenshotsButton.addEventListener('click', () => {
            if (processingActive) return;
            const hasScreenshots = screenshotBlobs.length > 0 || manualScreenshotBlobs.length > 0;
            const hasContactSheetPreview = contactSheetPreviewData.some(d => d !== null);
            if (screenshotsDiv && (hasScreenshots || hasContactSheetPreview)) {
                 if (confirm("Are you sure you want to clear all generated output (screenshots and contact sheet preview)?")) {
                     // Clear regular screenshots
                     screenshotsDiv.querySelectorAll('.screenshot-container').forEach(container => { if (container.dataset.blobUrl) URL.revokeObjectURL(container.dataset.blobUrl); });
                     screenshotsDiv.innerHTML = ''; screenshotBlobs = []; manualScreenshotBlobs = [];
                     
                     // Clear contact sheet preview and data
                     clearContactSheetPreview(true); // Clear inputs too
                     contactSheetBlob = null; // Reset downloadable blob
                     
                     // Clear all completion markers and grid caches
                     document.querySelectorAll('.grid-size-tab').forEach(tab => {
                         tab.classList.remove('completed');
                     });
                     
                     // Reset grid cache
                     gridCache = {
                         '5x4': { data: null, blob: null, completed: false },
                         '4x3': { data: null, blob: null, completed: false },
                         '3x2': { data: null, blob: null, completed: false }
                     };
                     
                     if(downloadContactSheetButton) downloadContactSheetButton.disabled = true;
                     if(processContactSheetButton) processContactSheetButton.textContent = 'Generate/Update Sheet'; // Reset button text
                     updateImageCount();
                 }
            }
        });

        // --- Final Initial Setup ---
        currentMode = document.querySelector('.mode-tab.active')?.getAttribute('data-mode') || 'auto';
        smartAlgorithm = document.querySelector('.smart-tab.active')?.getAttribute('data-algo') || 'histogram';
        document.querySelectorAll(`#${currentMode}Mode input[type="range"]`).forEach(updateSliderBackground);
        resetProcessingUI('all');
        updateDropZoneUI(false, null); // Initial state
        updateImageCount();
        initContactSheetPreview(); // Initialize the grid structure
        generateTimeInputs(); // Generate inputs structure
        
        // Ensure buttons are properly disabled initially
        if(downloadContactSheetButton) downloadContactSheetButton.disabled = true;
        if(previewContactSheetButton) previewContactSheetButton.disabled = true;

        console.log("Frame Capture Studio Initialized.");

      } catch (error) { /* ... error handling ... */ console.error("Error during script execution:", error); const errorDisplay = document.createElement('div'); errorDisplay.textContent = `Initialization Error: ${error.message}. Please refresh or check console (F12).`; errorDisplay.style.cssText = 'color: var(--danger-color); padding: 1rem; background-color: var(--bg-secondary); border: 1px solid var(--danger-color); margin: 1rem; border-radius: var(--border-radius-md);'; document.body.prepend(errorDisplay); }
    }); // End DOMContentLoaded
  </script>

</body>
</html>