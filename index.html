<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pilko Studio</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cairo+Play:wght@400&family=Inter:wght@400;500;600&family=Source+Code+Pro:wght@400&display=swap" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/remixicon@3.5.0/fonts/remixicon.css" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    :root {
      --bg-primary: #0a0f1f;
      --bg-secondary: #161d31;
      --bg-tertiary: #242c44;
      --text-primary: #e0e6f7;
      --text-secondary: #aeb9dd;
      --text-tertiary: #b2b8cf;
      --border-color: #3a4466;
      --border-dashed: #525c8f;

      --accent-primary: #00c6ff;    
      --accent-primary-dark: #00a8ff;
      --accent-secondary: #5eead4;
      --accent-secondary-dark: #2dd4bf;
      --accent-tertiary: #ff8cdc;
      --accent-tertiary-dark: #ff6ac1;
      --accent-interval: #9a6eff;
      --accent-interval-dark: #855bff;
      --danger-color: #f43f5e;
      --danger-color-dark: #e11d48;

      --gradient-primary: linear-gradient(90deg, var(--accent-primary), var(--accent-primary-dark));
      --gradient-secondary: linear-gradient(90deg, var(--accent-secondary), var(--accent-secondary-dark));
      --gradient-tertiary: linear-gradient(90deg, var(--accent-tertiary), var(--accent-tertiary-dark));
      --gradient-interval: linear-gradient(90deg, var(--accent-interval), var(--accent-interval-dark));
      --gradient-danger: linear-gradient(90deg, var(--danger-color), var(--danger-color-dark));
      --gradient-disabled: linear-gradient(90deg, var(--bg-tertiary), var(--bg-tertiary));

      --white: #ffffff;
      --black: #000000;

      --border-radius-sm: 3px;
      --border-radius-md: 6px;
      --border-radius-lg: 10px;
      --border-radius-full: 9999px;
      --content-padding: 1.25rem;
      --side-panel-width: 480px;
      --scrollbar-width: 8px;
      --separator-width: 2px;
      --data-font: 'Source Code Pro', monospace;

      --input-bg: var(--bg-tertiary);
      --text-color: var(--text-primary);
    }

    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    body { background-color: var(--bg-primary); color: var(--text-primary); font-family: 'Inter', "Helvetica Neue", Arial, sans-serif; line-height: 1.5; font-size: 15px; min-height: 100vh; display: flex; overflow: hidden; }
    html, body { margin: 0; padding: 0; width: 100%; height: 100%; }

    ::-webkit-scrollbar { width: var(--scrollbar-width); height: var(--scrollbar-width); }
    ::-webkit-scrollbar-track { background: var(--bg-secondary); border-radius: var(--border-radius-full); }
    ::-webkit-scrollbar-thumb { background-color: var(--bg-tertiary); border-radius: var(--border-radius-full); border: 1px solid var(--bg-secondary); }
    ::-webkit-scrollbar-thumb:hover { background-color: var(--text-secondary); }
    * { scrollbar-width: thin; scrollbar-color: var(--bg-tertiary) var(--bg-secondary); }

    .app-container { flex: 1; display: flex; position: relative; width: 100%; height: 100%; overflow: hidden; }
    .vertical-separator { position: absolute; top: 0; bottom: 0; left: var(--side-panel-width); width: var(--separator-width); background-image: linear-gradient(to bottom, var(--border-dashed) 60%, transparent 40%); background-size: 100% 8px; background-repeat: repeat-y; z-index: 10; pointer-events: none; transition: background-image 0.3s ease; }
    .vertical-separator.loading { background-image: linear-gradient(to bottom, var(--accent-interval) 60%, transparent 40%); background-size: 100% 12px; animation: loadingAnimation 10s linear infinite; }
    .vertical-separator.loading-smart { background-image: linear-gradient(to bottom, var(--accent-secondary) 60%, transparent 40%); background-size: 100% 12px; animation: loadingAnimation 10s linear infinite; }
    .vertical-separator.loading-grid { background-image: linear-gradient(to bottom, var(--accent-tertiary) 60%, transparent 40%); background-size: 100% 12px; animation: loadingAnimation 8s linear infinite; }
    @keyframes loadingAnimation { 0% { background-position: 0 0; } 100% { background-position: 0 100vh; } }

    .side-panel { flex: 0 0 var(--side-panel-width); position: relative; height: 100%; overflow-y: auto; overflow-x: hidden; direction: rtl; background-color: var(--bg-secondary); padding: 0; }
    .content-wrapper { 
      direction: ltr; 
      width: 100%; 
      padding: var(--content-padding); 
      display: flex; 
      flex-direction: column; 
      min-height: 100%;
    }

    .output-column { flex: 1; display: flex; flex-direction: column; background-color: var(--bg-primary); overflow-y: auto; padding: var(--content-padding); }
    #screenshots { display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 0.5rem; align-content: start; }

    .output-column.show-grid #screenshots { display: none; }
    .output-column:not(.show-grid) #contactSheetPreview { display: none; }


    h1 { font-family: 'Cairo Play', sans-serif; text-align: center; padding-bottom: 1rem; font-weight: 400; font-size: 2em; color: var(--white); position: relative; cursor: pointer; user-select: none; transition: color 0.3s ease; }
    h1::after {
      content: '';
      position: absolute;
      left: 0;
      bottom: 0;
      width: 100%;
      height: 2px;
      background-image: linear-gradient(to right, var(--accent-primary) 50%, transparent 50%);
      background-size: 20px 2px;
      background-repeat: repeat-x;
      opacity: 0;
      transition: opacity 0.4s ease;
      z-index: 1;
    }
    h1:hover {
      color: var(--accent-primary);
      text-shadow: 0 0 10px rgba(0, 198, 255, 0.3);
      margin: 0 0.5rem;
    }
    h1:hover::after {
      opacity: 1;
      animation: moveLines 1.5s linear infinite;
      margin-bottom: -0.1rem;
    }
    h1:active { transform: scale(0.98); }
    @keyframes moveLines {
      0% { background-position: 0px; }
      100% { background-position: 40px; }
    }

    #dropZone {
      border: 2px dashed var(--border-dashed);
      border-radius: var(--border-radius-lg);
      background: linear-gradient(145deg, var(--bg-tertiary), var(--bg-secondary));
      cursor: pointer;
      transition: background 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease, padding 0.3s ease;
      margin-bottom: 1rem;
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.15);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 1.5rem 1rem;
      position: relative;
      overflow: hidden;
    }

    #dropZone::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-image: var(--dropzone-bg-image, none);
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      opacity: 0;
      transition: opacity 0.5s ease;
      z-index: 0;
      min-height: 100%;
    }

    #dropZone.has-bg-image::before {
      opacity: 0.2;
    }

    #dropZone > * {
      position: relative;
      z-index: 1;
    }

    #dropZone:hover { border-color: var(--text-primary); }
    #dropZone #uploadIcon { color: var(--text-tertiary); transition: color 0.3s ease, transform 0.3s ease; display: block; }
    #dropZone:hover #uploadIcon { color: var(--text-primary); transform: scale(1.1); }
    #dropZone #uploadIcon svg { width: 50px; height: 50px; fill: currentColor; }
    
    #spinnerIcon { width: 40px; height: 40px; fill: currentColor; }
    #dropZone #dropZoneText { font-size: 0.95rem; color: var(--text-tertiary); display: block; }
    #dropZone #loadedFileInfo { display: none; }
    #dropZone.file-loaded { padding: 1rem 1.25rem 0.75rem; align-items: stretch; text-align: left; justify-content: flex-start; cursor: default; }
    #dropZone.file-loaded #uploadIcon, #dropZone.file-loaded #dropZoneText { display: none; }
    #dropZone.file-loaded #loadedFileInfo { display: block; width: 100%; }
    #loadedFileName { font-size: 0.95rem; font-weight: 500; color: var(--text-primary); margin-bottom: 0; display: flex; align-items: center; word-break: break-all; flex: 1; margin-right: 1rem; }
    #loadedFileName::before { content: '\EF80'; font-family: 'remixicon'; color: var(--text-primary); font-size: 1.2em; margin-right: 0.5rem; font-weight: normal; }

    .file-name-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.5rem; width: 100%; }

    #loadedFileStats { font-size: 0.85rem; color: var(--text-tertiary); }
    #loadedFileStats .info-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.3rem; white-space: nowrap; }
    #loadedFileStats .info-row:last-child { margin-bottom: 0; }
    #loadedFileStats .info-label { font-weight: 500; color: var(--text-secondary); margin-right: 1rem; }
    #loadedFileStats .info-value {
        font-family: var(--data-font);
        text-align: right;
        color: var(--text-primary);
        font-weight: 500;
        font-size: 0.9rem;
    }
    #loadedFileStats .leader { display: none; }

    #buttonRow { display: flex; align-items: center; justify-content: center; gap: 0.5rem; margin-top: 1rem; }
    
    #initialSelectFileButton { padding: 0.6rem 1.5rem; font-size: 0.9rem; background-color: rgba(255, 255, 255, 0.05); border: 1px solid var(--border-color); border-radius: var(--border-radius-md); color: var(--text-primary); cursor: pointer; transition: background-color 0.2s, border-color 0.2s, color 0.2s, box-shadow 0.2s; font-weight: 500; }
    #initialSelectFileButton:hover { background-color: rgba(255, 255, 255, 0.1); border-color: var(--text-tertiary); box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1); }

    #orText { color: var(--text-tertiary); font-size: 0.9rem; }
    
    #tryExampleButton { padding: 0.6rem 1.5rem; font-size: 0.9rem; background-color: rgba(255, 255, 255, 0.05); border: 1px solid var(--border-color); border-radius: var(--border-radius-md); color: var(--text-primary); cursor: pointer; transition: background-color 0.2s, border-color 0.2s, color 0.2s, box-shadow 0.2s; font-weight: 500; }
    #tryExampleButton:hover { background-color: rgba(255, 255, 255, 0.1); border-color: var(--text-tertiary); box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1); }

    #selectFileButton {
      font-size: 0.8rem;
      padding: 0.4rem 1rem;
      background-color: transparent;
      border: 1px solid var(--text-primary);
      color: var(--text-primary);
      border-radius: var(--border-radius-md);
      cursor: pointer;
      transition: background-color 0.2s;
    }
    #selectFileButton:hover { background-color: var(--text-primary); color: var(--bg-primary); }

    #dropZone.file-loaded #buttonRow { display: none; }

    #videoInput { display: none; }

    #imageCountDisplay { text-align: center; font-size: 0.9rem; color: var(--text-tertiary); margin-top: 1.5rem; margin-bottom: 0.75rem; padding: 0.4rem 0; background-color: var(--bg-tertiary); border-radius: var(--border-radius-md); border: 1px solid var(--border-color); flex-shrink: 0; }
    #imageCountValue {
        font-weight: 600;
        font-family: var(--data-font);
        margin-left: 0.5ch;
    }
    #imageCountValue.interval-mode { color: var(--accent-interval); }
    #imageCountValue.smart-mode { color: var(--accent-secondary); }
    #imageCountValue.manual-mode { color: var(--accent-primary); }
    #imageCountValue.grid-mode { color: var(--accent-tertiary); }

    .setting-row { 
        display: flex; 
        flex-direction: column;
        align-items: stretch; 
        flex-wrap: wrap; 
        margin-bottom: 1rem; 
        background-color: var(--bg-tertiary); 
        padding: 0.8rem 1rem; 
        border-radius: var(--border-radius-md); 
        border: 1px solid var(--border-color); 
        flex-shrink: 0; 
        gap: 0.5rem;
    }
    .setting-control-group {
        display: flex;
        align-items: center;
        justify-content: space-between;
        width: 100%;
        margin-bottom: 0.5rem;
    }
    .setting-control-group:last-child {
        margin-bottom: 0;
    }
    .setting-label { 
        flex: 1; 
        font-size: 0.9rem; 
        color: var(--text-primary); 
        font-weight: 500; 
        margin-right: 0.8rem; 
        margin: 0; 
        cursor: default; 
        display: inline-flex; 
        align-items: center; 
    }
    .info-icon-inline { font-size: 1.1em; color: var(--text-tertiary); cursor: help; }

    .toggle-row { display: flex; align-items: center; justify-content: space-between; }
    .toggle-label { display: flex; align-items: center; gap: 0.5rem; }
    .toggle-switch { position: relative; display: inline-block; width: 48px; height: 24px; flex-shrink: 0; margin-left: auto; /* Push toggle to the right */ }
    .toggle-input { opacity: 0; width: 0; height: 0; }
    .toggle-label-switch { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--bg-primary); transition: .3s; border-radius: 24px; border: 1px solid var(--border-color); }
    .toggle-label-switch:before { position: absolute; content: ""; height: 18px; width: 18px; left: 2px; bottom: 2px; background-color: var(--text-tertiary); transition: .3s; border-radius: 50%; box-shadow: 0 1px 2px rgba(0,0,0,0.15); }
    .toggle-input:checked + .toggle-label-switch { background: var(--text-tertiary); border-color: transparent; }
    .toggle-input:checked + .toggle-label-switch:before { transform: translateX(24px); background-color: var(--white); }

    #format-options-row { display: flex; }
    .format-controls { display: flex; align-items: center; }
    
    .corner-position-btn {
        background-color: var(--bg-tertiary);
        border-color: var(--border-color);
        color: var(--text-primary);
        border:1px solid var(--border-color);
        border-radius: var(--border-radius-sm);
        padding: 0.15rem;
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--text-secondary);
    }
    
    .corner-position-btn:hover {
        background: var(--border-color);
        color: var(--text-primary);
    }
    
    .corner-position-btn svg {
        transition: transform 0.2s ease;
    }


    #jpegQualityGlobalRow, #webpQualityGlobalRow {
        display: none;
        flex-basis: 100%;
        background-color: transparent;
        border: none;
        margin-bottom: 0;
    }

    .setting-group-title {
        font-size: 0.9rem;
        color: var(--text-primary);
        font-weight: 500;
        margin-bottom: 0.5rem;
        flex-basis: 100%;
    }

    .segmented-controls { display: flex; border-radius: var(--border-radius-md); overflow: hidden; background-color: var(--bg-tertiary); margin-bottom: 1rem; border: 1px solid var(--border-color); flex-shrink: 0; width: 100%; }
    .segmented-controls button { flex: 1; background-color: transparent; text-align: center; border: none; padding: 0.65rem 0.5rem; color: var(--text-tertiary); cursor: pointer; transition: background 0.2s, color 0.3s, box-shadow 0.2s; font-family: inherit; font-size: 0.85rem; font-weight: 500; border-left: 1px solid var(--border-color); position: relative; white-space: nowrap; }
    .segmented-controls button:first-child { border-left: none; }
    .segmented-controls button:hover:not(.active) { background-color: var(--border-color); color: var(--text-primary); }
    .mode-tabs button[data-mode="auto"].active { background: var(--gradient-interval); }
    .mode-tabs button[data-mode="autoSmart"].active { background: var(--gradient-secondary); }
    .mode-tabs button[data-mode="manual"].active { background: var(--gradient-primary); }
    .mode-tabs button[data-mode="contactSheet"].active { background: var(--gradient-tertiary); }
    .mode-tabs button.active { color: var(--bg-primary); font-weight: 600; box-shadow: inset 0 1px 3px rgba(0,0,0,0.2); }
    .smart-algo-tabs button.active { background: var(--gradient-secondary); color: var(--bg-primary); font-weight: 600; box-shadow: inset 0 1px 2px rgba(0,0,0,0.15); }
    .grid-size-tabs button.active { background: var(--gradient-tertiary); color: var(--bg-primary); font-weight: 600; box-shadow: inset 0 1px 2px rgba(0,0,0,0.15); }
    .grid-size-tabs button {
        position: relative;
        padding-right: 24px;
    }
    .grid-size-tabs button.completed::after {
        content: "✓";
        position: absolute;
        right: 8px;
        top: 50%;
        transform: translateY(-50%);
        font-weight: bold;
        color: var(--accent-tertiary);
    }
    .grid-size-tabs button.active.completed::after {
        color: var(--bg-primary);
    }
    .smart-algo-tabs, .grid-size-tabs, .timecode-size-tabs { margin-bottom: 0.8rem; }
    .smart-algo-tabs button, .grid-size-tabs button, .timecode-size-tabs button { padding: 0.5rem 0.5rem; font-size: 0.8rem; }
    .timecode-size-tabs button.active { background: var(--text-secondary); color: var(--bg-primary); font-weight: 600; box-shadow: inset 0 1px 2px rgba(0,0,0,0.15); }

    .settings-panel { flex-grow: 1; overflow-y: auto; padding-right: 5px; }
    .mode-content > div { display: none; }
    .mode-content > div.active { display: block; }

    .slider-row { display: flex; align-items: center; gap: 1rem; margin-bottom: 0; padding-bottom: 0.75rem; flex-wrap: wrap; }
    .slider-label, h3.slider-label { padding-left:1em; text-align: left; font-size: 0.85rem; color: var(--text-tertiary); flex-shrink: 0; margin: 0; font-weight: normal; }
    .slider-wrapper { flex: 1; display: flex; align-items: center; gap: 0.8rem; min-width: 150px; }
    .value-display {
        font-weight: 500;
        min-width: 40px;
        text-align: right;
        font-family: var(--data-font);
        color: var(--text-primary);
        font-size: 0.9rem;
    }
    .value-input {
        width: 150px;
        padding: 0.35rem 1rem;
        background-color: var(--bg-secondary);
        color: var(--text-primary);
        border: 1px solid var(--border-color);
        border-radius: var(--border-radius-sm);
        font-size: 0.9rem;
        font-family: inherit;
    }

    input[type="range"] { -webkit-appearance: none; -moz-appearance: none; appearance: none; width: 100%; height: 6px; background: var(--text-tertiary); border-radius: var(--border-radius-full); outline: none; cursor: pointer; transition: background 0.2s; }
    input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 18px; height: 18px; border-radius: 50%; background: var(--white); border: none; box-shadow: 0 1px 4px rgba(0, 0, 0, 0.25); transition: transform 0.1s ease-out; }
    input[type="range"]::-moz-range-thumb { width: 18px; height: 18px; border-radius: 50%; background: var(--white); border: none; box-shadow: 0 1px 4px rgba(0, 0, 0, 0.25); transition: transform 0.1s ease-out; }
    input[type="range"]:active::-webkit-slider-thumb, input[type="range"]:active::-moz-range-thumb { transform: scale(1.1); }

    .button-group { display: flex; flex-direction: column; gap: 0.5rem; }
    .action-button { width: 100%; padding: 0.75rem 1.5rem; font-size: 0.95rem; border: none; border-radius: var(--border-radius-md); color: var(--bg-primary); cursor: pointer; transition: background 0.3s ease, opacity 0.2s, color 0.2s, box-shadow 0.2s ease; text-align: center; font-weight: 600; background-size: 200% auto; box-shadow: 0 3px 5px rgba(0, 0, 0, 0.1); display: inline-flex; align-items: center; justify-content: center;}
    .action-button:hover:enabled { box-shadow: 0 5px 10px rgba(0, 0, 0, 0.15); background-position: right center; }
    .action-button:active:enabled { transform: scale(0.98); box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); }
    .action-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      box-shadow: none;
      filter: saturate(0.4) brightness(0.85);
    }
    /* Icon Styles */
    .action-button i, .secondary-button i {
      margin-left: 0.5em;
      vertical-align: middle;
      font-size: 1.1em;
      line-height: 1;
    }
     .action-button.secondary-button i {
         color: inherit;
     }

     #addManualButton i, #extractManualButton i, #clearScreenshotsButton .delete-icon-svg {
         margin-right: 0;
         margin-left: 0.5em;
     }
      #addManualButton, #extractManualButton {
        padding-left: 1.2rem;
      }

    #previewContactSheetButton i { color: var(--accent-tertiary); }
    #previewContactSheetButton:hover:enabled i { color: var(--accent-tertiary-dark); }
    #downloadContactSheetButton i { color: var(--accent-tertiary); }
    #downloadContactSheetButton:hover:enabled i { color: var(--accent-tertiary-dark); }
    #downloadManualButton i { color: var(--accent-primary); }
    #downloadManualButton:hover:enabled i { color: var(--accent-primary-dark); }
    #downloadAllButton i { color: var(--accent-interval); }
    #downloadAllButton:hover:enabled i { color: var(--accent-interval-dark); }
    #downloadAllSmartButton i { color: var(--accent-secondary); }
    #downloadAllSmartButton:hover:enabled i { color: var(--accent-secondary-dark); }

    .secondary-button:disabled i { opacity: 0.6; }


    #processButton, #intervalModeButtons .action-button:not(.secondary-button) { background: var(--gradient-interval); }
    #processSmartButton, #smartModeButtons .action-button:not(.secondary-button) { background: var(--gradient-secondary); }
    #processContactSheetButton, #contactSheetModeButtons .action-button:not(.secondary-button) { background: var(--gradient-tertiary); }
    #addManualButton, #manualModeButtons .action-button:not(.secondary-button) { background: var(--gradient-primary); }

    .action-button.cancel-active { background: var(--gradient-danger) !important; color: var(--white) !important; }
    .action-button.cancel-active:hover:enabled { background: var(--gradient-danger) !important; filter: brightness(1.1); }

    #downloadAllButton, #downloadAllSmartButton, #downloadManualButton, #downloadContactSheetButton { background: transparent; border: 1px solid var(--accent-tertiary); color: var(--accent-tertiary); padding: calc(0.75rem - 1px) calc(1.5rem - 1px); box-shadow: none; }
    #downloadAllButton { border-color: var(--accent-interval); color: var(--accent-interval); }
    #downloadAllButton:hover:enabled { background-color: rgba(154, 110, 255, 0.1); border-color: var(--accent-interval-dark); color: var(--accent-interval-dark); }
    #downloadAllSmartButton { border-color: var(--accent-secondary); color: var(--accent-secondary); }
    #downloadAllSmartButton:hover:enabled { background-color: rgba(45, 212, 191, 0.1); border-color: var(--accent-secondary-dark); color: var(--accent-secondary-dark); }
    #downloadManualButton { border-color: var(--accent-primary); color: var(--accent-primary); }
    #downloadManualButton:hover:enabled { background-color: rgba(0, 198, 255, 0.1); border-color: var(--accent-primary-dark); color: var(--accent-primary-dark); }
    #downloadContactSheetButton { border-color: var(--accent-tertiary); color: var(--accent-tertiary); }
    #downloadContactSheetButton:hover:enabled { background-color: rgba(255, 106, 193, 0.1); border-color: var(--accent-tertiary-dark); color: var(--accent-tertiary-dark); box-shadow: none; }

    #downloadAllButton:disabled { background: transparent; border-color: var(--accent-interval); color: var(--accent-interval); opacity: 0.5; box-shadow: none; }
    #downloadAllSmartButton:disabled { background: transparent; border-color: var(--accent-secondary); color: var(--accent-secondary); opacity: 0.5; box-shadow: none; }
    #downloadManualButton:disabled { background: transparent; border-color: var(--accent-primary); color: var(--accent-primary); opacity: 0.5; box-shadow: none; }
    #downloadContactSheetButton:disabled { background: transparent; border-color: var(--accent-tertiary); color: var(--accent-tertiary); opacity: 0.5; box-shadow: none; }

    .action-icon-button {
        border-radius: var(--border-radius-md);
        cursor: pointer;
        transition: background-color 0.2s, color 0.2s, border-color 0.2s, box-shadow 0.2s, opacity 0.2s;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-weight: 500;
        border: 1px solid;
        box-shadow: 0 1px 4px rgba(0,0,0,0.10);
    }
    .action-icon-button:disabled {
        opacity: 0.4;
        cursor: not-allowed;
        box-shadow: none;
    }
    .action-icon-button--delete {
        background-color: rgba(244, 63, 94, 0.1);
        color: var(--danger-color);
        border-color: var(--danger-color);
        box-shadow: 0 1px 4px rgba(244, 63, 94, 0.1);
    }
    .action-icon-button--delete:hover:enabled {
        background-color: var(--danger-color);
        color: var(--black);
        box-shadow: none;
    }
    .action-icon-button--delete:disabled {
        background-color: rgba(244, 63, 94, 0.1);
        color: var(--danger-color);
        border-color: var(--danger-color);
    }
    .action-icon-button--download {
        background-color: rgba(154, 110, 255, 0.08);
        color: var(--text-tertiary);
        border-color: var(--text-tertiary);
        box-shadow: 0 1px 4px rgba(154, 110, 255, 0.10);
    }
    .action-icon-button--download:hover:enabled {
        background-color: var(--text-primary);
        color: var(--black);
        border-color: var(--text-tertiary);
    }
    .action-icon-button--download:disabled {
        background-color: rgba(154, 110, 255, 0.08);
        color: var(--text-tertiary);
        border-color: var(--text-primary);
    }

    #clearScreenshotsButton {
        margin-top: 0;
        padding: 0.6rem 1rem 0.6rem 0.8rem;
        font-size: 0.85rem;
        width: auto;
        flex-shrink: 0;
    }
    #clearScreenshotsButton .delete-icon-svg {
        margin-right: 0.5em;
    }

    .delete-icon-svg {
      width: 1.1em;
      height: 1.1em;
      fill: currentColor;
      vertical-align: middle;
    }

    #manualVideo {
        width: 100%;
        border-radius: var(--border-radius-lg);
        background-color: var(--black);
        margin-bottom: 1rem;
        border: 1px solid var(--border-color);
        display: block;
        min-height: 200px;
    }

    #addManualButton i {
      display: inline-block;
    }

    #addManualButton.cutting i {
      animation: cut-animation 0.3s ease-in-out;
    }

    /* Scissors cutting animation */
    @keyframes cut-animation {
      0% { transform: rotate(0) scaleY(1); }
      40% { transform: rotate(-20deg) scaleY(-1) scale(1.05); }
      100% { transform: rotate(0) scaleY(1); }
    }

    #addManualButton:hover {
      box-shadow: 0 5px 10px rgba(0, 0, 0, 0.15);
      background-position: right center;
    }
    #addManualButton:active {
      transform: scale(0.98);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .progress-bar-container { width: 100%; height: 2rem ; background-color: var(--bg-tertiary); overflow: hidden; margin-top: 0.8rem; display: none; }
    .progress-bar-fill { height: 100%; width: 0%; border-radius: var(--border-radius-full); transition: width 0.3s ease-out; }
    #progressBarAuto .progress-bar-fill { background: var(--gradient-interval); }
    #progressBarSmart .progress-bar-fill { background: var(--gradient-secondary); }
    #progressBarContactSheet .progress-bar-fill { background: var(--gradient-tertiary); }

    .screenshot-container {
        position: relative;
        overflow: hidden;
        border-radius: var(--border-radius-md);
        border: 1px solid var(--border-color);
        background-color: var(--bg-secondary);
        transition: box-shadow 0.3s ease, border-color 0.3s ease;
    }
    .screenshot-container:hover {
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        border-color: var(--accent-primary);
    }
    .screenshot-container .img-container {
        display: block;
        line-height: 0;
    }
    .screenshot-container img {
        display: block;
        width: 100%;
        height: auto;
        object-fit: cover;
        border-radius: var(--border-radius-md);
        animation: fadeIn 0.5s ease-in-out;
    }
    .screenshot-overlay, .screenshot-container .lightbox-delete-btn, .screenshot-container .thumbnail-download-btn {
        position: absolute;
        opacity: 0;
        transition: opacity 0.2s ease-in-out;
    }

    .screenshot-container:hover .screenshot-overlay,
    .screenshot-container:hover .lightbox-delete-btn,
    .screenshot-container:hover .thumbnail-download-btn {
        opacity: 1;
        pointer-events: auto;
    }

    .screenshot-overlay {
        left: 0;
        bottom: 0;
        right: 0;
        background: linear-gradient(to top, rgba(0,0,0,0.7), transparent);
        color: var(--white);
        font-size: 0.8rem;
        padding: 0.5rem;
        text-align: right;
        font-family: 'Source Code Pro', monospace;
        pointer-events: none;
    }

    .lightbox-delete-btn {
        padding: 0.5rem 0.75rem;
        font-size: 16px;
        margin-right: 10px;
    }

    .screenshot-container .lightbox-delete-btn {
        position: absolute;
        bottom: 6px;
        left: 6px;
        padding: 0.3rem 0.5rem;
        font-size: 14px;
        opacity: 0;
        width: auto;
        height: auto;
        min-width: 28px;
        min-height: 28px;
    }
     .screenshot-container .lightbox-delete-btn .delete-icon-svg {
         width: 1em;
         height: 1em;
     }

    @keyframes fadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }

    #video, #canvas, #contactSheetCanvas { display: none; }
    #frameCanvas { display: none; }

    #contactSheetVideo { width: 100%; border-radius: var(--border-radius-lg); background-color: var(--black); margin-bottom: 1rem; aspect-ratio: 16 / 9; border: 1px solid var(--border-color); }
    .fine-tune-message { color: var(--accent-tertiary); font-size: 0.85rem; margin: 0.5rem 0 1rem; text-align: center; display: none; }
    .grid-controls { display: grid; grid-template-columns: repeat(5, 1fr); gap: 0.2rem; margin-bottom: 1rem; }
    .time-input-container { display: flex; flex-direction: column; gap: 0.3rem; position: relative; }
    .time-input-wrapper {
        position: relative;
        display: inline-block;
        height: 2rem;
    }
    
    /* Manual mode time input wrapper - specific width for manual controls */
    #manualMode .time-input-container .time-input-wrapper {
        width: 120px;
    }
    .time-input {
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        opacity: 0;
        z-index: 1;
        pointer-events: none;
    }
    .time-formatted {
        width: 100%;
        height: 100%;
        font-family: monospace;
        text-align: center;
        position: relative;
        padding: 0.4rem;
        border-radius: var(--border-radius-sm);
        border: 1px solid var(--border-color);
        background-color: var(--input-bg);
        color: var(--text-color);
        box-sizing: border-box;
        cursor: ns-resize;
        user-select: none;
        transition: background-color 0.15s ease;
    }
    .time-formatted:hover {
        background-color: var(--bg-tertiary);
        border-color: var(--accent-primary);
        cursor: ns-resize;
    }
    .time-formatted:focus {
        outline: none;
        border-color: var(--accent-tertiary);
    }
    .time-formatted::after {
        content: "↕";
        position: absolute;
        right: 0.5rem;
        top: 50%;
        transform: translateY(-50%);
        color: var(--text-tertiary);
        font-size: 0.9rem;
        opacity: 0.6;
    }
    .time-formatted:hover::after {
        opacity: 1;
        color: var(--accent-primary);
    }

    #contactSheetPreview {
        width: 100%;
        margin: 0 auto;
        display: grid;
        grid-template: repeat(var(--grid-rows, 4), 1fr) / repeat(var(--grid-cols, 5), 1fr);
        gap: 2px;
        overflow: hidden;
        background-color: var(--border-color);
        border: 1px solid var(--border-color);
        border-radius: var(--border-radius-md);
    }
    .grid-cell {
        background-color: var(--bg-secondary);
        position: relative;
        overflow: hidden;
        border: none;
        display: flex;
        width: 100%;
        height: 100%;
        min-height: 70px;
        align-items: center;
        justify-content: center;
    }
    .grid-cell.filled {
        cursor: pointer;
    }
    .grid-cell img {
        max-width: 100%;
        min-width: none;
        max-height: 100%;
        min-height: max-content;
        object-fit: contain;
        display: block;
        opacity: 0;
        transition: opacity 0.3s ease;
    }
    .grid-cell.filled img {
        opacity: 1;
        animation: fadeIn 0.3s ease-in-out;
    }
    .grid-cell .screenshot-overlay {
        opacity: 0;
        transition: opacity 0.2s ease-in-out;
        pointer-events: none;
        position: absolute;
    }
    .grid-cell:hover .screenshot-overlay { opacity: 1; pointer-events: auto; }
    .grid-label { color: var(--accent-tertiary); font-size: 0.9rem; font-weight: 500; margin: 1rem 0 0.5rem; text-align: center; width: 100%; }

    .time-input-container .time-formatted {
        transition: border-color 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease;
    }
    .time-input-container.highlight .time-formatted {
        border-color: var(--accent-tertiary);
        box-shadow: 0 0 0 2px rgba(255, 140, 220, 0.3);
        background-color: rgba(255, 140, 220, 0.05);
    }
    .grid-cell {
        transition: outline 0.2s ease;
    }
    .grid-cell.highlight {
        outline: 2px solid var(--accent-tertiary);
        outline-offset: -1px;
        position: relative;
        z-index: 2;
    }
     .grid-cell.input-hover-highlight {
        outline: 2px solid var(--accent-tertiary);
        outline-offset: -1px;
        position: relative;
        z-index: 1;
     }
    .grid-cell.highlight img {
        opacity: 1;
    }
    .frame-adjust-buttons {
        position: absolute;
        bottom: 8px;
        left: 50%;
        transform: translateX(-50%);
        display: none;
        gap: 2px;
        z-index: 5;
        background: transparent;
        width: auto;
        justify-content: center;
    }

    .grid-cell.highlight:not(.input-hover-highlight) .frame-adjust-buttons {
        display: flex;
    }
    
    .screenshot-container:hover .frame-adjust-buttons {
        display: flex;
    }

    .frame-adjust-btn {
        width: auto;
        min-width: 28px;
        height: 28px;
        border-radius: 4px;
        background-color: rgba(0, 0, 0, 0.75);
        color: white;
        border: 1px solid rgba(255, 255, 255, 0.6);
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 0.3em;
        padding: 0 0.4em;
        font-weight: bold;
        font-size: 16px;
        cursor: pointer;
        transition: background-color 0.15s ease, transform 0.15s ease;
        user-select: none;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.4);
    }
    .frame-adjust-btn:hover {
        background-color: var(--border-color);
    }
    .frame-adjust-btn:active {
        background-color: var(--border-dashed);
    }
    .frame-adjust-btn i {
        vertical-align: middle;
    }
    .frame-adjust-btn .icon-flipped {
        transform: scaleX(-1);
    }


    #contactSheetMode .video-container, #contactSheetMode #contactSheetVideo {
        display: none;
    }
    .disclaimer-note {
        text-align: center;
        color: var(--text-tertiary);
        font-style: italic;
        margin: 1rem 0 0.5rem;
        font-size: 0.85rem;
        padding: 0.3rem 0.6rem;
        background-color: rgba(36, 44, 68, 0.5);
        border-radius: var(--border-radius-sm);
    }
    #largeGridMessage {
        display: none;
    }


    .sticky-button-container {
        position: sticky;
        bottom: 0;
        background-color: var(--bg-secondary);
        margin-top: auto;
        border-top: 1px solid var(--border-color);
        z-index: 10;
        display: flex;
        flex-direction: column;
    }

    .sticky-button-container .button-group {
        display: flex;
        flex-direction: column;
        margin-bottom: 0.4rem;
        margin-top: 1rem;
    }

    .status-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 0.5rem;
        margin-top: 0.4rem;
    }

    .status-row #imageCountDisplay {
        flex: 1;
        margin-top: 0;
        margin-bottom: 0;
    }

    .status-row .info-icon {
        margin-left: 1rem;
        color: var(--text-tertiary);
        cursor: pointer;
        transition: color 0.2s ease;
        font-size: 1.1rem;
    }

    .status-row .info-icon:hover {
        color: var(--accent-primary);
    }

    .status-row #toolInfoButton {
        background-color: var(--bg-secondary);
        border: 1px solid var(--border-color);
        color: var(--text-tertiary);
        border-radius: var(--border-radius-md);
        cursor: pointer;
        padding: 0.45rem;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 500;
        font-size: 0.9rem;
        min-width: 2.2rem;
        aspect-ratio: 1;
    }

    .status-row #toolInfoButton:hover {
        background-color: var(--bg-tertiary);
        border-color: var(--text-tertiary);
        color: var(--text-primary);
    }

    .status-row #toolInfoButton:active {
        transform: scale(0.95);
    }

    .status-row #toolInfoButton i {
        font-size: 1.1rem;
    }

    /* Naming Settings Button Styling */
    #namingSettingsButton,
    #namingSettingsButtonSmart,
    #namingSettingsButtonManual {
        min-width: 2.2rem;
        aspect-ratio: 1;
        padding: 0.45rem;
        background-color: var(--bg-secondary);
        border: 1px solid var(--border-color);
        color: var(--text-tertiary);
    }

    #namingSettingsButton:hover:enabled,
    #namingSettingsButtonSmart:hover:enabled,
    #namingSettingsButtonManual:hover:enabled {
        background-color: var(--bg-tertiary);
        border-color: var(--text-tertiary);
        color: var(--text-primary);
    }

    #namingSettingsButton i,
    #namingSettingsButtonSmart i,
    #namingSettingsButtonManual i {
        font-size: 1.1rem;
    }

    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.75);
        z-index: 1000;
        display: flex;
        justify-content: center;
        align-items: center;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease, visibility 0.3s ease;
    }

    .modal-overlay.active {
        opacity: 1;
        visibility: visible;
    }

    .info-box-content {
        background: var(--bg-secondary);
        border-radius: var(--border-radius-lg);
        width: 500px;
        max-height: 90vh;
        overflow-y: auto;
        padding: 1.5rem;
        position: relative;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
        transform: translateY(20px);
        transition: transform 0.3s ease;
    }

    .modal-overlay.active .info-box-content {
        transform: translateY(0);
    }

    .modal-close {
        position: absolute;
        top: 1rem;
        right: 1rem;
        color: var(--text-tertiary);
        background: none;
        border: none;
        font-size: 1.5rem;
        cursor: pointer;
        transition: color 0.2s ease;
    }

    .modal-close:hover {
        color: var(--accent-primary);
    }

    .modal-title {
        font-size: 1.5rem;
        margin-bottom: 1rem;
        color: var(--text-primary);
        padding-bottom: 0.75rem;
    }

    .modal-body {
        color: var(--text-tertiary);
        line-height: 1.6;
    }

    .modal-body p {
        margin-bottom: 1rem;
    }

    .modal-body h3 {
        color: var(--text-primary);
        margin: 1.5rem 0 0.5rem;
        font-size: 1.1rem;
    }

    .modal-body ul {
        padding-left: 1.5rem;
        margin-bottom: 1rem;
    }

     .modal-body a {
        color: var(--accent-primary);
        text-decoration: none;
        transition: color 0.2s ease;
     }
      .modal-body a:hover {
         color: var(--accent-primary-dark);
         text-decoration: underline;
      }


    .sticky-button-container #progressBarAuto,
    .sticky-button-container #progressBarSmart,
    .sticky-button-container #progressBarContactSheet {
        margin-top: 0;
    }

    .progress-bar-wrapper {
        height: 0.2rem;
        position: relative;
    }

    .progress-bar-container {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 100%;
        background-color: var(--bg-tertiary);
        overflow: hidden;
    }

    .progress-bar-fill {
        height: 100%;
        width: 0%;
        background: var(--gradient-interval);
        transition: width 0.1s ease;
    }

    #progressBarSmart .progress-bar-fill {
        background: var(--gradient-secondary);
    }

    #progressBarContactSheet .progress-bar-fill {
        background: var(--gradient-tertiary);
    }


    .action-button-row {
        display: flex;
        gap: 0.5rem;
        width: 100%;
    }
    .action-button-row .action-button {
        flex: 1;
    }

    .secondary-button {
        background: transparent;
        border: 1px solid var(--accent-tertiary);
        color: var(--accent-tertiary);
        padding: calc(0.75rem - 1px) calc(1.5rem - 1px);
        box-shadow: none;
    }
    .secondary-button:hover:enabled {
        background-color: rgba(255, 106, 193, 0.1);
        border-color: var(--accent-tertiary-dark);
        color: var(--accent-tertiary-dark);
        box-shadow: none;
    }

    #manualModeButtons .secondary-button {
        border-color: var(--accent-primary);
        color: var(--accent-primary);
    }
    #manualModeButtons .secondary-button:hover:enabled {
        background-color: rgba(0, 198, 255, 0.1);
        border-color: var(--accent-primary-dark);
        color: var(--accent-primary-dark);
    }
    #smartModeButtons .secondary-button {
        border-color: var(--accent-secondary);
        color: var(--accent-secondary);
    }
    #smartModeButtons .secondary-button:hover:enabled {
        background-color: rgba(94, 234, 212, 0.1);
        border-color: var(--accent-secondary-dark);
        color: var(--accent-secondary-dark);
    }

    #extractManualButton {
        border-color: var(--accent-primary) !important;
        color: var(--accent-primary) !important;
    }
    #extractManualButton:hover:enabled {
        background-color: rgba(0, 198, 255, 0.1) !important;
        border-color: var(--accent-primary-dark) !important;
        color: var(--accent-primary-dark) !important;
    }

    #processButton { background: var(--gradient-interval); }

    .screenshot-lightbox-content {
        max-width: 90%;
        max-height: 90vh;
        width: fit-content;
        display: flex;
        flex-direction: column;
        padding: 0;
        position: relative;
        background-color: var(--bg-secondary);
    }

    .screenshot-lightbox-content .modal-close {
        position: absolute;
        top: 10px;
        right: 10px;
        background-color: rgba(0, 0, 0, 0.5);
        color: var(--white);
        border-radius: 50%;
        width: 36px;
        height: 36px;
        display: flex;
        z-index: 10;
    }

    
    .screenshot-lightbox-container {
        display: flex;
        overflow: hidden;
        position: relative;
        width: fit-content;
        max-width: 100%;
        flex-grow: 1;
        align-items: center;
        justify-content: center;
    }

    .screenshot-lightbox-container img {
        max-width: 100%;
        max-height: 100%;
        object-fit: contain;
        margin: 0;
    }

    .lightbox-nav-btn {
        background-color: var(--bg-tertiary);
        color: var(--text-primary);
        border: 1px solid var(--border-color);
        padding: 0.5rem 0.75rem;
        border-radius: var(--border-radius-sm);
        cursor: pointer;
        font-size: 0.9rem;
        line-height: 1;
        transition: background-color 0.2s, border-color 0.2s, color 0.2s;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        white-space: nowrap;
        margin: 0 5px;
    }
     .lightbox-nav-btn:hover:enabled {
        background-color: var(--border-color);
        border-color: var(--text-secondary);
        color: var(--text-primary);
     }
     .lightbox-nav-btn:disabled {
        background-color: var(--bg-tertiary);
        color: var(--text-secondary);
        cursor: not-allowed;
        opacity: 0.6;
        border-color: var(--border-color);
     }
     .lightbox-nav-btn i {
        font-size: 1.1em;
        margin: 0 0.3em;
        vertical-align: middle;
     }
     .lightbox-nav-btn .nav-text {
        margin: 0 0.4em;
    }
    .lightbox-nav-btn .nav-icon {
       font-size: 1.2em;
       line-height: 1;
    }

    #lightboxDownload {
        background-color: var(--bg-tertiary);
        color: var(--text-primary);
        border: 1px solid var(--border-color);
        padding: 0.5rem 1rem;
        border-radius: var(--border-radius-sm);
        font-weight: 500;
        gap: 0.5em;
         display: inline-flex;
        align-items: center;
        justify-content: center;
        text-decoration: none;
        transition: background-color 0.2s, border-color 0.2s, color 0.2s;
    }
    #lightboxDownload:hover:enabled {
        background-color: var(--border-color);
        border-color: var(--text-secondary);
        color: var(--text-primary);
    }
     #lightboxDownload i {
        font-size: 1.1em;
     }


    .prev-btn, .next-btn {
        position: static;
        transform: none;
        opacity: 1;
        width: auto;
        height: auto;
    }

    .screenshot-lightbox-info {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.5rem 1rem;
        background-color: var(--bg-secondary);
        border-top: 1px solid var(--border-color);
        height: 60px;
        flex-shrink: 0;
    }

    .lightbox-controls-left {
        display: flex;
        align-items: center;
        gap: 10px;
    }
     #lightboxFrameNumber {
         color: var(--text-secondary);
         font-size: 0.9em;
         margin-left: 5px;
         font-family: var(--data-font);
     }
     .screenshot-lightbox-content:not(.grid-mode) #lightboxFrameNumber {
         display: none;
     }
     .screenshot-lightbox-content.grid-mode #lightboxDeleteBtn {
         display: none;
     }
    .lightbox-frame-adjust-controls {
        display: none;
        align-items: center;
        gap: 5px;
    }
    .screenshot-lightbox-content.grid-mode .lightbox-frame-adjust-controls,
    .screenshot-lightbox-content:not(.grid-mode) .lightbox-frame-adjust-controls[style*="inline-flex"] {
        display: inline-flex;
    }
    .lightbox-adjust-btn {
        background-color: var(--bg-tertiary);
        color: var(--text-primary);
        border: 1px solid var(--border-color);
        padding: 0.3rem 0.6rem;
        border-radius: var(--border-radius-sm);
        cursor: pointer;
        font-size: 0.9rem;
        line-height: 1;
        transition: background-color 0.2s, border-color 0.2s;
        display: inline-flex;
        align-items: center;
        gap: 0.2em;
    }
     .lightbox-adjust-btn i {
        font-size: 1em;
        vertical-align: middle;
     }
     .lightbox-adjust-btn .icon-flipped {
         transform: scaleX(-1);
     }
    .lightbox-adjust-btn:hover {
        background-color: var(--border-color);
        border-color: var(--text-secondary);
    }
    
    .manual-time-btn {
        background-color: var(--bg-tertiary);
        color: var(--text-primary);
        border: 1px solid var(--border-color);
        padding: 0.3rem 0.6rem;
        border-radius: var(--border-radius-sm);
        cursor: pointer;
        font-size: 0.9rem;
        line-height: 1;
        transition: background-color 0.2s, border-color 0.2s;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 0.2em;
        width: 2em;
        height: 2em;
    }
    
    .manual-time-btn:hover {
        background-color: var(--border-color);
        border-color: var(--border-color);
        color: var(--text-primary);
    }

    #manualDragControl {
        cursor: ew-resize;
        border-radius: var(--border-radius-full);
        width: 100%;
        justify-content: center;
        background-image: repeating-linear-gradient(
            -45deg,
            var(--border-color),
            var(--border-color) 4px,
            var(--bg-secondary) 4px,
            var(--bg-secondary) 8px
        );
    }
    
    #manualDragControl:hover {
        background-color: var(--bg-tertiary);
        border-color: var(--border-color);
        color: var(--text-primary);
        background-image: repeating-linear-gradient(
            -45deg,
            var(--border-color),
            var(--border-color) 4px,
            var(--bg-secondary) 4px,
            var(--bg-secondary) 8px
        );
    }

    .drag-helper-text {
        text-align: center;
        margin-top: 0.3rem;
        margin-bottom: 2rem;
        font-style: italic;
        color: var(--text-tertiary);
        font-size: 0.85rem;
    }

    .time-input-row {
        margin-bottom: 0.5rem;
        display: flex;
        align-items: center;
        justify-content: space-between;
    }

    .time-input-controls {
        display: flex;
        align-items: center;
    }

    .time-input-field {
        width: 100px;
    }

    #lightboxTimestamp {
        font-family: 'Source Code Pro', monospace;
        color: var(--text-primary);
        font-size: 1rem;
        margin: 0 15px;
        min-width: 60px;
        text-align: center;
    }

    .lightbox-nav-controls {
        display: flex;
        flex-direction: row;
        align-items: center;
        gap: 5px;
    }

    #lightboxDeleteBtn {
        margin-right: 10px;
        min-width: 36px;
        min-height: 36px;
    }

    .mode-description {
        color: var(--text-tertiary);
        font-size: 0.9rem;
        margin-bottom: 1rem;
        background-color: rgba(36, 44, 68, 0.5);
        border-radius: var(--border-radius-sm);
        padding: 0.5rem 0.8rem;
    }



     #processContactSheetButton.needs-update {
        background: var(--gradient-tertiary);
        animation: pulse-tertiary 1.5s infinite;
     }
     #downloadContactSheetButton.needs-update, #previewContactSheetButton.needs-update {
        border-color: var(--accent-tertiary);
     }

     .disclaimer-note {
        text-align: center;
        color: var(--text-tertiary);
        font-style: italic;
        margin: 0.75rem 0 0.5rem;
        font-size: 0.85rem;
        padding: 0.3rem 0.6rem;
        background-color: rgba(36, 44, 68, 0.5);
        border-radius: var(--border-radius-sm);
    }
    #largeGridDisclaimer {
        display: none;
        margin-bottom: 1rem;
    }


     @keyframes pulse-tertiary {
        0% { box-shadow: 0 0 0 0 rgba(255, 140, 220, 0.4); }
        70% { box-shadow: 0 0 0 6px rgba(255, 140, 220, 0); }
        100% { box-shadow: 0 0 0 0 rgba(255, 140, 220, 0); }
     }

     @media (max-width: 800px) {
        body { overflow-y: auto; height: auto; }
        .app-container { flex-direction: column; height: auto; overflow: visible; }
        .vertical-separator { display: none; }
        .side-panel { flex-basis: auto; width: 100%; height: auto; max-height: none; border-right: none; overflow-y: visible; padding: 0; }
        .content-wrapper { direction: ltr; padding: var(--content-padding); height: auto; }
        .output-column { width: 100%; overflow-y: visible; }
        #screenshots { padding: 0; }
        .mode-content { overflow: visible; }
        .screenshot-lightbox-content { width: auto; min-width: auto; max-width: 95%; }
        .lightbox-nav-btn .nav-text { display: none; }
        #lightboxDownload span { display: none; }
        #lightboxFrameNumber { display: none; }
        #lightboxDownload { display: none; }    
        .screenshot-lightbox-info { justify-content: flex-start; }
        .lightbox-controls-left { position: relative; }
        .lightbox-nav-controls { margin-left: auto; }
        .modal-overlay#namingSettingsModal,
        .modal-overlay#toolInfoModal {
            align-items: flex-end;
        }
        .modal-overlay#namingSettingsModal .info-box-content,
        .modal-overlay#toolInfoModal .info-box-content {
            max-width: 100vw;
            width: 100vw;
            min-height: 60vh;
            max-height: 100vh;
            border-radius: 1.2rem 1.2rem 0 0;
            padding-bottom: 2.5rem;
        }
        .modal-overlay#namingSettingsModal .info-box-content {
            padding-left: 1rem;
            padding-right: 1rem;
        }
    }

    .screenshot-container .thumbnail-download-btn {
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
      z-index: 2;
    }
    .screenshot-container:hover .thumbnail-download-btn {
      opacity: 1;
      pointer-events: auto;
    }

    .grid-cell .thumbnail-download-btn {
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
      z-index: 2;
    }
    .grid-cell.filled:hover .thumbnail-download-btn,
    .grid-cell:hover .thumbnail-download-btn {
      opacity: 1;
      pointer-events: auto;
    }

  </style>
</head>
<body>

  <div class="app-container">

    <div class="vertical-separator"></div>

    <div class="side-panel">
      <div class="content-wrapper">
        <h1 id="pageTitle" data-text="Pilko Studio">Pilko Studio</h1>

        <div id="dropZone">
            <div id="uploadIcon">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" id="uploadIconSvg"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="1.5"><path stroke-miterlimit="10" d="M9.047 9.5v5"/><path stroke-linejoin="round" d="M11.34 11.605L9.373 9.638a.458.458 0 0 0-.651 0l-1.968 1.967"/><path stroke-linejoin="round" d="M12 5.32H6.095A3.595 3.595 0 0 0 2.5 8.923v6.162a3.595 3.595 0 0 0 3.595 3.595H12a3.595 3.595 0 0 0 3.595-3.595V8.924A3.594 3.594 0 0 0 12 5.32m9.5 4.118v5.135c0 .25-.071.496-.205.708a1.355 1.355 0 0 1-.555.493a1.27 1.27 0 0 1-.73.124a1.366 1.366 0 0 1-.677-.278l-3.225-2.588a1.377 1.377 0 0 1-.503-1.047c0-.2.045-.396.133-.575c.092-.168.218-.315.37-.432l3.225-2.567a1.36 1.36 0 0 1 .678-.278c.25-.032.504.011.729.124a1.325 1.325 0 0 1 .76 1.181"/></g></svg>
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" id="spinnerIcon" style="display: none;"><path fill="currentColor" d="M12,1A11,11,0,1,0,23,12,11,11,0,0,0,12,1Zm0,19a8,8,0,1,1,8-8A8,8,0,0,1,12,20Z" opacity=".25"/><path fill="currentColor" d="M10.14,1.16a11,11,0,0,0-9,8.92A1.59,1.59,0,0,0,2.46,12,1.52,1.52,0,0,0,4.11,10.7a8,8,0,0,1,6.66-6.61A1.42,1.42,0,0,0,12,2.69h0A1.57,1.57,0,0,0,10.14,1.16Z"><animateTransform attributeName="transform" dur="0.75s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></svg>
            </div>
            <div id="dropZoneText">Upload a video file</div>
            <div id="loadedFileInfo">
                <div class="file-name-row">
                    <div id="loadedFileName">Filename goes here</div>
                    <button id="selectFileButton" class="file-loaded-button">Change File</button>
                </div>
                <div id="loadedFileStats">
                    <div class="info-row"><div class="info-label">Resolution</div><div class="info-value" id="resolutionValue">-</div></div>
                    <div class="info-row"><div class="info-label">Duration</div><div class="info-value" id="lengthValue">-</div></div>
                    <div class="info-row"><div class="info-label">Aspect Ratio</div><div class="info-value" id="aspectRatioValue">-</div></div>
                    <div class="info-row"><div class="info-label">Bitrate</div><div class="info-value" id="bitrateValue">-</div></div>
                </div>
            </div>
            <div id="buttonRow">
                <button id="initialSelectFileButton" type="button">Select a File</button>
                <span id="orText">or</span>
                <button id="tryExampleButton" type="button">Try Example Video</button>
            </div>
            <input type="file" id="videoInput" accept="video/*">
        </div>

        <div class="settings-panel">
            <div class="setting-row">
                <div class="setting-control-group">
                    <label class="setting-label format-label">Capture Format</label>
                    <div class="format-controls">
                        <select id="captureFormatSelect" class="value-input" style="width:90px;">
                            <option value="png" selected>PNG</option>
                            <option value="jpeg">JPEG</option>
                            <option value="webp">WEBP</option>
                        </select>
                    </div>
                </div>
                <!-- Quality sliders (hidden by default, shown based on format selection) -->
                <div class="slider-row" id="jpegQualityGlobalRow">
                    <h3 class="slider-label">JPEG Quality</h3>
                    <div class="slider-wrapper">
                        <input type="range" id="jpegQualityGlobal" min="1" max="100" value="90" step="1">
                        <span id="jpegQualityGlobalValue" class="value-display">90%</span>
                    </div>
                </div>
                <div class="slider-row" id="webpQualityGlobalRow">
                    <h3 class="slider-label">WEBP Quality</h3>
                    <div class="slider-wrapper">
                        <input type="range" id="webpQualityGlobal" min="1" max="100" value="90" step="1">
                        <span id="webpQualityGlobalValue" class="value-display">90%</span>
                    </div>
                </div>
                <div class="setting-control-group">
                    <label class="setting-label toggle-label">
                        Remove Black Bars
                        <i class="ri-question-line info-icon-inline" title="Automatically detect and crop black bars from letterboxed videos" id="removeBarsInfoIcon"></i>
                    </label>
                    <div class="toggle-switch">
                        <input type="checkbox" id="removeBarsToggle" class="toggle-input">
                        <label for="removeBarsToggle" class="toggle-label-switch"></label>
                    </div>
                </div>
                <!-- Pro Mode toggle -->
                <div class="setting-control-group">
                    <label class="setting-label toggle-label">
                        Pro Mode
                    </label>
                    <div class="toggle-switch">
                        <input type="checkbox" id="proModeToggle" class="toggle-input">
                        <label for="proModeToggle" class="toggle-label-switch"></label>
                    </div>
                </div>
                <!-- Framerate input, hidden unless Pro Mode -->
                <div class="setting-control-group" id="framerateRow" style="display:none;">
                    <label class="slider-label">
                        Set Framerate
                        <i class="ri-question-line info-icon-inline" title="Set your input video's framerate. This ensures accurate timecode data for the generated frames and manual fine-tuning." id="framerateInfoIcon"></i>
                    </label>
                    <div class="time-input-controls" style="margin-left:auto; max-width: 180px;">
                        <button class="manual-time-btn" id="frameratePrevBtn" title="Decrease framerate" tabindex="-1" style="min-width:32px;">-</button>
                        <input type="text" id="framerateInput" class="value-input time-input-field" value="30" style="width:87px; text-align:center;" inputmode="decimal">
                        <button class="manual-time-btn" id="framerateNextBtn" title="Increase framerate" tabindex="-1" style="min-width:32px;">+</button>
                    </div>
                </div>
                <!-- Add Timecode, hidden unless Pro Mode -->
                <div class="setting-control-group" id="addTimestampGroup" >
                    <label class="slider-label">
                        Add TC Overlay
                        <i class="ri-question-line info-icon-inline" title="Burn-in SMPTE timecode overlay to bottom right corner of generated frames" id="timestampInfoIcon"></i>
                    </label>
                    <div class="format-controls">
                        <select id="timecodeFormatSelect" class="value-input">
                            <option value="off" selected>Off</option>
                            <option value="hh:mm:ss:ff">hh:mm:ss:ff</option>
                            <option value="hh:mm:ss">hh:mm:ss</option>
                            <option value="mm:ss:ff">mm:ss:ff</option>
                            <option value="mm:ss">mm:ss</option>
                            <option value="ss:ff">ss:ff</option>
                            <option value="ss">ss</option>
                            <option value="ff">ff</option>
                        </select>
                    </div>
                </div>
                <!-- Custom Text Overlay, hidden unless Pro Mode -->
                <div class="setting-control-group" id="customTextGroup" style="display:none;">
                    <label class="slider-label">
                        Add Text Overlay
                        <i class="ri-question-line info-icon-inline" title="Add custom text overlay to generated frames and rotate its position with the button on the right." id="customTextInfoIcon"></i>
                    </label>
                    <div class="format-controls">
                        <input type="text" id="customTextInput" class="value-input" placeholder="Enter custom text..." style="width: 170px;">
                        <button class="corner-position-btn" id="cornerPositionBtn" title="Toggle text position">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                                <path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="m4 8l.01.011M4 4l.01.011M8 4l.01.011M12 4l.01.011M16 4l.01.011M20 4l.01.011M20 8l.01.011M20 12l.01.011M20 16l.01.011M20 20l.01.011M16 20l.01.011M4 12.01v8h8v-8z"/>
                            </svg>
                        </button>
                    </div>
                </div>
                <!-- Overlay Size, hidden unless Pro Mode -->
                <div class="setting-control-group" id="timecodeSizeGroup" style="display:none;">
                    <label class="slider-label">
                        Overlay Size
                        <i class="ri-question-line info-icon-inline" title="Set the font size for timecode and custom text overlays." id="overlaySizeInfoIcon"></i>
                    </label>
                    <div class="segmented-controls timecode-size-tabs" style="max-width: 200px; margin-bottom: 0;">
                        <button class="timecode-size-tab" data-size="S">S</button>
                        <button class="timecode-size-tab active" data-size="M">M</button>
                        <button class="timecode-size-tab" data-size="L">L</button>
                        <button class="timecode-size-tab" data-size="XL">XL</button>
                    </div>
                </div>
            </div>

            <div class="segmented-controls mode-tabs">
                <button class="mode-tab active" data-mode="manual">Manual</button>
                <button class="mode-tab" data-mode="auto">Interval</button>
                <button class="mode-tab" data-mode="autoSmart">Smart Auto</button>
                <button class="mode-tab" data-mode="contactSheet">Grid</button>
            </div>

            <div class="mode-content">
                <div id="manualMode" class="active">
                    <p class="mode-description">Use the video player to navigate and press Cut Frame to extract screenshots.</p>
                    <video id="manualVideo" controls></video>
                    
                    <h3 class="setting-group-title">Fine-tune current frame</h3>
                    <div class="time-input-container" style="margin-bottom: 1rem;">
                        <div class="time-input-row">
                            <h3 class="slider-label">Time</h3>
                            <div class="time-input-controls">
                                <button class="manual-time-btn" id="manualTimePrevBtn" title="Go back 1 second">
                                    <i class="ri-arrow-drop-left-line"></i>
                                </button>
                                <input type="text" id="manualTimeInput" class="value-input time-input-field" value="0:00" placeholder="0:00">
                                <button class="manual-time-btn" id="manualTimeNextBtn" title="Go forward 1 second">
                                    <i class="ri-arrow-drop-right-line"></i>
                                </button>
                            </div>
                        </div>
                        <div class="time-input-row">
                            <h3 class="slider-label">Frame <i class="ri-error-warning-line info-icon-inline" title='You need to enable "Pro Mode" -option and use "Set Framerate" -option to set the framerate of your input video for accurate frame display.' id="frameWarningIcon"></i></h3>
                            <div class="time-input-controls">
                                <button class="manual-time-btn" id="manualFramePrevBtn" title="Go back 1 frame">
                                    <i class="ri-arrow-drop-left-line"></i>
                                </button>
                                <input type="text" id="manualFrameInput" class="value-input time-input-field" value="0" placeholder="0" inputmode="numeric" pattern="[0-9]*">
                                <button class="manual-time-btn" id="manualFrameNextBtn" title="Go forward 1 frame">
                                    <i class="ri-arrow-drop-right-line"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                    <div class="drag-control-container">
                        <button class="manual-time-btn" id="manualDragControl">
                            <i class="ri-expand-horizontal-s-line"></i>
                        </button>
                        <div class="drag-helper-text">
                            Drag the bar above horizontally to adjust video position
                        </div>
                    </div>
                </div>
                <div id="autoMode">
                    <p class="mode-description">Captures screenshots at regular time intervals. Lower value creates more images, higher value creates fewer.</p>
                    <div class="slider-row"><h3 class="slider-label" style="font-size: 0.9rem; color: var(--text-primary); font-weight: 500;">Interval</h3>
                    <div class="slider-wrapper"><input type="range" id="intervalInput" min="1" max="30" value="10" step="1"><span id="intervalValue" class="value-display"></span></div></div>
                </div>
                <div id="autoSmartMode">
                    <p class="mode-description">Identifies scenes and visual changes<br>- <strong>Aims to capture one frame per scene</strong>.<br>- It's not perfect, but provides a good foundation.<br>You can fine-tune a frame with <i class="ri-scissors-line"></i> buttons below it.</p>
                    <h3 class="setting-group-title">Algorithm</h3>
                    <div class="segmented-controls smart-algo-tabs">
                        <button class="smart-tab active" data-algo="histogram">Histogram Diff</button>
                        <button class="smart-tab" data-algo="pixeldiff">Pixel Diff</button>
                    </div>
                    <div class="slider-row" id="histThresholdSettings">
                        <h3 class="slider-label">Hist Thresh</h3>
                        <div class="slider-wrapper">
                            <input type="range" id="histThresholdInput" min="0.20" max="0.80" value="0.50" step="0.05">
                            <span id="histThresholdValue" class="value-display"></span>
                        </div>
                    </div>
                    <p class="disclaimer-note">Compares color and brightness distribution between frames. Higher threshold means more sensitivity to changes.<br><strong>Default value: 50%</strong></p>
                    <div class="slider-row" id="pixelThresholdSettings" style="display:none;">
                        <h3 class="slider-label">Pixel Thresh</h3>
                        <div class="slider-wrapper">
                            <input type="range" id="pixelThresholdInput" min="20" max="80" value="50" step="5">
                            <span id="pixelThresholdValue" class="value-display"></span>
                        </div>
                    </div>
                    <p class="disclaimer-note" id="pixelDiffDisclaimer" style="display: none;">Measures the percentage of pixel changes between frames. Higher threshold means more sensitivity to changes.<br><strong>Default value: 50%</strong></p>
                </div>
                <div id="contactSheetMode">
                    <p class="mode-description">Choose a grid size for screenshots. After generating, you can fine-tune the captured frames.</p>
                    <h3 class="setting-group-title">Grid Size</h3>
                    <div class="segmented-controls grid-size-tabs">
                        <button class="grid-size-tab active" data-rows="4" data-cols="5">5×4</button>
                        <button class="grid-size-tab" data-rows="3" data-cols="4">4×3</button>
                        <button class="grid-size-tab" data-rows="2" data-cols="3">Custom</button>
                    </div>
                    <div id="customGridControls" style="display: none; margin-bottom: 0.5rem;">
                        <div class="time-input-container">
                            <div class="time-input-row">
                                <h3 class="slider-label">Columns</h3>
                                <div class="time-input-controls">
                                    <button class="manual-time-btn" id="customGridColsPrevBtn" title="Decrease columns">
                                        <i class="ri-arrow-drop-left-line"></i>
                                    </button>
                                    <input type="text" id="customGridCols" class="value-input time-input-field" value="3" placeholder="3" inputmode="numeric" pattern="[0-9]*">
                                    <button class="manual-time-btn" id="customGridColsNextBtn" title="Increase columns">
                                        <i class="ri-arrow-drop-right-line"></i>
                                    </button>
                                </div>
                            </div>
                            <div class="time-input-row">
                                <h3 class="slider-label">Rows</h3>
                                <div class="time-input-controls">
                                    <button class="manual-time-btn" id="customGridRowsPrevBtn" title="Decrease rows">
                                        <i class="ri-arrow-drop-left-line"></i>
                                    </button>
                                    <input type="text" id="customGridRows" class="value-input time-input-field" value="2" placeholder="2" inputmode="numeric" pattern="[0-9]*">
                                    <button class="manual-time-btn" id="customGridRowsNextBtn" title="Increase rows">
                                        <i class="ri-arrow-drop-right-line"></i>
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="video-container">
                        <video id="contactSheetVideo" controls></video>
                    </div>
                    <p id="largeGridDisclaimer" class="disclaimer-note">Time inputs hidden for grids larger than 6x6.</p>
                    <div class="grid-controls">
                    </div>
                    
                    <h3 class="setting-group-title">Output Resolution</h3>
                    <div class="slider-row">
                        <h3 class="slider-label">Width</h3>
                        <div class="slider-wrapper">
                            <input type="range" id="gridOutputWidthSlider" min="1000" max="10000" value="3000" step="500">
                            <input type="text" id="gridOutputWidth" class="value-input time-input-field" value="3000" placeholder="3000" inputmode="numeric" pattern="[0-9]*">
                        </div>
                    </div>
                    <div class="slider-row">
                        <h3 class="slider-label">Height</h3>
                        <div class="slider-wrapper">
                        </div>
                        <span id="gridOutputWidthValue" class="value-display">-</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="sticky-button-container">         
            <div class="button-group" id="intervalModeButtons">
                <button id="processButton" class="action-button">Extract Screenshots <i class="ri-scissors-line"></i></button>
                <div class="action-button-row">
                    <button id="downloadAllButton" class="action-button secondary-button" disabled>Download All <i class="ri-download-2-line"></i></button>
                    <button id="namingSettingsButton" class="action-icon-button" title="Filename Settings" disabled><i class="ri-settings-3-line"></i></button>
                </div>
            </div>

            <div class="button-group" id="smartModeButtons" style="display:none;">
                <button id="processSmartButton" class="action-button">Extract Smart Shots <i class="ri-scissors-line"></i></button>
                <div class="action-button-row">
                    <button id="downloadAllSmartButton" class="action-button secondary-button" disabled>Download All <i class="ri-download-2-line"></i></button>
                    <button id="namingSettingsButtonSmart" class="action-icon-button" title="Filename Settings" disabled><i class="ri-settings-3-line"></i></button>
                </div>
            </div>

            <div class="button-group" id="manualModeButtons" style="display:flex;">
                <button id="addManualButton" class="action-button" type="button">Cut Frame <i class="ri-scissors-line"></i></button>
                <div class="action-button-row">
                    <button id="extractManualButton" class="action-button secondary-button" type="button">Save Frame <i class="ri-download-line"></i></button>
                    <button id="downloadManualButton" class="action-button secondary-button" type="button" disabled>Download All <i class="ri-download-2-line"></i></button>
                    <button id="namingSettingsButtonManual" class="action-icon-button" title="Filename Settings" disabled><i class="ri-settings-3-line"></i></button>
                </div>
            </div>

            <div class="button-group" id="contactSheetModeButtons" style="display:none;">
                <button id="processContactSheetButton" class="action-button">Generate/Update Grid</button>
                <div class="action-button-row">
                    <button id="previewContactSheetButton" class="action-button secondary-button" disabled>Preview <i class="ri-image-line"></i></button>
                    <button id="downloadContactSheetButton" class="action-button secondary-button" disabled>Download <i class="ri-download-2-line"></i></button>
                </div>
            </div>

            <div class="progress-bar-wrapper">
                <div id="progressBarAuto" class="progress-bar-container" style="display:none;"><div id="progressBarFillAuto" class="progress-bar-fill"></div></div>
                <div id="progressBarSmart" class="progress-bar-container" style="display:none;"><div id="progressBarFillSmart" class="progress-bar-fill"></div></div>
                <div id="progressBarContactSheet" class="progress-bar-container" style="display:none;"><div id="progressBarFillContactSheet" class="progress-bar-fill"></div></div>
            </div>

            <div class="status-row">
                <button id="clearScreenshotsButton" type="button" class="action-icon-button action-icon-button--delete" disabled>
                    <svg class="delete-icon-svg" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 1024 1024"><path fill="currentColor" d="M360 184h-8c4.4 0 8-3.6 8-8zm304 0v-8c0 4.4 3.6 8 8 8h-8v72h72v-80c0-35.3-28.7-64-64-64H352c-35.3 0-64 28.7-64 64v80h72zm504 72H160c-17.7 0-32 14.3-32 32v32c0 4.4 3.6 8 8 8h60.4l24.7 523c1.6 34.1 29.8 61 63.9 61h454c34.2 0 62.3-26.8 63.9-61l24.7-523H888c4.4 0 8-3.6 8-8v-32c0-17.7-14.3-32-32-32M731.3 840H292.7l-24.2-512h487z"/></svg>
                    Clear Output
                </button>
                <div id="imageCountDisplay">Generated Images:<span id="imageCountValue">0</span></div>
                <button id="toolInfoButton" type="button" title="About this tool"><i class="ri-information-line"></i></button>
            </div>
        </div>

      </div>
    </div>

    <div class="output-column" id="outputColumn">
      <div id="screenshots">
      </div>
      <div id="contactSheetPreview">
      </div>
    </div>

  </div>

  <video id="video" style="display:none;"></video>
  <canvas id="canvas"></canvas>
  <canvas id="frameCanvas" style="display:none;"></canvas>
  <canvas id="contactSheetCanvas" style="display:none;"></canvas>

  <div class="modal-overlay" id="toolInfoModal">
    <div class="info-box-content">
      <button class="modal-close" id="modalClose"><i class="ri-close-line"></i></button>
      <h2 class="modal-title">Pilko Studio</h2>
      <div class="modal-body">
        <p>Pilko Studio is a frame capture web tool that lets you extract screenshots from your videos in many different ways locally within your browser.</p>

        <h3>Extraction Modes</h3>
          <ul>
            <li><strong style="color: var(--accent-primary)">Manual</strong><br><span>Manually select and capture specific frames from the video player.</span></li>
            <li><strong style="color: var(--accent-interval)">Interval</strong><br><span>Extract frames at regular time intervals (seconds).</span></li>
            <li><strong style="color: var(--accent-secondary)">Smart Auto</strong><br><span>Use different frame comparison algorithms to capture only significant frame changes.</span></li>
              <ul>
                <li><strong style="color: var(--accent-secondary)">Histogram Diff</strong> compares the overall distribution of colors and brightness levels between frames. If the distribution is different enough (determined by the slider value) in a scene change, it triggers a frame capture.</li>
                <li><strong style="color: var(--accent-secondary)">Pixel Diff</strong> measures the percentage of pixels that have changed between frames. If the percentage is above the threshold (determined by the slider value), a frame capture will be triggered.</li>
              </ul>
            </li>
            <li><strong style="color: var(--accent-tertiary)">Grid</strong><br><span>Generate a grid of screenshots to a single image.</span></li>
          </ul>

        <h3>Features</h3>
        <ul>
          <li>See basic video metadata.</li>
          <li>Automatically detect and remove black bars.</li>
          <li>Different capture formats (PNG, JPEG, WEBP) and quality sliders (1-100%).</li>
          <li>Preview and fine-tune captured frames with buttons or hotkeys.</li>
          <li>Download individually or as a .zip -file.</li>
        </ul>

        <h3>Processing & Privacy</h3>
        <p>All video processing and screenshot extraction happen locally within the browser, with no cloud or server-side dependencies, ensuring your privacy.<br>This website already performs all processing locally, but you can also self-host it for full peace of mind. View the source code on <a href="https://github.com/LandoNikko/Pilko-Frame-Capture-Studio" target="_blank" rel="noopener noreferrer" style="color: var(--text-primary)">GitHub</a>.</p>

      </div>
    </div>
  </div>

  <div class="modal-overlay" id="screenshotLightbox">
    <div class="info-box-content screenshot-lightbox-content">
      <button class="modal-close" id="lightboxClose"><i class="ri-close-line"></i></button>
      <div class="screenshot-lightbox-container">
        <img id="lightboxImage" src="" alt="Screenshot fullscreen view">
      </div>
      <div class="screenshot-lightbox-info">
        <div class="lightbox-controls-left">
           <button class="action-icon-button action-icon-button--delete lightbox-delete-btn" id="lightboxDeleteBtn" title="Delete this screenshot (Hotkeys: 🡫, S)">
             <!-- SVG Icon by JS -->
           </button>
           <span id="lightboxFrameNumber"></span> 
        </div>
        <div class="lightbox-nav-controls">
            <div class="lightbox-frame-adjust-controls">
                <button class="lightbox-adjust-btn" id="lightboxAdjustPrev" title="Cut backward by 1s (Hotkey: Q)">-<i class="ri-scissors-line icon-flipped"></i></button>
            </div>
            <button class="lightbox-nav-btn prev-btn" id="lightboxPrevBtn" title="Hotkeys: 🡨, A">
              <span class="nav-icon"><i class="ri-arrow-drop-left-line"></i></span>
              <span class="nav-text">Previous Frame</span>
            </button>
            <span id="lightboxTimestamp"></span>
            <button class="lightbox-nav-btn next-btn" id="lightboxNextBtn" title="Hotkeys: 🡪, D">
              <span class="nav-text">Next Frame</span>
              <span class="nav-icon"><i class="ri-arrow-drop-right-line"></i></span>
            </button>
             <div class="lightbox-frame-adjust-controls">
                <button class="lightbox-adjust-btn" id="lightboxAdjustNext" title="Cut forward by 1s (Hotkey: E)"><i class="ri-scissors-line"></i>+</button>
            </div>
        </div>
        <a id="lightboxDownload" href="#" download="screenshot.png" class="lightbox-action-btn lightbox-download-btn"><span>Download</span> <i class="ri-download-2-line"></i></a>
      </div>
    </div>
  </div>

  <div class="modal-overlay" id="namingSettingsModal">
    <div class="info-box-content">
      <button class="modal-close" id="namingSettingsClose"><i class="ri-close-line"></i></button>
      <h2 class="modal-title">Filename Settings</h2>
      <div class="modal-body">
        <div class="setting-row">
          <div class="setting-control-group">
            <label class="setting-label">Prefix</label>
            <input type="text" id="filenamePrefix" class="value-input" value="screenshot_" placeholder="screenshot_">
          </div>
          <div class="setting-control-group">
            <label class="setting-label">Numbering Style</label>
            <select id="numberingStyleSelect" class="value-input">
              <option value="0001">0001</option>
              <option value="001" selected>001</option>
              <option value="01">01</option>
              <option value="1">1</option>
            </select>
          </div>
          <div class="setting-control-group">
            <label class="setting-label">Timestamp</label>
            <div class="setting-controls">
              <div class="toggle-switch">
                <input type="checkbox" id="includeTimestamp" class="toggle-input">
                <label for="includeTimestamp" class="toggle-label-switch"></label>
              </div>
            </div>
          </div>
          <!-- Frame toggle-switch -->
          <div class="setting-control-group">
            <label class="setting-label">Frame</label>
            <div class="setting-controls">
              <div class="toggle-switch">
                <input type="checkbox" id="includeFrame" class="toggle-input">
                <label for="includeFrame" class="toggle-label-switch"></label>
              </div>
            </div>
          </div>
          <!-- Framerate input, hidden unless Frame is enabled -->
          <div class="setting-control-group" id="framerateRow" style="display:none; align-items:center;">
            <label class="slider-label" style="margin-bottom:0;">Set Framerate</label>
            <input type="number" id="framerateInput" class="value-input" value="30" min="1" max="240" step="1" style="width:70px; margin-left:auto;">
          </div>
        </div>
        <div class="disclaimer-note" id="namingSettingsExample" style="background-color: var(--bg-primary); text-align: right; padding: 0.75rem; border-radius: var(--border-radius-md); font-family: monospace; margin: 1rem 0;">
          <span id="namingSettingsExampleText">screenshot_001_0-10.png</span>
        </div>
        <div class="setting-row">
          <div class="setting-control-group">
            <button id="saveNamingSettings" class="action-button">Save Settings</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    'use strict';

    const DELETE_ICON_SVG = `<svg class="delete-icon-svg" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 1024 1024"><path fill="currentColor" d="M360 184h-8c4.4 0 8-3.6 8-8zm304 0v-8c0 4.4 3.6 8 8 8h-8v72h72v-80c0-35.3-28.7-64-64-64H352c-35.3 0-64 28.7-64 64v80h72zm504 72H160c-17.7 0-32 14.3-32 32v32c0 4.4 3.6 8 8 8h60.4l24.7 523c1.6 34.1 29.8 61 63.9 61h454c34.2 0 62.3-26.8 63.9-61l24.7-523H888c4.4 0 8-3.6 8-8v-32c0-17.7-14.3-32-32-32M731.3 840H292.7l-24.2-512h487z"/></svg>`;

    let verticalSeparatorElement = null;
    let cropData = null;
    let removeBarsEnabled = false;
    let addTimestampEnabled = false;
    let gridCache = {
      '5x4': { data: null, blob: null, completed: false },
      '4x3': { data: null, blob: null, completed: false },
      '3x2': { data: null, blob: null, completed: false }
    };

    // Naming Settings State
    let namingSettings = {
      prefix: 'screenshot_',
      numberingStyle: '001',
      includeTimestamp: false,
      includeIndex: true,
      includeFrame: false,
      framerate: 30
    };

    const toolInfoIcon = document.getElementById('toolInfoButton');
    const toolInfoModal = document.getElementById('toolInfoModal');
    const modalClose = document.getElementById('modalClose');

    const screenshotLightbox = document.getElementById('screenshotLightbox');
    const lightboxClose = document.getElementById('lightboxClose');

    function toggleModal(modal, show) {
        if (show) {
            modal.classList.add('active');
            document.body.style.overflow = 'hidden';
        } else {
            modal.classList.remove('active');
            document.body.style.overflow = '';
        }
    }

    if (toolInfoIcon && toolInfoModal && modalClose) {
        toolInfoIcon.addEventListener('click', () => toggleModal(toolInfoModal, true));
        modalClose.addEventListener('click', () => toggleModal(toolInfoModal, false));
        toolInfoModal.addEventListener('click', (e) => { if (e.target === toolInfoModal) toggleModal(toolInfoModal, false); });
        document.addEventListener('keydown', (e) => { if (e.key === 'Escape' && toolInfoModal.classList.contains('active')) toggleModal(toolInfoModal, false); });
    }

    if (screenshotLightbox && lightboxClose) {
        lightboxClose.addEventListener('click', () => toggleModal(screenshotLightbox, false));
        screenshotLightbox.addEventListener('click', (e) => {
            if (e.target === screenshotLightbox || e.target.closest('.screenshot-lightbox-container')) {
                // Close when clicking overlay or container, not controls
                if (!e.target.closest('.screenshot-lightbox-info') && e.target !== lightboxClose && !lightboxClose.contains(e.target)) {
                     toggleModal(screenshotLightbox, false);
                }
            }
        });
        // Hotkeys in Lightbox
         document.addEventListener('keydown', (e) => {
            if (screenshotLightbox.classList.contains('active')) {
                 if (e.key === 'Escape') toggleModal(screenshotLightbox, false);
                 if (e.key === 'ArrowLeft' || e.key === 'a') document.getElementById('lightboxPrevBtn')?.click();
                 if (e.key === 'ArrowRight' || e.key === 'd') document.getElementById('lightboxNextBtn')?.click();
                 if (e.key === 'ArrowDown' || e.key === 's') document.getElementById('lightboxDeleteBtn')?.click();
                 if (e.key === 'q') document.getElementById('lightboxAdjustPrev')?.click();
                 if (e.key === 'e') document.getElementById('lightboxAdjustNext')?.click();
             }
        });
    }

    // Naming Settings Modal
    const namingSettingsModal = document.getElementById('namingSettingsModal');
    const namingSettingsClose = document.getElementById('namingSettingsClose');
    const namingSettingsButton = document.getElementById('namingSettingsButton');
    const namingSettingsButtonSmart = document.getElementById('namingSettingsButtonSmart');
    const namingSettingsButtonManual = document.getElementById('namingSettingsButtonManual');
    const filenamePrefix = document.getElementById('filenamePrefix');
    const includeTimestamp = document.getElementById('includeTimestamp');
    const numberingStyleSelect = document.getElementById('numberingStyleSelect');
    const saveNamingSettings = document.getElementById('saveNamingSettings');
    const namingSettingsExample = document.getElementById('namingSettingsExample');
    const namingSettingsExampleText = document.getElementById('namingSettingsExampleText');
    const includeFrame = document.getElementById('includeFrame');
    const framerateInput = document.getElementById('framerateInput');

    const openNamingSettingsModal = () => {
        if (filenamePrefix) filenamePrefix.value = namingSettings.prefix;
        if (includeTimestamp) includeTimestamp.checked = namingSettings.includeTimestamp;
        if (numberingStyleSelect) numberingStyleSelect.value = namingSettings.numberingStyle;
        if (includeFrame) includeFrame.checked = namingSettings.includeFrame;
        if (framerateInput) framerateInput.value = namingSettings.framerate;
        if (framerateRow) framerateRow.style.display = namingSettings.includeFrame ? 'flex' : 'none';
        updateNamingSettingsExample();
        toggleModal(namingSettingsModal, true);
    };

    if (namingSettingsButton && namingSettingsModal && namingSettingsClose) {
        namingSettingsButton.addEventListener('click', openNamingSettingsModal);
        namingSettingsClose.addEventListener('click', () => toggleModal(namingSettingsModal, false));
        namingSettingsModal.addEventListener('click', (e) => { 
            if (e.target === namingSettingsModal) toggleModal(namingSettingsModal, false); 
        });
        document.addEventListener('keydown', (e) => { 
            if (e.key === 'Escape' && namingSettingsModal.classList.contains('active')) toggleModal(namingSettingsModal, false); 
        });
    }

    if (namingSettingsButtonSmart) {
        namingSettingsButtonSmart.addEventListener('click', openNamingSettingsModal);
    }

    if (namingSettingsButtonManual) {
        namingSettingsButtonManual.addEventListener('click', openNamingSettingsModal);
    }

    if (numberingStyleSelect) {
        numberingStyleSelect.addEventListener('change', () => {
            namingSettings.numberingStyle = numberingStyleSelect.value;
            updateNamingSettingsExample();
        });
    }

    if (saveNamingSettings) {
        saveNamingSettings.addEventListener('click', () => {
            if (filenamePrefix) namingSettings.prefix = filenamePrefix.value || 'screenshot_';
            if (includeTimestamp) namingSettings.includeTimestamp = includeTimestamp.checked;
            if (numberingStyleSelect) namingSettings.numberingStyle = numberingStyleSelect.value;
            if (includeFrame) namingSettings.includeFrame = includeFrame.checked;
            if (framerateInput) namingSettings.framerate = parseInt(framerateInput.value) || 30;
            toggleModal(namingSettingsModal, false);
        });
    }

    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    document.addEventListener('DOMContentLoaded', () => {
      try {
        const $ = (id) => document.getElementById(id);
        const $$ = (selector, parent = document) => parent.querySelectorAll(selector);

        const dropZone = $('dropZone');
        const videoInput = $('videoInput');
        const selectFileButton = $('selectFileButton');
        const initialSelectFileButton = $('initialSelectFileButton');
        const tryExampleButton = $('tryExampleButton');
        const resolutionValue = $('resolutionValue');
        const lengthValue = $('lengthValue');
        const aspectRatioValue = $('aspectRatioValue');
        const bitrateValue = $('bitrateValue');
        const imageCountDisplay = $('imageCountDisplay');
        const imageCountValue = $('imageCountValue');
        const modeTabs = $$('.mode-tab');
        const modeContentDiv = $$('.mode-content')[0];
        const intervalInput = $('intervalInput');
        const intervalValue = $('intervalValue');
        // Global Format/Quality Controls
        const captureFormatSelect = $('captureFormatSelect');
        const jpegQualityGlobalRow = $('jpegQualityGlobalRow');
        const jpegQualityGlobal = $('jpegQualityGlobal');
        const jpegQualityGlobalValue = $('jpegQualityGlobalValue');
        const webpQualityGlobalRow = $('webpQualityGlobalRow');
        const webpQualityGlobal = $('webpQualityGlobal');
        const webpQualityGlobalValue = $('webpQualityGlobalValue');
        // Smart Auto Controls
        const smartAlgoTabs = $$('.smart-tab');
        const histThresholdSettings = $('histThresholdSettings');
        const pixelThresholdSettings = $('pixelThresholdSettings');
        const histThresholdInput = $('histThresholdInput');
        const histThresholdValue = $('histThresholdValue');
        const pixelThresholdInput = $('pixelThresholdInput');
        const pixelThresholdValue = $('pixelThresholdValue');
        const pixelDiffDisclaimer = $('pixelDiffDisclaimer');
        // Buttons & Progress
        const processButton = $('processButton');
        const downloadAllButton = $('downloadAllButton');
        const progressBarAuto = $('progressBarAuto');
        const progressBarFillAuto = $('progressBarFillAuto');
        const processSmartButton = $('processSmartButton');
        const downloadAllSmartButton = $('downloadAllSmartButton');
        const progressBarSmart = $('progressBarSmart');
        const progressBarFillSmart = $('progressBarFillSmart');
        // Manual Controls
        const manualVideo = $('manualVideo');
        const extractManualButton = $('extractManualButton');
        const addManualButton = $('addManualButton');
        const downloadManualButton = $('downloadManualButton');
        // Grid Controls
        const contactSheetVideo = $('contactSheetVideo');
        const contactSheetControlsElement = $$('.grid-controls')[0];
        const processContactSheetButton = $('processContactSheetButton');
        const downloadContactSheetButton = $('downloadContactSheetButton');
        const previewContactSheetButton = $('previewContactSheetButton');
        const progressBarContactSheet = $('progressBarContactSheet');
        let progressBarFillContactSheet = $('progressBarFillContactSheet');
        const contactSheetCanvas = $('contactSheetCanvas');
        const contactSheetPreviewElement = $('contactSheetPreview');
        const largeGridDisclaimer = $('largeGridDisclaimer');
        // Other
        const removeBarsToggle = $('removeBarsToggle');
        const addTimestampToggle = $('addTimestampToggle');
        const screenshotsDiv = $('screenshots');
        const video = $('video');
        const canvas = $('canvas');
        const frameCanvas = $('frameCanvas');
        const clearScreenshotsButton = $('clearScreenshotsButton');
        const outputColumn = $('outputColumn');
        const gridSizeTabs = $$('.grid-size-tab');
        const customGridControls = $('customGridControls');
        const customGridCols = $('customGridCols');
        const customGridRows = $('customGridRows');
        const gridOutputWidth = $('gridOutputWidth');
        const gridOutputWidthSlider = $('gridOutputWidthSlider');
        const gridOutputWidthValue = $('gridOutputWidthValue');

        // Naming Settings
        const namingSettingsButton = $('namingSettingsButton');
        const namingSettingsButtonSmart = $('namingSettingsButtonSmart');
        const namingSettingsButtonManual = $('namingSettingsButtonManual');
        const namingSettingsModal = $('namingSettingsModal');
        const namingSettingsClose = $('namingSettingsClose');
        const filenamePrefix = $('filenamePrefix');
        const includeTimestamp = $('includeTimestamp');
        const numberingStyleSelect = $('numberingStyleSelect');
        const saveNamingSettings = $('saveNamingSettings');

        verticalSeparatorElement = $$('.vertical-separator')[0];

        [dropZone, videoInput, selectFileButton, video, manualVideo, canvas, frameCanvas, contactSheetCanvas, modeContentDiv, screenshotsDiv, clearScreenshotsButton, processContactSheetButton, downloadContactSheetButton, previewContactSheetButton, progressBarContactSheet, $('loadedFileInfo'), $('loadedFileName'), imageCountDisplay, imageCountValue, contactSheetVideo, contactSheetControlsElement, contactSheetPreviewElement, largeGridDisclaimer, outputColumn, histThresholdInput, histThresholdValue, histThresholdSettings, pixelThresholdInput, pixelThresholdValue, pixelThresholdSettings, captureFormatSelect, jpegQualityGlobalRow, jpegQualityGlobal, jpegQualityGlobalValue, webpQualityGlobalRow, webpQualityGlobal, webpQualityGlobalValue, pixelDiffDisclaimer].forEach(el => {
            if (!el) throw new Error(`Missing critical HTML element: ${el?.id || 'unknown'}`);
        });
        if (!progressBarFillContactSheet) throw new Error("Missing critical HTML element: progressBarFillContactSheet");

        let currentMode = 'manual';
        let smartAlgorithm = 'histogram';
        let uploadedFile = null;
        let currentVideoDuration = 0;
        let processingActive = false;
        let cancelExtractionRequested = false;
        let screenshotBlobs = [];
        let manualScreenshotBlobs = [];
        let contactSheetBlob = null; // This holds the *final generated* image blob
        let contactSheetPreviewData = new Array(20).fill(null); // Holds data for *preview* cells {blob, timestamp, blobUrl}
        let currentSamplingProcess = null;

        if (imageCountValue) imageCountValue.classList.add('manual-mode');

        const buttonGroups = {
            auto: $('intervalModeButtons'),
            autoSmart: $('smartModeButtons'),
            contactSheet: $('contactSheetModeButtons'),
            manual: $('manualModeButtons')
        };
        Object.values(buttonGroups).forEach(group => { if (group) group.style.display = 'none'; });
        if (buttonGroups.manual) buttonGroups.manual.style.display = 'flex';

        const progressBarElements = {
            auto: progressBarAuto,
            autoSmart: progressBarSmart,
            contactSheet: progressBarContactSheet
        };
        const progressBarFillElements = {
             auto: progressBarFillAuto,
             autoSmart: progressBarFillSmart,
             contactSheet: progressBarFillContactSheet
        };

        const formatTime = (seconds) => {
            if (isNaN(seconds)) seconds = 0;
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            const ms = Math.floor((seconds % 1) * 100);
            return h > 0 ? `${h}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}` : `${m}:${s.toString().padStart(2, '0')}`;
        };
        const parseTimeString = (timeStr) => {
            try {
                if (!timeStr.includes(':')) {
                    const directSeconds = parseFloat(timeStr);
                    return isNaN(directSeconds) ? 0 : directSeconds;
                }
                const parts = timeStr.trim().split(':').map(parseFloat);
                if (parts.length === 2 && !parts.some(isNaN)) return parts[0] * 60 + parts[1];
                if (parts.length === 3 && !parts.some(isNaN)) return parts[0] * 3600 + parts[1] * 60 + parts[2];
                console.warn("Invalid time format:", timeStr);
                return 0;
            } catch { return 0; }
        };
        const gcd = (a, b) => b ? gcd(b, a % b) : a;
        const getCommonAspectRatio = (width, height) => {
            if (!width || !height) return '-';
            const rawRatio = width / height;
            const commonRatios = [{ ratio: 16/9, display: "16:9" },{ ratio: 4/3, display: "4:3" },{ ratio: 21/9, display: "21:9" },{ ratio: 2/1, display: "2:1" },{ ratio: 1.85/1, display: "1.85:1" },{ ratio: 2.35/1, display: "2.35:1" },{ ratio: 2.39/1, display: "2.39:1" },{ ratio: 2.40/1, display: "2.4:1" },{ ratio: 3/2, display: "3:2" },{ ratio: 5/4, display: "5:4" },{ ratio: 1/1, display: "1:1" },{ ratio: 9/16, display: "9:16" }];
            const TOLERANCE = 0.005;
            for (const { ratio, display } of commonRatios) { if (Math.abs(rawRatio - ratio) / ratio < TOLERANCE) return display; }
            const a = Math.round(width), b = Math.round(height);
            const divisor = gcd(a, b);
            return `${a / divisor}:${b / divisor}`;
        };
        const getStandardizedResolution = (width, height) => {
             if (!width || !height) return '-';
            const roundWidth = (w) => { if (w % 10 === 0) return w; const lastDigit = w % 10; return lastDigit <= 4 ? w - lastDigit : w + (10 - lastDigit); };
            return `${roundWidth(Math.round(width))}×${roundWidth(Math.round(height))}`;
        };
        const updateFileInfoDisplay = () => {
            if (!video?.duration || !isFinite(video.duration) || !video?.videoWidth || !video?.videoHeight || !resolutionValue || !lengthValue || !aspectRatioValue || !bitrateValue) {
                return;
            }
            currentVideoDuration = video.duration;
            let width = video.videoWidth, height = video.videoHeight;
            if (removeBarsEnabled && cropData && cropData.cropWidth > 0 && cropData.cropHeight > 0) { width = cropData.cropWidth; height = cropData.cropHeight; }
            lengthValue.textContent = formatTime(currentVideoDuration);
            resolutionValue.textContent = getStandardizedResolution(width, height);
            aspectRatioValue.textContent = getCommonAspectRatio(width, height);
            if (uploadedFile?.size > 0 && currentVideoDuration > 0) { const bitrateKbps = Math.round((uploadedFile.size * 8) / currentVideoDuration / 1000); bitrateValue.textContent = `${bitrateKbps} kbps`; } else { bitrateValue.textContent = "N/A"; }
        };
        const calculateGridOutputHeight = () => {
            if (!gridOutputWidth || !video?.videoWidth || !video?.videoHeight) {
                if (gridOutputWidthValue) {
                    gridOutputWidthValue.textContent = '-';
                }
                return;
            }
            
            const activeGridSizeTab = $$('.grid-size-tab.active')[0];
            if (!activeGridSizeTab) return;
            
            const cols = parseInt(activeGridSizeTab.getAttribute('data-cols') || 5);
            const rows = parseInt(activeGridSizeTab.getAttribute('data-rows') || 4);
            
            const outputWidth = parseInt(gridOutputWidth.value) || 3000;
            const videoAspectRatio = video.videoWidth / video.videoHeight;
            
            const cellWidth = outputWidth / cols;
            const cellHeight = cellWidth / videoAspectRatio;
            const outputHeight = Math.round(cellHeight * rows);
            
            if (gridOutputWidthValue) {
                gridOutputWidthValue.textContent = `${outputHeight}px`;
            }
        };

        const updateImageCount = () => {
            const screenshotCount = screenshotBlobs.length;
            const manualCount = manualScreenshotBlobs.length;
            let totalCount = 0;
             if (currentMode === 'manual') totalCount = manualCount;
             else if (currentMode === 'auto' || currentMode === 'autoSmart') totalCount = screenshotCount;
             else if (currentMode === 'contactSheet') totalCount = contactSheetPreviewData.filter(d => d?.blob).length;

            if (imageCountValue) {
                imageCountValue.textContent = totalCount;
                imageCountValue.classList.remove('interval-mode', 'smart-mode', 'manual-mode', 'grid-mode');
                if (currentMode === 'auto') imageCountValue.classList.add('interval-mode');
                else if (currentMode === 'autoSmart') imageCountValue.classList.add('smart-mode');
                else if (currentMode === 'manual') imageCountValue.classList.add('manual-mode');
                else if (currentMode === 'contactSheet') imageCountValue.classList.add('grid-mode');
            }
            const hasAutoOrSmartScreenshots = screenshotBlobs.length > 0;
            const hasManualScreenshots = manualScreenshotBlobs.length > 0;
            const hasContactSheetPreview = contactSheetPreviewData.some(d => d !== null);

            if(downloadAllButton) downloadAllButton.disabled = !hasAutoOrSmartScreenshots || processingActive;
            if(downloadAllSmartButton) downloadAllSmartButton.disabled = !hasAutoOrSmartScreenshots || processingActive;
            if(downloadManualButton) downloadManualButton.disabled = !hasManualScreenshots || processingActive;
            if(namingSettingsButton) namingSettingsButton.disabled = !hasAutoOrSmartScreenshots && !hasManualScreenshots || processingActive;
            if(namingSettingsButtonSmart) namingSettingsButtonSmart.disabled = !hasAutoOrSmartScreenshots && !hasManualScreenshots || processingActive;
            if(namingSettingsButtonManual) namingSettingsButtonManual.disabled = !hasAutoOrSmartScreenshots && !hasManualScreenshots || processingActive;
            // Grid buttons depend on whether a blob exists *and* it's not marked as needing update
            const needsUpdate = processContactSheetButton?.classList.contains('needs-update');
            if(downloadContactSheetButton) downloadContactSheetButton.disabled = !contactSheetBlob || processingActive || needsUpdate;
            if(previewContactSheetButton) previewContactSheetButton.disabled = !contactSheetBlob || processingActive || needsUpdate;
            if(clearScreenshotsButton) clearScreenshotsButton.disabled = !hasAutoOrSmartScreenshots && !hasManualScreenshots && !hasContactSheetPreview && !contactSheetBlob;
        };
        const updateDropZoneUI = (isFileLoaded, filename) => {
          if(!dropZone || !selectFileButton || !$('loadedFileName')) return;
          const appContainer = $$('.app-container')[0];
          dropZone.classList.toggle('file-loaded', isFileLoaded);
          if (appContainer) appContainer.classList.toggle('file-loaded', isFileLoaded);
          if (isFileLoaded && filename) {
            $('loadedFileName').textContent = filename;
            selectFileButton.textContent = "Change File";
            selectFileButton.classList.add('file-selected');
            // Don't call updateFileInfoDisplay here, wait for 'loadedmetadata'
          } else {
            dropZone.classList.remove('file-loaded');
            if (appContainer) appContainer.classList.remove('file-loaded');
            dropZone.classList.remove('has-bg-image');
            const oldBgUrl = dropZone.dataset.bgUrl;
            if (oldBgUrl) URL.revokeObjectURL(oldBgUrl);
            dropZone.dataset.bgUrl = '';
            document.documentElement.style.setProperty('--dropzone-bg-image', 'none');
            $('loadedFileName').textContent = '';
            selectFileButton.textContent = "Change File";
            selectFileButton.classList.remove('file-selected');
            if(resolutionValue) resolutionValue.textContent = '-'; if(lengthValue) lengthValue.textContent = '-'; if(aspectRatioValue) aspectRatioValue.textContent = '-'; if(bitrateValue) bitrateValue.textContent = '-';
            if(intervalInput) intervalInput.value = '10'; if(intervalValue) intervalValue.textContent = '10s';
            if(histThresholdInput) histThresholdInput.value = '0.50'; if(histThresholdValue) histThresholdValue.textContent = '50%';
            if(pixelThresholdInput) pixelThresholdInput.value = '50'; if(pixelThresholdValue) pixelThresholdValue.textContent = '50%';
            if(removeBarsToggle) removeBarsToggle.checked = false;
            if(addTimestampToggle) addTimestampToggle.checked = false;
            if(manualTimeInput) manualTimeInput.value = '0:00';
            if(manualFrameInput) manualFrameInput.value = '0';
            if(captureFormatSelect) captureFormatSelect.value = 'png';
          }
        };
        const resetProcessingUI = (mode = 'all') => {
            processingActive = false; cancelExtractionRequested = false; currentSamplingProcess = null;
            if (verticalSeparatorElement) verticalSeparatorElement.classList.remove('loading', 'loading-smart', 'loading-grid');

            const resetBtn = (btn, text, startHandler, iconClass = null) => {
                 if (!btn) return;
                 btn.disabled = !video?.src;
                 btn.innerHTML = '';
                 
                 // All buttons now have icon after text
                 btn.appendChild(document.createTextNode(text));
                 if (iconClass) {
                     const icon = document.createElement('i');
                     icon.className = iconClass;
                     btn.appendChild(icon);
                 }

                 btn.classList.remove('cancel-active');
                 btn.classList.remove('needs-update');
                 btn.style.background = '';
                 btn.removeEventListener('click', handleCancelClick);

                 const existingListeners = btn._startHandlers || {};
                 Object.values(existingListeners).forEach(handler => btn.removeEventListener('click', handler));
                 if (startHandler) {
                     btn.addEventListener('click', startHandler);
                     btn._startHandlers = { [mode]: startHandler };
                 } else {
                    btn._startHandlers = {};
                 }
             };

            resetBtn(processButton, 'Extract Screenshots', startAutoExtraction, 'ri-scissors-line');
            resetBtn(processSmartButton, 'Extract Smart Shots', startSmartExtraction, 'ri-scissors-line');
            resetBtn(processContactSheetButton, 'Generate/Update Grid', generateContactSheet);
            resetBtn(addManualButton, 'Cut Frame', addManualButton.onclick, 'ri-scissors-line');
            resetBtn(extractManualButton, 'Save Frame', extractManualButton.onclick, 'ri-download-line');

            if (addManualButton) addManualButton.disabled = !video?.src;
            if (extractManualButton) extractManualButton.disabled = !video?.src;

            Object.entries(progressBarElements).forEach(([key, bar]) => {
                if (bar && (mode === key || mode === 'all')) bar.style.display = 'none';
                if (progressBarFillElements[key]) progressBarFillElements[key].style.width = '0%';
            });

            if(downloadContactSheetButton) {
                downloadContactSheetButton.title = '';
                downloadContactSheetButton.classList.remove('needs-update');
            }
            if(previewContactSheetButton) {
                previewContactSheetButton.title = '';
                previewContactSheetButton.classList.remove('needs-update');
            }

            updateImageCount();
        };

        const setProcessingUI = (mode) => {
            processingActive = true; cancelExtractionRequested = false;
            [processButton, processSmartButton, processContactSheetButton, downloadAllButton, downloadAllSmartButton, downloadManualButton, downloadContactSheetButton, previewContactSheetButton, addManualButton, extractManualButton, clearScreenshotsButton, namingSettingsButton, namingSettingsButtonSmart, namingSettingsButtonManual].forEach(btn => {
                if (btn) btn.disabled = true;
            });

            let processBtn, progressBar, loadingClass, startHandler;
            if (mode === 'auto') { processBtn = processButton; progressBar = progressBarElements.auto; loadingClass = 'loading'; startHandler = startAutoExtraction; }
            else if (mode === 'autoSmart') { processBtn = processSmartButton; progressBar = progressBarElements.autoSmart; loadingClass = 'loading-smart'; startHandler = startSmartExtraction; }
            else if (mode === 'contactSheet') { processBtn = processContactSheetButton; progressBar = progressBarElements.contactSheet; loadingClass = 'loading-grid'; startHandler = generateContactSheet;}
            else return;

            if (verticalSeparatorElement && loadingClass) verticalSeparatorElement.classList.add(loadingClass);
            if (progressBar) progressBar.style.display = 'block';
            if (progressBarFillElements[mode]) progressBarFillElements[mode].style.width = '0%';

             const icon = processBtn.querySelector('i, svg');
             if(icon) icon.remove();

            processBtn.textContent = 'Cancel Extraction';
            processBtn.classList.add('cancel-active');
            processBtn.classList.remove('needs-update');
            processBtn.style.background = '';

            const existingHandlers = processBtn._startHandlers || {};
             Object.values(existingHandlers).forEach(handler => processBtn.removeEventListener('click', handler));
             processBtn._startHandlers = {};

            processBtn.removeEventListener('click', handleCancelClick);
            processBtn.addEventListener('click', handleCancelClick);
            processBtn.disabled = false;
        };

        const handleCancelClick = () => {
            cancelExtractionRequested = true;
            if (currentSamplingProcess?.cancel) currentSamplingProcess.cancel();
        };

        const computeHistogram = (imageData, sampleFactor = 4) => { const data = imageData.data; const hist = new Array(256).fill(0); let count = 0; const step = 4 * sampleFactor; for (let i = 0; i < data.length; i += step) { const gray = Math.round(0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]); hist[gray]++; count++; } return count === 0 ? hist : hist.map(val => val / count); };
        const histogramDifference = (hist1, hist2) => (!hist1 || !hist2 || hist1.length !== hist2.length) ? 1 : hist1.reduce((acc, val, i) => acc + Math.abs(val - hist2[i]), 0);
        const computePixelDiff = (data1, data2, sampleFactor = 4) => { let diff = 0; let count = 0; const step = 4 * sampleFactor; for (let i = 0; i < data1.length; i += step) { diff += Math.abs(data1[i] - data2[i]) + Math.abs(data1[i+1] - data2[i+1]) + Math.abs(data1[i+2] - data2[i+2]); count++; } return count > 0 ? (diff / (count * 3)) : 0; };

         const deleteScreenshot = (itemToDelete, blobArrayRef) => {
             const indexToRemove = blobArrayRef.indexOf(itemToDelete);
             if (indexToRemove > -1) {
                 const [removedItem] = blobArrayRef.splice(indexToRemove, 1);
                 if (removedItem?.blobUrl) URL.revokeObjectURL(removedItem.blobUrl);

                 const parentDiv = (blobArrayRef === manualScreenshotBlobs || blobArrayRef === screenshotBlobs) ? screenshotsDiv : null;
                 if (!parentDiv) return -1;

                 const containerToRemove = parentDiv.querySelector(`.screenshot-container[data-index="${indexToRemove}"]`);

                 if (containerToRemove) {
                     containerToRemove.remove();
                 } else {
                     console.warn("Could not find DOM element to remove for index:", indexToRemove, "Timestamp:", removedItem.timestamp);
                 }

                 const remainingContainers = $$('.screenshot-container', parentDiv);
                 remainingContainers.forEach((container, newIndex) => {
                     container.dataset.index = newIndex.toString();
                 });

                 updateImageCount();
                 return indexToRemove;
             }
             return -1;
         };

        const createScreenshotContainer = (blob, timestamp = -1, blobArrayRef = screenshotBlobs) => {
            if(!screenshotsDiv || !blob) return null;
            const container = document.createElement('div');
            container.className = "screenshot-container";
            container.dataset.timestamp = timestamp.toString();
            const blobUrl = URL.createObjectURL(blob);

            const blobData = { blob, timestamp, blobUrl };
            let insertBeforeNode = null;
            if (blobArrayRef === manualScreenshotBlobs || blobArrayRef === screenshotBlobs) {
                for (let i = 0; i < blobArrayRef.length; i++) {
                    if (blobArrayRef[i].timestamp > timestamp) {
                        insertBeforeNode = screenshotsDiv.querySelector(`.screenshot-container[data-index="${i}"]`);
                        blobArrayRef.splice(i, 0, blobData);
                        break;
                    }
                }
            }
            if (!insertBeforeNode) {
                blobArrayRef.push(blobData);
            }

            const currentIndex = blobArrayRef.indexOf(blobData);
            container.dataset.index = currentIndex.toString();
            container.dataset.blobUrl = blobUrl;

            const img = document.createElement('img');
            img.className = "screenshot-img";
            img.src = blobUrl;

            const imgContainer = document.createElement('div');
            imgContainer.className = 'img-container';
            imgContainer.style.cursor = 'pointer';
            imgContainer.appendChild(img);
            container.appendChild(imgContainer);

            imgContainer.addEventListener('click', () => {
                 const indexFromData = parseInt(container.dataset.index);
                 let clickedItem = null;
                 let actualIndex = -1;

                 if (!isNaN(indexFromData) && indexFromData >= 0 && indexFromData < blobArrayRef.length) {
                      clickedItem = blobArrayRef[indexFromData];
                      actualIndex = indexFromData;
                 }

                 if (actualIndex > -1 && clickedItem) {
                     openLightbox(clickedItem, blobArrayRef, actualIndex);
                 } else {
                    console.error("Could not determine item for lightbox. Index:", indexFromData, "Array length:", blobArrayRef.length);
                 }
             });

            const downloadBtn = document.createElement('button');
            downloadBtn.className = "action-icon-button action-icon-button--download thumbnail-download-btn";
            downloadBtn.title = "Download this screenshot";
            downloadBtn.style.position = 'absolute';
            downloadBtn.style.top = '6px';
            downloadBtn.style.right = '6px';
            downloadBtn.style.minWidth = '28px';
            downloadBtn.style.minHeight = '28px';
            downloadBtn.style.zIndex = '3';
            downloadBtn.innerHTML = '<i class="ri-download-2-line"></i>';
            downloadBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const extension = blob.type === 'image/jpeg' ? 'jpg' : (blob.type.split('/')[1] || 'png');
                const timeSuffix = (timestamp !== undefined && timestamp >= 0) ? `_${formatTime(timestamp).replace(':','-')}` : `_${currentIndex + 1}`;
                const filename = `screenshot${timeSuffix}.${extension}`;
                const tempLink = document.createElement('a');
                tempLink.href = blobUrl;
                tempLink.download = filename;
                document.body.appendChild(tempLink);
                tempLink.click();
                document.body.removeChild(tempLink);
            });
            container.appendChild(downloadBtn);

            if (timestamp >= 0) {
                const overlay = document.createElement('div');
                overlay.className = "screenshot-overlay";
                overlay.textContent = formatTime(timestamp);
                container.appendChild(overlay);
            }

            const delBtn = document.createElement('button');
            delBtn.className = "action-icon-button action-icon-button--delete lightbox-delete-btn";
            delBtn.title = "Remove this screenshot";
            delBtn.innerHTML = DELETE_ICON_SVG;
            delBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const currentItemIndex = blobArrayRef.indexOf(blobData);
                if (currentItemIndex > -1) {
                    deleteScreenshot(blobData, blobArrayRef);
                    if (screenshotLightbox?.classList.contains('active')) {
                        toggleModal(screenshotLightbox, false);
                    }
                } else {
                    console.error("Item to delete not found in array.");
                }
            });

            container.appendChild(delBtn);

            if (blobArrayRef === screenshotBlobs && timestamp >= 0) {
                const btnContainer = document.createElement('div');
                btnContainer.className = 'frame-adjust-buttons';
                
                const createAdjustBtn = (text, offset, title) => {
                    const btn = document.createElement('div');
                    btn.className = 'frame-adjust-btn';
                    if (text === '-') btn.innerHTML = `-<i class="ri-scissors-line icon-flipped"></i>`;
                    else if (text === '+') btn.innerHTML = `<i class="ri-scissors-line"></i>+`;
                    else btn.textContent = text;
                    btn.title = title;
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const arrayType = currentMode === 'autoSmart' ? 'autoSmart' : 'auto';
                                            const containerEl = btn.closest('.screenshot-container');
                        const idx = containerEl ? parseInt(containerEl.dataset.index) : -1;
                        if (idx >= 0) {
                            adjustFrameTime(idx, offset, arrayType);
                        }
                    });
                    return btn;
                };
                
                btnContainer.appendChild(createAdjustBtn('-', -1, 'Cut forward by 1s'));
                btnContainer.appendChild(createAdjustBtn('+', 1, 'Cut backward by 1s'));
                container.appendChild(btnContainer);
            }

            if (insertBeforeNode) {
                screenshotsDiv.insertBefore(container, insertBeforeNode);
            } else {
                screenshotsDiv.appendChild(container);
            }

            const allContainers = $$('.screenshot-container', screenshotsDiv);
            allContainers.forEach((cont, idx) => {
                cont.dataset.index = idx.toString();
            });


            return container;
        };


        const openLightbox = (item, blobArrayRef, currentIndex) => {
             const lightboxImage = $('lightboxImage');
             const lightboxTimestamp = $('lightboxTimestamp');
             const lightboxDownload = $('lightboxDownload');
             const prevBtn = $('lightboxPrevBtn');
             const nextBtn = $('lightboxNextBtn');
             const deleteBtnContainer = $('lightboxDeleteBtn').parentNode;
             let deleteBtn = $('lightboxDeleteBtn');
             const lightboxAdjustControls = $$('.lightbox-frame-adjust-controls');
             const lightboxAdjustPrev = $('lightboxAdjustPrev');
             const lightboxAdjustNext = $('lightboxAdjustNext');
             const lightboxContent = $$('.info-box-content.screenshot-lightbox-content')[0];
             const frameNumberSpan = $('lightboxFrameNumber');

             if (!lightboxImage || !lightboxTimestamp || !lightboxDownload || !screenshotLightbox || !prevBtn || !nextBtn || !item || !deleteBtnContainer || !lightboxAdjustControls || lightboxAdjustControls.length === 0 || !lightboxAdjustPrev || !lightboxAdjustNext || !lightboxContent || !frameNumberSpan) return;

             const arrayType = blobArrayRef === contactSheetPreviewData ? 'contactSheet' : (blobArrayRef === manualScreenshotBlobs ? 'manual' : 'auto');
             screenshotLightbox.dataset.currentIndex = currentIndex.toString();
             screenshotLightbox.dataset.arrayType = arrayType;
             screenshotLightbox.dataset.itemId = item.timestamp;

             const isContactSheet = arrayType === 'contactSheet';
             const isSmartAuto = arrayType === 'auto';
             const shouldShowAdjustControls = isContactSheet || isSmartAuto;
             lightboxAdjustControls.forEach(control => {
                 control.style.display = shouldShowAdjustControls ? 'inline-flex' : 'none';
             });
             lightboxContent.classList.toggle('grid-mode', isContactSheet);

             screenshotLightbox.dataset.blobArrayRef = arrayType;

             updateLightboxContent(currentIndex, blobArrayRef);
             toggleModal(screenshotLightbox, true);

             prevBtn.onclick = () => navigateLightbox(-1);
             nextBtn.onclick = () => navigateLightbox(1);

             const newDeleteBtn = document.createElement('button');
             newDeleteBtn.id = 'lightboxDeleteBtn';
             newDeleteBtn.className = "action-icon-button action-icon-button--delete lightbox-delete-btn";
             newDeleteBtn.title = "Delete this screenshot (Hotkeys: 🡫, S)";
             newDeleteBtn.innerHTML = DELETE_ICON_SVG;
             if (isContactSheet) {
                 newDeleteBtn.style.display = 'none';
             }
             deleteBtnContainer.replaceChild(newDeleteBtn, deleteBtn);
             deleteBtn = newDeleteBtn;

             deleteBtn.onclick = () => {
                 const currentIdx = parseInt(screenshotLightbox.dataset.currentIndex || '0');
                 const currentArrayType = screenshotLightbox.dataset.arrayType || 'auto';
                 let currentBlobArrayRef;
                 if (currentArrayType === 'contactSheet') currentBlobArrayRef = contactSheetPreviewData;
                 else if (currentArrayType === 'manual') currentBlobArrayRef = manualScreenshotBlobs;
                 else currentBlobArrayRef = screenshotBlobs;

                 if (currentIdx >= 0 && currentIdx < currentBlobArrayRef.length) {
                     const itemToDelete = currentBlobArrayRef[currentIdx];
                     if (currentArrayType === 'contactSheet') {
                     } else {
                         const deletedIndex = deleteScreenshot(itemToDelete, currentBlobArrayRef);
                         if (deletedIndex > -1) {
                             if (currentBlobArrayRef.length === 0) {
                                 toggleModal(screenshotLightbox, false); return;
                             }
                             const newIndex = Math.min(deletedIndex, currentBlobArrayRef.length - 1);
                             screenshotLightbox.dataset.currentIndex = newIndex.toString();
                             updateLightboxContent(newIndex, currentBlobArrayRef);
                             updateNavButtonVisibility(newIndex, currentBlobArrayRef.length);
                         }
                     }
                 }
             };

             lightboxAdjustPrev.onclick = () => adjustFrameTimeFromLightbox(-1);
             lightboxAdjustNext.onclick = () => adjustFrameTimeFromLightbox(1);

             updateNavButtonVisibility(currentIndex, blobArrayRef.length);
         };

        const adjustFrameTimeFromLightbox = (offset) => {
            if (!screenshotLightbox.classList.contains('active')) return;
            const currentIndex = parseInt(screenshotLightbox.dataset.currentIndex || '-1');
            const arrayType = screenshotLightbox.dataset.arrayType || 'auto';
            if (currentIndex >= 0) {
                adjustFrameTime(currentIndex, offset, arrayType);
            }
        };


         const updateLightboxContent = (index, blobArrayRef) => {
             const lightboxImage = $('lightboxImage');
             const lightboxTimestamp = $('lightboxTimestamp');
             const lightboxDownload = $('lightboxDownload');
             const frameNumberSpan = $('lightboxFrameNumber');
             const isContactSheet = blobArrayRef === contactSheetPreviewData;

             if (index >= 0 && index < blobArrayRef.length && lightboxImage && lightboxTimestamp && lightboxDownload && frameNumberSpan) {
                 const item = blobArrayRef[index];
                 if (!item || !item.blobUrl) {
                     lightboxImage.src = '';
                     lightboxTimestamp.textContent = '-';
                     lightboxDownload.href = '#';
                     frameNumberSpan.textContent = '';
                     return;
                 }
                 const newBlobUrl = item.blobUrl;

                 lightboxImage.src = newBlobUrl;
                 lightboxImage.dataset.blobUrl = newBlobUrl;

                 lightboxTimestamp.textContent = item.timestamp >= 0 ? formatTime(item.timestamp) : '';
                 frameNumberSpan.textContent = isContactSheet ? `Frame ${index + 1}` : '';

                 const filename = generateFilename(item, index);
                 lightboxDownload.href = newBlobUrl;
                 lightboxDownload.download = filename;
             }
         };

        const navigateLightbox = (direction) => {
            if (!screenshotLightbox) return;
            const currentIndex = parseInt(screenshotLightbox.dataset.currentIndex || '0');
            const arrayType = screenshotLightbox.dataset.arrayType || 'auto';
            let blobArrayRef;
            if (arrayType === 'contactSheet') blobArrayRef = contactSheetPreviewData;
            else if (arrayType === 'manual') blobArrayRef = manualScreenshotBlobs;
            else blobArrayRef = screenshotBlobs;

            let newIndex = currentIndex + direction;
            while (arrayType === 'contactSheet' && newIndex >= 0 && newIndex < blobArrayRef.length && !blobArrayRef[newIndex]) {
                newIndex += direction;
            }

            if (newIndex >= 0 && newIndex < blobArrayRef.length) {
                screenshotLightbox.dataset.currentIndex = newIndex.toString();
                updateLightboxContent(newIndex, blobArrayRef);
                updateNavButtonVisibility(newIndex, blobArrayRef.length);
            }
        };

        const updateNavButtonVisibility = (currentIndex, totalItems) => {
            const prevBtn = $('lightboxPrevBtn');
            const nextBtn = $('lightboxNextBtn');
            if (prevBtn && nextBtn) { prevBtn.disabled = currentIndex <= 0; nextBtn.disabled = currentIndex >= totalItems - 1; }
        };

        const getFileExtensionFromType = (type) => (!type || type === 'image/png') ? 'png' : (type === 'image/jpeg' ? 'jpg' : type.split('/')[1] || 'png');

        const getCurrentFormatSettings = () => {
             const selectedFormat = captureFormatSelect.value || 'png';
             let quality = 1.0;
             if (selectedFormat === 'jpeg') {
                quality = parseFloat(jpegQualityGlobal?.value || 90) / 100;
             } else if (selectedFormat === 'webp') {
                quality = parseFloat(webpQualityGlobal?.value || 90) / 100;
             }
             return { type: `image/${selectedFormat}`, quality };
         };

         const generateFilename = (item, index) => {
             const { type } = getCurrentFormatSettings();
             const extension = getFileExtensionFromType(type);
             
             // Use the current prefix from the input field, or fall back to namingSettings.prefix
             const currentPrefix = filenamePrefix?.value ?? namingSettings.prefix;
             let filename = currentPrefix;
             
             // Add index if enabled
             if (namingSettings.includeIndex) {
                 const paddedIndex = (index + 1).toString().padStart(namingSettings.numberingStyle.length, '0');
                 filename += paddedIndex;
             }
             
             // Add timestamp if enabled and available
             if (namingSettings.includeTimestamp && item.timestamp !== undefined && item.timestamp >= 0) {
                 const timestampStr = formatTime(item.timestamp).replace(/:/g, '-');
                 filename += filename.length > namingSettings.prefix.length ? '_' + timestampStr : timestampStr;
             }
             // Add frame if enabled
             if (namingSettings.includeFrame && item.timestamp !== undefined && item.timestamp >= 0) {
                 const framerate = namingSettings.framerate || 30;
                 const frameNum = Math.round(item.timestamp * framerate);
                 filename += `_${frameNum}`;
             }
             
             return `${filename}.${extension}`;
         };

         const downloadBlobsAsZip = (blobDataArray, baseFilename = "screenshots") => {
             if (!blobDataArray || blobDataArray.length === 0 || !window.JSZip) { alert(blobDataArray?.length === 0 ? "No screenshots to download." : "Error: JSZip library not loaded."); return; }
             const zip = new JSZip();

             blobDataArray.forEach((item, index) => {
                 if (!item || !item.blob) return;
                 const filename = generateFilename(item, index);
                 zip.file(filename, item.blob);
             });
             zip.generateAsync({ type: "blob" }).then((content) => {
                 const url = URL.createObjectURL(content);
                 const tempLink = document.createElement('a');
                 tempLink.href = url;
                 tempLink.download = `${baseFilename}.zip`;
                 document.body.appendChild(tempLink);
                 tempLink.click();
                 document.body.removeChild(tempLink);
                 URL.revokeObjectURL(url);
             }).catch(err => { console.error("Error generating ZIP:", err); alert("Error creating ZIP file: " + err.message); });
         };

        const handleFileLoad = (file) => {
            if (!video || !manualVideo || !contactSheetVideo || !file) return;
            
            if (file.name === 'ElephantsDream.mp4' || file.name === 'sample-mp4-file.mp4') {
                showSpinner();
            }
            
            uploadedFile = file;
            const fileURL = URL.createObjectURL(file);

             if (video.src && video.src.startsWith('blob:')) URL.revokeObjectURL(video.src);
             if (manualVideo.src && manualVideo.src.startsWith('blob:')) URL.revokeObjectURL(manualVideo.src);
             if (contactSheetVideo.src && contactSheetVideo.src.startsWith('blob:')) URL.revokeObjectURL(contactSheetVideo.src);

            video.src = fileURL;
            manualVideo.src = fileURL;
            contactSheetVideo.src = fileURL;
            updateDropZoneUI(true, file.name);
            resetUIOnNewVideo();

                            const onMetadataLoaded = () => {
                    hideSpinner();
                    updateFileInfoDisplay();
                    updateDropZoneThumbnail();
                    resetProcessingUI('all');
                    calculateGridOutputHeight();
                    // Initial setup for grid inputs based on new duration
                     if (currentMode === 'contactSheet') {
                        const activeGridSizeTab = $$('.grid-size-tab.active')[0];
                        const rows = parseInt(activeGridSizeTab?.getAttribute('data-rows') || 4);
                        const cols = parseInt(activeGridSizeTab?.getAttribute('data-cols') || 5);
                         if (updateContactSheetControlsVisibility(rows, cols)) {
                            generateTimeInputs(rows, cols);
                         }
                     }
                     // Setup manual fine-tune controls
                     setupManualFineTuneControls();
                };

            if (video.readyState >= video.HAVE_METADATA) {
                setTimeout(onMetadataLoaded, 100);
            } else {
                video.addEventListener('loadedmetadata', onMetadataLoaded, { once: true });
            }

            video.addEventListener('error', (e) => {
                 console.error("Video loading error:", e);
                 hideSpinner();
                 alert(`Error loading video: ${file.name}. It might be corrupted or in an unsupported format.`);
                 updateDropZoneUI(false, null);
                 resetUIOnNewVideo();
            });

            if (removeBarsToggle?.checked) {
                video.addEventListener('canplay', () => {
                     setTimeout(() => {
                         detectCropBoundariesMulti(() => {
                             updateDropZoneThumbnail();
                             updateFileInfoDisplay();
                         });
                     }, 200);
                }, { once: true });
            }
        };

        const loadVideoFromURL = async (url, filename) => {
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                const blob = await response.blob();
                const file = new File([blob], filename, { type: 'video/mp4' });
                handleFileLoad(file);
                hideSpinner();
            } catch (error) {
                console.error('Error loading video from URL:', error);
                hideSpinner();
                throw error;
            }
        };

        const handleExampleVideoLoad = async () => {
            const primaryURL = 'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ElephantsDream.mp4';
            const backupURL = 'https://www.learningcontainer.com/wp-content/uploads/2020/05/sample-mp4-file.mp4';
            
            showSpinner();
            try {
                await loadVideoFromURL(primaryURL, 'ElephantsDream.mp4');
            } catch (error) {
                console.log('Primary video failed, trying backup:', error);
                try {
                    await loadVideoFromURL(backupURL, 'sample-mp4-file.mp4');
                } catch (backupError) {
                    console.error('Backup video also failed:', backupError);
                    alert('Failed to load example video. Please try selecting a file manually.');
                    hideSpinner();
                }
            }
        };

        const showSpinner = () => {
            const uploadIconSvg = $('uploadIconSvg');
            const spinnerIcon = $('spinnerIcon');
            if (uploadIconSvg && spinnerIcon) {
                uploadIconSvg.style.display = 'none';
                spinnerIcon.style.display = 'block';
            }
        };

        const hideSpinner = () => {
            const uploadIconSvg = $('uploadIconSvg');
            const spinnerIcon = $('spinnerIcon');
            if (uploadIconSvg && spinnerIcon) {
                uploadIconSvg.style.display = 'block';
                spinnerIcon.style.display = 'none';
            }
        };

        const resetUIOnNewVideo = () => {
             $$('.screenshot-container', screenshotsDiv).forEach(container => {
                 if (container.dataset.blobUrl) URL.revokeObjectURL(container.dataset.blobUrl);
             });
            if(screenshotsDiv) screenshotsDiv.innerHTML = '';
            screenshotBlobs = []; manualScreenshotBlobs = []; contactSheetBlob = null; cropData = null; currentVideoDuration = 0;
            clearContactSheetPreview(true);
            Object.keys(gridCache).forEach(key => gridCache[key] = { data: null, blob: null, completed: false });
            $$('.grid-size-tab').forEach(tab => tab.classList.remove('completed'));
            updateImageCount(); resetProcessingUI('all');
            if(resolutionValue) resolutionValue.textContent = '-'; if(lengthValue) lengthValue.textContent = '-'; if(aspectRatioValue) aspectRatioValue.textContent = '-'; if(bitrateValue) bitrateValue.textContent = '-';
            if(intervalInput) intervalInput.value = '10'; if(intervalValue) intervalValue.textContent = '10s';
            if(histThresholdInput) histThresholdInput.value = '0.60'; if(histThresholdValue) histThresholdValue.textContent = '60%';
            if(pixelThresholdInput) pixelThresholdInput.value = '50'; if(pixelThresholdValue) pixelThresholdValue.textContent = '50%';

        };

        const sampleVideoFrames = (options) => {
             const { videoElement = video, sampleTimestamps, outputType, useCrop, processFrameCallback, onCompleteCallback, onProgressCallback, onErrorCallback } = options;
             let localCancelRequested = false;
             let currentSampleIndex = 0;
             const collectedData = new Array(sampleTimestamps.length).fill(null);
             let frameRequestHandle = null;

             if (!videoElement?.src || videoElement.readyState < videoElement.HAVE_METADATA || videoElement.duration <= 0 || !sampleTimestamps?.length) {
                 const error = new Error(!videoElement?.src ? "Video not loaded." : !sampleTimestamps?.length ? "No timestamps provided." : "Video not ready for sampling.");
                 console.error("sampleVideoFrames error:", error.message);
                 if (onErrorCallback) onErrorCallback(error); else console.error(error);
                 if (onCompleteCallback) onCompleteCallback(collectedData);
                 return { cancel: () => { localCancelRequested = true; } };
             }

             const totalSamples = sampleTimestamps.length;
             const checkCancelled = () => localCancelRequested || cancelExtractionRequested;

             const processNext = () => {
                 if (checkCancelled()) { console.log("Sampling cancelled."); if (onCompleteCallback) onCompleteCallback(collectedData); return; }
                 if (currentSampleIndex >= totalSamples) { console.log("Sampling complete."); if (onCompleteCallback) onCompleteCallback(collectedData); return; }

                 const timestamp = sampleTimestamps[currentSampleIndex];
                 const originalIndex = currentSampleIndex;

                 if (onProgressCallback) onProgressCallback(Math.min(Math.round((currentSampleIndex / totalSamples) * 100), 100));

                 captureFrameAtTime(timestamp, (blob) => {
                     if (checkCancelled()) { if (onCompleteCallback) onCompleteCallback(collectedData); return; }

                     if (!blob) {
                         console.warn(`Failed to capture frame at ${timestamp.toFixed(2)}s (Index: ${originalIndex})`);
                     } else {
                         try {
                             processFrameCallback(blob, timestamp, originalIndex);
                             collectedData[currentSampleIndex] = { blob, timestamp };
                         } catch (processError) {
                             console.error(`Error in processFrameCallback at ${timestamp.toFixed(2)}s (Index: ${originalIndex}):`, processError);
                             if (onErrorCallback) onErrorCallback(processError);
                         }
                     }

                     currentSampleIndex++;
                     if (!checkCancelled()) {
                       frameRequestHandle = requestAnimationFrame(processNext);
                     } else {
                        if (onCompleteCallback) onCompleteCallback(collectedData);
                     }
                 }, { videoElement, useCrop, skipProgress: true });
             };

             frameRequestHandle = setTimeout(() => {
                 if (!checkCancelled()) requestAnimationFrame(processNext);
             }, 150);


             return { cancel: () => {
                 localCancelRequested = true;
                 if (frameRequestHandle) {
                    cancelAnimationFrame(frameRequestHandle);
                    clearTimeout(frameRequestHandle);
                    frameRequestHandle = null;
                 }
                 resetProcessingUI(currentMode);
             }};
         };

         const captureFrameAtTime = (time, callback, options = {}) => {
            const { videoElement = video, useCrop = removeBarsEnabled, skipProgress = false } = options;
            if (!videoElement || !videoElement.src || videoElement.readyState < 1 || !canvas) { callback(null); return; }

            let seekTimeout;
            let onSeeked, onError;

            const cleanupListeners = () => {
                clearTimeout(seekTimeout);
                videoElement.removeEventListener('seeked', onSeeked);
                videoElement.removeEventListener('error', onError);
            };

            const drawLogic = () => {
                 try {
                     const ctx = canvas.getContext('2d', { willReadFrequently: true });
                     if (!ctx) throw new Error('Canvas context not available');
                     const effectiveCropData = useCrop && cropData ? cropData : { cropX: 0, cropY: 0, cropWidth: videoElement.videoWidth, cropHeight: videoElement.videoHeight };
                     if (effectiveCropData.cropWidth <= 0 || effectiveCropData.cropHeight <= 0) throw new Error(`Invalid effective crop dimensions: ${effectiveCropData.cropWidth}x${effectiveCropData.cropHeight}`);

                     canvas.width = effectiveCropData.cropWidth; canvas.height = effectiveCropData.cropHeight;
                     ctx.drawImage(videoElement, effectiveCropData.cropX, effectiveCropData.cropY, effectiveCropData.cropWidth, effectiveCropData.cropHeight, 0, 0, canvas.width, canvas.height);

                     drawTimestampOverlay(canvas, time);

                     const { type, quality } = getCurrentFormatSettings();
                     canvas.toBlob((blob) => callback(blob), type, quality);
                 } catch (error) {
                     console.error(`[captureFrameAtTime] Draw error at ${time.toFixed(2)}s:`, error);
                     callback(null);
                 }
             };

            seekTimeout = setTimeout(() => {
                console.warn(`Seek timeout for time ${time.toFixed(2)}s`);
                cleanupListeners();
                callback(null);
            }, 7000);

            onSeeked = () => {
                cleanupListeners();
                setTimeout(drawLogic, 50); // Delay draw after seek completes
            };

            onError = (e) => {
                console.error(`[captureFrameAtTime] Video Error at ${time.toFixed(2)}s:`, e);
                cleanupListeners();
                callback(null);
            };

            videoElement.addEventListener('seeked', onSeeked, { once: true });
            videoElement.addEventListener('error', onError, { once: true });

            try {
                 const duration = videoElement.duration;
                 if (!duration || !isFinite(duration)) {
                     throw new Error("Video duration is invalid or not available.");
                 }
                 const targetTime = Math.max(0, Math.min(time, duration ? duration - 0.01 : 0));

                 if (videoElement.currentTime.toFixed(2) !== targetTime.toFixed(2)) {
                    videoElement.currentTime = targetTime;
                 } else {
                    // Already at the right time, might not trigger 'seeked'
                    cleanupListeners();
                    setTimeout(drawLogic, 60); // Manually trigger draw logic slightly later
                 }

            } catch (error) {
                console.error(`[captureFrameAtTime] Seek Error setting time to ${time.toFixed(2)}:`, error);
                cleanupListeners();
                callback(null);
            }
        };


        const detectCropBoundariesMulti = (callback) => {
            if (!video?.src || video.readyState < 2 || !video.duration || !isFinite(video.duration) || video.videoWidth === 0 || video.videoHeight === 0) {
                console.warn("Video not ready for crop detection.");
                cropData = { cropX: 0, cropY: 0, cropWidth: video.videoWidth || 1, cropHeight: video.videoHeight || 1 };
                if (callback) callback();
                return;
            }
            const sampleTimes = [0.3, 0.5, 0.7].map(p => Math.min(Math.max(p * video.duration, 0.1), video.duration - 0.1));
            let sampleResults = [];
            let currentSample = 0;

            function analyzeFrame(callbackFrame) {
                const tempCanvas = document.createElement('canvas'); tempCanvas.width = video.videoWidth; tempCanvas.height = video.videoHeight;
                const ctx = tempCanvas.getContext("2d"); if(!ctx) { console.error("Failed to get context for crop analysis"); callbackFrame({ topCrop: 0, bottomCrop: video.videoHeight - 1, leftCrop: 0, rightCrop: video.videoWidth - 1 }); return; }
                try {
                    ctx.drawImage(video, 0, 0, video.videoWidth, video.videoHeight);
                    const imageData = ctx.getImageData(0, 0, video.videoWidth, video.videoHeight); const data = imageData.data, width = video.videoWidth, height = video.videoHeight;
                    const pixelThreshold = 15, lineRatioThreshold = 0.98; let topCrop = 0, bottomCrop = height - 1, leftCrop = 0, rightCrop = width - 1;

                    const isBlackRow = (y) => { let blackPxCount = 0; for (let x = 0; x < width; x++) { const i = (y * width + x) * 4; if (data[i] < pixelThreshold && data[i + 1] < pixelThreshold && data[i + 2] < pixelThreshold) blackPxCount++; } return blackPxCount / width >= lineRatioThreshold; };
                    const isBlackCol = (x, yStart, yEnd) => { let blackPxCount = 0; for (let y = yStart; y <= yEnd; y++) { const i = (y * width + x) * 4; if (data[i] < pixelThreshold && data[i + 1] < pixelThreshold && data[i + 2] < pixelThreshold) blackPxCount++; } return blackPxCount / (yEnd - yStart + 1) >= lineRatioThreshold; };

                    for (let y = 0; y < height / 2; y++) { if (!isBlackRow(y)) { topCrop = y; break; } topCrop = y; }
                    for (let y = height - 1; y >= height / 2; y--) { if (!isBlackRow(y)) { bottomCrop = y; break; } bottomCrop = y; }
                    for (let x = 0; x < width / 2; x++) { if (!isBlackCol(x, topCrop, bottomCrop)) { leftCrop = x; break; } leftCrop = x; }
                    for (let x = width - 1; x >= width / 2; x--) { if (!isBlackCol(x, topCrop, bottomCrop)) { rightCrop = x; break; } rightCrop = x; }
                    callbackFrame({ topCrop, bottomCrop, leftCrop, rightCrop });
                } catch (e) {
                    console.error("Error analyzing frame for crop:", e);
                    callbackFrame({ topCrop: 0, bottomCrop: video.videoHeight - 1, leftCrop: 0, rightCrop: video.videoWidth - 1 });
                }
            }

            function median(arr) { const sorted = arr.slice().sort((a, b) => a - b); return sorted[Math.floor(sorted.length / 2)]; }

            function processNextSample() {
                if (currentSample >= sampleTimes.length) {
                    if (sampleResults.length > 0) {
                        const finalTop = median(sampleResults.map(r => r.topCrop)); const finalBottom = median(sampleResults.map(r => r.bottomCrop));
                        const finalLeft = median(sampleResults.map(r => r.leftCrop)); const finalRight = median(sampleResults.map(r => r.rightCrop));
                        cropData = { cropX: finalLeft, cropY: finalTop, cropWidth: Math.max(1, finalRight - finalLeft + 1), cropHeight: Math.max(1, finalBottom - finalTop + 1) };
                    } else {
                         cropData = { cropX: 0, cropY: 0, cropWidth: video.videoWidth || 1, cropHeight: video.videoHeight || 1 };
                    }
                    console.log("Detected black bars crop data:", cropData); if (callback) callback(); return;
                }
                const sampleTime = sampleTimes[currentSample];
                let seekedHandler, errorHandler;

                const cleanupSampleListeners = () => {
                    video.removeEventListener("seeked", seekedHandler);
                    video.removeEventListener("error", errorHandler);
                };

                seekedHandler = () => {
                    cleanupSampleListeners();
                    setTimeout(() => analyzeFrame(boundaries => { sampleResults.push(boundaries); currentSample++; processNextSample(); }), 50);
                };
                errorHandler = (e) => {
                    console.error("Seek error during crop detection sample:", e);
                    cleanupSampleListeners();
                    sampleResults.push({ topCrop: 0, bottomCrop: video.videoHeight - 1, leftCrop: 0, rightCrop: video.videoWidth - 1 }); // Assume no crop on error
                    currentSample++;
                    processNextSample();
                };

                video.addEventListener("seeked", seekedHandler, { once: true });
                video.addEventListener("error", errorHandler, { once: true });
                try { if (Math.abs(video.currentTime - sampleTime) > 0.1) video.currentTime = sampleTime; else { cleanupSampleListeners(); seekedHandler(); } } // Trigger manually if close
                catch (err) { errorHandler(err); }
            }
            processNextSample();
        };

        const updateSliderBackground = (slider) => {
            if (!slider) return;
            const val = parseFloat(slider.value);
            const min = parseFloat(slider.min || 0);
            const max = parseFloat(slider.max || 100);
            const pct = max > min ? ((val - min) * 100) / (max - min) : 0;
            let color = 'var(--accent-interval)';
             // Determine slider color
             if (slider.id === 'jpegQualityGlobal' || slider.id === 'webpQualityGlobal') {
                 color = 'var(--text-secondary)'; // Use a neutral or primary accent for global settings
             }
             else if (slider.closest('#autoSmartMode')) { color = 'var(--accent-secondary)'; }
             else if (slider.closest('#manualMode')) { color = 'var(--accent-primary)'; }
             else if (slider.closest('#contactSheetMode')) { color = 'var(--accent-tertiary)'; }
            slider.style.background = `linear-gradient(to right, ${color} 0%, ${color} ${pct}%, var(--border-color) ${pct}%, var(--border-color) 100%)`;
        };

        const setupSlider = (slider, displaySpan, suffix) => {
            if (!slider || !displaySpan) return;
            const updateUI = () => { 
                // Special handling for histogram threshold (convert to percentage)
                if (slider.id === 'histThresholdInput') {
                    displaySpan.textContent = Math.round(slider.value * 100) + '%';
                }
                // Special handling for pixel threshold (add % sign)
                else if (slider.id === 'pixelThresholdInput') {
                    displaySpan.textContent = slider.value + '%';
                }
                // Default handling for other sliders
                else {
                    displaySpan.textContent = slider.value + suffix;
                }
                updateSliderBackground(slider); 
            };
            slider.addEventListener('input', updateUI); updateUI();
        };

        const initGlobalFormatControls = () => {
             const updateVisibility = () => {
                const selectedFormat = captureFormatSelect.value;
                jpegQualityGlobalRow.style.display = (selectedFormat === 'jpeg') ? 'flex' : 'none';
                webpQualityGlobalRow.style.display = (selectedFormat === 'webp') ? 'flex' : 'none';
                if (selectedFormat === 'jpeg') updateSliderBackground(jpegQualityGlobal);
                if (selectedFormat === 'webp') updateSliderBackground(webpQualityGlobal);
             };

             captureFormatSelect.addEventListener('change', updateVisibility);
             setupSlider(jpegQualityGlobal, jpegQualityGlobalValue, '%');
             setupSlider(webpQualityGlobal, webpQualityGlobalValue, '%');
             updateVisibility(); // Initial call
        };

        const updateDropZoneThumbnail = () => {
            if (!video?.src || video.readyState < 1 || !dropZone || !video.duration || !isFinite(video.duration)) return;
            const previewTime = Math.min(Math.max(video.duration * 0.25, 0.1), video.duration - 0.01);
            captureFrameAtTime(previewTime, (blob) => {
                if (!blob || !dropZone) return;
                const blobUrl = URL.createObjectURL(blob);
                const oldBgUrl = dropZone.dataset.bgUrl;
                if (oldBgUrl) URL.revokeObjectURL(oldBgUrl);
                dropZone.dataset.bgUrl = blobUrl;
                document.documentElement.style.setProperty('--dropzone-bg-image', `url(${blobUrl})`);
                dropZone.classList.add('has-bg-image');
            }, { videoElement: video });
        };

        const initContactSheetPreview = (rows = 4, cols = 5) => {
            if (!contactSheetPreviewElement) return;
            contactSheetPreviewElement.innerHTML = '';
            document.documentElement.style.setProperty('--grid-rows', rows);
            document.documentElement.style.setProperty('--grid-cols', cols);
            contactSheetPreviewData = new Array(rows * cols).fill(null);

            for (let i = 0; i < rows * cols; i++) {
                const cell = document.createElement('div');
                cell.className = 'grid-cell'; cell.dataset.index = i;
                const img = document.createElement('img'); img.alt = `Frame ${i+1}`; cell.appendChild(img);
                                 cell.addEventListener('click', (e) => {
                    if (!e.target.closest('.frame-adjust-btn') && cell.classList.contains('filled')) {
                        const index = parseInt(cell.dataset.index);
                        if (!isNaN(index) && index >= 0 && index < contactSheetPreviewData.length && contactSheetPreviewData[index]) {
                            openLightbox(contactSheetPreviewData[index], contactSheetPreviewData, index);
                        }
                    }
                });

                const downloadBtn = document.createElement('button');
                downloadBtn.className = "action-icon-button action-icon-button--download thumbnail-download-btn";
                downloadBtn.title = "Download this screenshot";
                downloadBtn.style.position = 'absolute';
                downloadBtn.style.top = '6px';
                downloadBtn.style.right = '6px';
                downloadBtn.style.minWidth = '28px';
                downloadBtn.style.minHeight = '28px';
                downloadBtn.style.zIndex = '3';
                downloadBtn.innerHTML = '<i class="ri-download-2-line"></i>';
                downloadBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const idx = parseInt(cell.dataset.index);
                    const data = contactSheetPreviewData[idx];
                    if (data && data.blob) {
                        const extension = data.blob.type === 'image/jpeg' ? 'jpg' : (data.blob.type.split('/')[1] || 'png');
                        const timeSuffix = (data.timestamp !== undefined && data.timestamp >= 0) ? `_${formatTime(data.timestamp).replace(':','-')}` : `_${idx + 1}`;
                        const filename = `grid_frame${timeSuffix}.${extension}`;
                        const tempLink = document.createElement('a');
                        tempLink.href = data.blobUrl;
                        tempLink.download = filename;
                        document.body.appendChild(tempLink);
                        tempLink.click();
                        document.body.removeChild(tempLink);
                    }
                });
                cell.appendChild(downloadBtn);

                const btnContainer = document.createElement('div'); btnContainer.className = 'frame-adjust-buttons';
                const createAdjustBtn = (text, offset, title) => {
                    const btn = document.createElement('div'); btn.className = 'frame-adjust-btn';
                    if (text === '-') btn.innerHTML = `-<i class="ri-scissors-line icon-flipped"></i>`;
                    else if (text === '+') btn.innerHTML = `<i class="ri-scissors-line"></i>+`;
                    else btn.textContent = text;
                    btn.title = title;
                    btn.addEventListener('click', (e) => { e.stopPropagation(); adjustFrameTime(i, offset); }); return btn;
                };
                btnContainer.appendChild(createAdjustBtn('-', -1, 'Cut forward by 1s'));
                btnContainer.appendChild(createAdjustBtn('+', 1, 'Cut backward by 1s'));
                cell.appendChild(btnContainer);

                cell.addEventListener('mouseenter', () => {
                    cell.classList.add('highlight');
                    const timeInputCont = contactSheetControlsElement?.querySelector(`.time-input-container[data-index="${i}"]`);
                    if (timeInputCont) timeInputCont.classList.add('highlight');
                });
                cell.addEventListener('mouseleave', () => {
                    cell.classList.remove('highlight');
                     const timeInputCont = contactSheetControlsElement?.querySelector(`.time-input-container[data-index="${i}"]`);
                    if (timeInputCont) timeInputCont.classList.remove('highlight');
                });

                contactSheetPreviewElement.appendChild(cell);
            }
        };

        const adjustFrameTime = debounce((index, offsetSeconds, arrayType = 'contactSheet') => {
            if (arrayType === 'contactSheet') {
                const timeInput = $(`timeInput_${index}`); if (!timeInput) return;
                const currentValue = parseFloat(timeInput.value); if (isNaN(currentValue)) return;
                const newValue = Math.max(0, Math.min(currentValue + offsetSeconds, currentVideoDuration ? currentVideoDuration - 0.01 : 0));
                updateTimeValue(index, newValue, true);
            } else if (arrayType === 'auto' || arrayType === 'autoSmart') {
                const blobArrayRef = arrayType === 'autoSmart' ? screenshotBlobs : screenshotBlobs;
                if (index >= 0 && index < blobArrayRef.length) {
                    const currentItem = blobArrayRef[index];
                    if (currentItem && currentItem.timestamp !== undefined) {
                        const newTime = Math.max(0, Math.min(currentItem.timestamp + offsetSeconds, currentVideoDuration ? currentVideoDuration - 0.01 : 0));
                        captureFrameAtTime(newTime, (blob) => {
                            if (blob) {
                                const oldBlobUrl = currentItem.blobUrl;
                                if (oldBlobUrl) URL.revokeObjectURL(oldBlobUrl);
                                
                                const newBlobUrl = URL.createObjectURL(blob);
                                currentItem.blob = blob;
                                currentItem.timestamp = newTime;
                                currentItem.blobUrl = newBlobUrl;
                                
                                const container = screenshotsDiv?.querySelector(`.screenshot-container[data-index="${index}"]`);
                                if (container) {
                                    const img = container.querySelector('img');
                                    if (img) img.src = newBlobUrl;
                                    
                                    const overlay = container.querySelector('.screenshot-overlay');
                                    if (overlay) overlay.textContent = formatTime(newTime);
                                    
                                    container.dataset.timestamp = newTime.toString();
                                }
                                
                                if (screenshotLightbox.classList.contains('active') && parseInt(screenshotLightbox.dataset.currentIndex) === index) {
                                    updateLightboxContent(index, blobArrayRef);
                                }
                            }
                        });
                    }
                }
            }
        }, 150);

        const updateTimeValue = (index, seconds, triggerFrameUpdate = false) => {
            if (isNaN(seconds)) seconds = 0;
            const clampedTime = Math.min(Math.max(0, seconds), currentVideoDuration ? currentVideoDuration - 0.01 : 0);
            const numberInput = $(`timeInput_${index}`);
            const formatted = $(`timeFormatted_${index}`);
            if (numberInput) numberInput.value = clampedTime.toFixed(2);
            if (formatted) formatted.value = formatTime(clampedTime);
            if (triggerFrameUpdate) handleFineTuneChange(index, clampedTime);
        };

        // This function now ONLY updates the preview cell and marks the sheet as needing regeneration
        const handleFineTuneChange = debounce((index, newTime) => {
            if (isNaN(newTime) || newTime < 0 || !video?.src || video.readyState < 1) return;
             captureFrameAtTime(newTime, (blob) => {
                 if (blob) {
                     updatePreviewCell(index, blob, newTime); // Update visual cell and data array

                     // Mark sheet as needing regeneration
                     contactSheetBlob = null; // Invalidate the final blob
                     const activeTab = $$('.grid-size-tab.active')[0];
                     if (activeTab) activeTab.classList.remove('completed');
                     const { rows, cols } = activeTab ? activeTab.dataset : { rows: 4, cols: 5 };
                     const cacheKey = `${cols}x${rows}`;
                     if (gridCache[cacheKey]) {
                         gridCache[cacheKey].completed = false;
                         gridCache[cacheKey].blob = null; // Also clear blob from cache
                     }

                     if (processContactSheetButton) {
                         processContactSheetButton.textContent = 'Update Sheet Image';
                         processContactSheetButton.classList.add('needs-update');
                         processContactSheetButton.style.background = 'var(--gradient-tertiary)';
                     }
                     if (previewContactSheetButton) {
                         previewContactSheetButton.disabled = true;
                         previewContactSheetButton.classList.add('needs-update');
                         previewContactSheetButton.title = "Sheet has been modified. Click 'Update Sheet Image'.";
                     }
                     if (downloadContactSheetButton) {
                         downloadContactSheetButton.disabled = true;
                         downloadContactSheetButton.classList.add('needs-update');
                         downloadContactSheetButton.title = "Sheet has been modified. Click 'Update Sheet Image'.";
                     }

                     if (screenshotLightbox.classList.contains('active') && parseInt(screenshotLightbox.dataset.currentIndex) === index) {
                        updateLightboxContent(index, contactSheetPreviewData);
                     }

                     updateImageCount();

                 } else { console.warn(`Fine-tuning failed for cell ${index} at ${newTime.toFixed(2)}s`); }
             });
        }, 300);


        const clearContactSheetPreview = (clearInputs = true) => {
            contactSheetPreviewData.forEach(data => { if (data?.blobUrl) URL.revokeObjectURL(data.blobUrl); });
            const gridCells = $$('.grid-cell', contactSheetPreviewElement);
            contactSheetPreviewData = new Array(gridCells.length).fill(null);
            gridCells.forEach(cell => {
                 cell.classList.remove('filled'); cell.style.cursor = 'default';
                 const img = cell.querySelector('img'); if (img) img.src = '';
                 const overlay = cell.querySelector('.screenshot-overlay'); if (overlay) overlay.remove();
                 delete cell.dataset.blobUrl; delete cell.dataset.timestamp;
            });
            if (clearInputs) {
                 $$('.time-input', contactSheetControlsElement).forEach(input => input.value = '0.00');
                 $$('.time-formatted', contactSheetControlsElement).forEach(input => input.value = '0:00');
            }
            if (downloadContactSheetButton) {
                 downloadContactSheetButton.disabled = true;
                 downloadContactSheetButton.classList.remove('needs-update');
                 downloadContactSheetButton.title = '';
            }
            if (previewContactSheetButton) {
                previewContactSheetButton.disabled = true;
                previewContactSheetButton.classList.remove('needs-update');
                previewContactSheetButton.title = '';
            }
             if (processContactSheetButton) {
                 processContactSheetButton.classList.remove('needs-update');
                 processContactSheetButton.style.background = '';
                 processContactSheetButton.textContent = 'Generate/Update Sheet';
             }
        };

        const updatePreviewCell = (index, blob, timestamp) => {
            const cell = contactSheetPreviewElement?.querySelector(`.grid-cell[data-index="${index}"]`);
            if (!cell || !blob || index < 0 || index >= contactSheetPreviewData.length) return;

            const existingData = contactSheetPreviewData[index];
            if (existingData?.blobUrl) URL.revokeObjectURL(existingData.blobUrl);

            const blobUrl = URL.createObjectURL(blob);
            const img = cell.querySelector('img'); if (img) img.src = blobUrl;
            cell.classList.add('filled'); cell.dataset.blobUrl = blobUrl; cell.dataset.timestamp = String(timestamp); cell.style.cursor = 'pointer';

            let overlay = cell.querySelector('.screenshot-overlay');
            if (!overlay) { overlay = document.createElement('div'); overlay.className = 'screenshot-overlay'; cell.appendChild(overlay); }
            overlay.textContent = formatTime(timestamp);

            contactSheetPreviewData[index] = { blob, timestamp, blobUrl };
         };

         const generateTimeInputs = (rows = 4, cols = 5) => {
              if (!contactSheetControlsElement) return;
              contactSheetControlsElement.innerHTML = '';
              contactSheetControlsElement.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
              const numCells = rows * cols;

              const isLargeGrid = rows > 6 || cols > 6;
              contactSheetControlsElement.style.display = isLargeGrid ? 'none' : 'grid';
              largeGridDisclaimer.style.display = isLargeGrid ? 'block' : 'none';

              if (isLargeGrid) return;

              for (let i = 0; i < numCells; i++) {
                  const container = document.createElement('div'); container.className = 'time-input-container'; container.dataset.index = i;
                  const wrapper = document.createElement('div'); wrapper.className = 'time-input-wrapper';

                  let initialTimestamp = contactSheetPreviewData[i]?.timestamp;
                  if (initialTimestamp === undefined || initialTimestamp === null || initialTimestamp <= 0) {
                      if (currentVideoDuration > 0) {
                         const startPercent = 0.1; const endPercent = 0.9;
                         const step = numCells > 1 ? (endPercent - startPercent) / (numCells - 1) : 0;
                         const percent = startPercent + (i * step);
                         initialTimestamp = Math.max(0.01, Math.min(percent * currentVideoDuration, currentVideoDuration - 0.01));
                      } else {
                         initialTimestamp = 0;
                      }
                  }


                  const timeInput = document.createElement('input'); timeInput.type = 'number'; timeInput.className = 'time-input'; timeInput.id = `timeInput_${i}`;
                  timeInput.value = initialTimestamp.toFixed(2); timeInput.min = '0'; timeInput.max = currentVideoDuration ? currentVideoDuration.toFixed(2) : '999'; timeInput.step = '0.01'; timeInput.dataset.index = i;

                  const timeFormatted = document.createElement('input'); timeFormatted.type = 'text'; timeFormatted.className = 'time-formatted'; timeFormatted.id = `timeFormatted_${i}`;
                  timeFormatted.value = formatTime(initialTimestamp); timeFormatted.dataset.index = i; timeFormatted.placeholder = "0:00"; timeFormatted.setAttribute('draggable', 'false');

                  timeFormatted.addEventListener('change', (e) => { updateTimeValue(parseInt(e.target.dataset.index), parseTimeString(e.target.value), true); });
                  timeFormatted.addEventListener('focus', (e) => e.target.select());

                  let isDragging = false; let startY = 0; let startValue = 0; let sensitivity = 0.05;
                  timeFormatted.addEventListener('mousedown', (e) => {
                      isDragging = true; startY = e.clientY; startValue = parseFloat(timeInput.value);
                      document.body.style.cursor = 'ns-resize';
                      document.addEventListener('mousemove', handleMouseMove);
                      document.addEventListener('mouseup', handleMouseUp);
                      e.preventDefault();
                  });
                  const handleMouseMove = (e) => {
                      if (!isDragging) return;
                      const deltaY = startY - e.clientY;
                      const newValue = Math.max(0, Math.min(startValue + (deltaY * sensitivity), (currentVideoDuration ? currentVideoDuration - 0.01 : 0)));
                      timeInput.value = newValue.toFixed(2);
                      timeFormatted.value = formatTime(newValue);
                      handleFineTuneChange(parseInt(timeInput.dataset.index), newValue);
                  };
                  const handleMouseUp = () => {
                      if (!isDragging) return;
                      isDragging = false;
                      document.body.style.cursor = '';
                      document.removeEventListener('mousemove', handleMouseMove);
                      document.removeEventListener('mouseup', handleMouseUp);
                  };

                  container.addEventListener('mouseenter', () => {
                      container.classList.add('highlight');
                      const cell = contactSheetPreviewElement?.querySelector(`.grid-cell[data-index="${i}"]`);
                      if (cell) cell.classList.add('input-hover-highlight');
                  });
                  container.addEventListener('mouseleave', () => {
                       container.classList.remove('highlight');
                       const cell = contactSheetPreviewElement?.querySelector(`.grid-cell[data-index="${i}"]`);
                       if (cell) cell.classList.remove('input-hover-highlight');
                  });


                  wrapper.appendChild(timeInput); wrapper.appendChild(timeFormatted); container.appendChild(wrapper); contactSheetControlsElement.appendChild(container);
              }

          };

        const generateContactSheet = async () => {
             if (!video?.src || processingActive || video.readyState < video.HAVE_METADATA) {
                 alert("Please load a video file first or wait for it to be ready.");
                 return;
             }
             setProcessingUI('contactSheet');

             const activeGridSizeTab = $$('.grid-size-tab.active')[0];
             const rows = parseInt(activeGridSizeTab?.getAttribute('data-rows') || 4);
             const cols = parseInt(activeGridSizeTab?.getAttribute('data-cols') || 5);
             const numSamples = rows * cols;
             const isLargeGrid = rows > 6 || cols > 6;

             // --- Read timestamps from current input fields ---
             // This ensures manual changes are captured when Update is clicked
             const sampleTimestamps = [];
             console.log("Reading current input values for sheet generation.");
             for (let i = 0; i < numSamples; i++) {
                const input = $(`timeInput_${i}`);
                // If grid is large, inputs don't exist, calculate default
                const existingValue = !isLargeGrid && input ? parseFloat(input.value) : NaN;

                 if (isLargeGrid || !input || isNaN(existingValue)) {
                     // Calculate default if large grid or input is invalid/missing
                     const startPercent = 0.1; const endPercent = 0.9;
                     const step = numSamples > 1 ? (endPercent - startPercent) / (numSamples - 1) : 0;
                     const percent = startPercent + (i * step);
                     const time = Math.max(0.01, Math.min(percent * currentVideoDuration, currentVideoDuration ? currentVideoDuration - 0.01 : 0.01));
                     sampleTimestamps.push(time);
                     // Update visual input only if it exists and we calculated default
                     if (!isLargeGrid && input && isNaN(existingValue)) {
                         const timeFormatted = $(`timeFormatted_${i}`);
                         input.value = time.toFixed(2);
                         if (timeFormatted) timeFormatted.value = formatTime(time);
                         console.warn(`Calculated default for invalid input at index ${i}.`);
                     }
                 } else {
                    // Use the valid value from the input
                    sampleTimestamps.push(Math.max(0.01, Math.min(existingValue, currentVideoDuration ? currentVideoDuration - 0.01 : 0.01)));
                 }
             }
             // --- End Timestamp Reading ---

             if (sampleTimestamps.length === 0 || sampleTimestamps.length !== numSamples) {
                 alert("Error: Could not calculate timestamps for grid.");
                 resetProcessingUI('contactSheet');
                 return;
             }

             // Clear visual cells and reset preview data *before* sampling
             $$('.grid-cell', contactSheetPreviewElement).forEach(cell => {
                 cell.classList.remove('filled');
                 const img = cell.querySelector('img'); if (img) img.src = '';
                 const overlay = cell.querySelector('.screenshot-overlay'); if (overlay) overlay.remove();
                 delete cell.dataset.blobUrl;
             });
             contactSheetPreviewData.forEach(data => { if (data?.blobUrl) URL.revokeObjectURL(data.blobUrl); });
             contactSheetPreviewData = new Array(numSamples).fill(null);
             contactSheetBlob = null; // Always clear the old final blob before regeneration


             try {
                 // Don't remove: Janky fix to address a timing issue where the first frame capture would fail
                 const preCaptureTime = 0.1;
                 console.log("Performing pre-capture seek...");
                 await new Promise((resolve, reject) => {
                     captureFrameAtTime(preCaptureTime, (blob) => {
                         if (blob) {
                             URL.revokeObjectURL(URL.createObjectURL(blob));
                             resolve();
                         } else {
                             console.warn("Pre-capture failed, proceeding anyway...");
                             resolve();
                         }
                     }, { videoElement: video, timeout: 3000 });
                 });

                 if (cancelExtractionRequested) { resetProcessingUI('contactSheet'); return; }

                 currentSamplingProcess = sampleVideoFrames({
                     videoElement: video, sampleTimestamps, outputType: 'blob', useCrop: removeBarsEnabled,
                     processFrameCallback: (blob, timestamp, index) => {
                         // Index corresponds to the position in sampleTimestamps
                         if (index >= 0 && index < contactSheetPreviewData.length) {
                             updatePreviewCell(index, blob, timestamp); // Updates preview AND data array
                         } else { console.warn(`Invalid index ${index} received in processFrameCallback`); }
                     },
                     onProgressCallback: (progress) => { if (progressBarFillContactSheet) progressBarFillContactSheet.style.width = `${progress}%`; },
                     onCompleteCallback: async (collectedData) => { // collectedData is just confirmation
                         if (cancelExtractionRequested) { console.log("Grid generation cancelled."); resetProcessingUI('contactSheet'); return; }
                         if (progressBarFillContactSheet) progressBarFillContactSheet.style.width = `100%`;

                         const validPreviewData = contactSheetPreviewData.filter(data => data?.blob);

                         if (validPreviewData.length === 0) {
                                                console.error("Failed to collect any valid frames for final grid render.");
                    alert("Failed to capture frames for the grid.");
                            resetProcessingUI('contactSheet');
                            return;
                         }

                         // --- Start Final Image Compositing ---
                         const renderCols = parseInt($$('.grid-size-tab.active')[0]?.getAttribute('data-cols') || 5);
                         const renderRows = parseInt($$('.grid-size-tab.active')[0]?.getAttribute('data-rows') || 4);
                         const targetWidth = parseInt(gridOutputWidth?.value || 2000);
                         const cellWidth = Math.floor(targetWidth / renderCols);

                         const imageLoadPromises = validPreviewData.map(({ blob, timestamp, blobUrl }, index) => new Promise((resolve) => {
                             const img = new Image();
                             // Find the original index in the full previewData array based on the blobUrl
                             const originalIndex = contactSheetPreviewData.findIndex(d => d?.blobUrl === blobUrl);
                             img.onload = () => resolve({img, tempUrl: blobUrl, aspectRatio: img.width / img.height, originalIndex });
                             img.onerror = (err) => { console.warn(`Failed to load image for grid cell (ts: ${timestamp})`); resolve(null); };
                             img.src = blobUrl;
                         }));

                         const loadedImageResults = (await Promise.all(imageLoadPromises)).filter(r => r !== null);

                         if (loadedImageResults.length === 0) {
                             console.error("No images could be loaded for the grid.");
                             resetProcessingUI('contactSheet');
                             return;
                         }

                         const rowHeights = new Array(renderRows).fill(0);
                         loadedImageResults.forEach(result => {
                             if (result.originalIndex === -1) return;
                             const row = Math.floor(result.originalIndex / renderCols);
                             if (row < rowHeights.length) {
                                 const heightForCell = cellWidth / result.aspectRatio;
                                 rowHeights[row] = Math.max(rowHeights[row], heightForCell);
                             }
                         });
                         const totalHeight = rowHeights.reduce((sum, height) => sum + Math.ceil(height), 0);
                         const rowOffsets = [];
                         let currentOffset = 0;
                         for (const height of rowHeights) {
                             rowOffsets.push(currentOffset);
                             currentOffset += Math.ceil(height);
                         }

                         const ctx = contactSheetCanvas.getContext('2d'); if (!ctx) throw new Error("Could not get grid canvas context");
                         contactSheetCanvas.width = targetWidth;
                         contactSheetCanvas.height = totalHeight;
                         ctx.fillStyle = 'black'; ctx.fillRect(0, 0, targetWidth, totalHeight);

                         let imagesDrawn = 0;
                         loadedImageResults.forEach(result => {
                            if (result.originalIndex === -1) return;
                             const { img, aspectRatio, originalIndex } = result;
                             const row = Math.floor(originalIndex / renderCols);
                             const col = originalIndex % renderCols;
                             const drawX = col * cellWidth;
                             const drawY = rowOffsets[row];
                             const drawHeight = Math.ceil(rowHeights[row]);
                             const drawWidth = cellWidth;

                             const actualImageHeight = drawWidth / aspectRatio;
                             const actualImageWidth = drawHeight * aspectRatio;
                             let finalDrawWidth, finalDrawHeight, offsetX, offsetY;
                             if (actualImageHeight <= drawHeight) { finalDrawWidth = drawWidth; finalDrawHeight = actualImageHeight; offsetX = drawX; offsetY = drawY + (drawHeight - finalDrawHeight) / 2; }
                             else { finalDrawHeight = drawHeight; finalDrawWidth = actualImageWidth; offsetX = drawX + (drawWidth - finalDrawWidth) / 2; offsetY = drawY; }

                             try { ctx.drawImage(img, offsetX, offsetY, finalDrawWidth, finalDrawHeight); imagesDrawn++; }
                             catch (drawError) { console.error(`Error drawing image for cell ${originalIndex}:`, drawError); }
                             // No need to revoke tempUrl here
                         });
                         // --- End Final Image Compositing ---

                        if (imagesDrawn > 0) {
                            contactSheetCanvas.toBlob((finalBlob) => {
                                if (finalBlob) {
                                    contactSheetBlob = finalBlob;
                                    const activeTab = $$('.grid-size-tab.active')[0];
                                    if (activeTab) { activeTab.classList.add('completed'); const { rows, cols } = activeTab.dataset; const cacheKey = `${cols}x${rows}`; gridCache[cacheKey] = { data: [...contactSheetPreviewData], blob: finalBlob, completed: true }; }
                                     // Re-enable buttons and remove update indicators
                                    if (downloadContactSheetButton) { downloadContactSheetButton.disabled = false; downloadContactSheetButton.classList.remove('needs-update'); downloadContactSheetButton.title = ''; }
                                    if (previewContactSheetButton) { previewContactSheetButton.disabled = false; previewContactSheetButton.classList.remove('needs-update'); previewContactSheetButton.title = '';}
                                } else {
                                    console.error("Failed to generate final grid blob.");
                                    contactSheetBlob = null;
                                }
                                resetProcessingUI('contactSheet');
                            }, 'image/jpeg', 0.9);
                        } else {
                            console.error("No images drawn to grid.");
                            contactSheetBlob = null;
                            resetProcessingUI('contactSheet');
                        }
                     },
                     onErrorCallback: (error) => {
                                        console.error("Error during grid frame sampling:", error);
                alert(`Error generating grid: ${error.message}`);
                        resetProcessingUI('contactSheet');
                     }
                 });
             } catch (error) {
                                 console.error("Failed to start grid generation:", error);
                alert(`Error starting grid generation: ${error.message}`);
                 resetProcessingUI('contactSheet');
             }
         };


        if (pageTitle) pageTitle.addEventListener('click', () => window.location.reload());

        if (videoInput) videoInput.addEventListener('change', (event) => { const file = event.target.files[0]; if (file) handleFileLoad(file); });
        if (dropZone) {
             dropZone.addEventListener('dragover', (e) => { e.preventDefault(); if (!dropZone.classList.contains('file-loaded')) dropZone.classList.add('hover'); });
             dropZone.addEventListener('dragleave', (e) => { e.preventDefault(); dropZone.classList.remove('hover'); });
             dropZone.addEventListener('drop', (e) => { e.preventDefault(); dropZone.classList.remove('hover'); const file = e.dataTransfer.files[0]; if (file?.type.startsWith('video/')) handleFileLoad(file); else alert("Please drop a valid video file."); });
             dropZone.addEventListener('click', (e) => { if (dropZone.classList.contains('file-loaded')) { if (selectFileButton && !selectFileButton.contains(e.target) && videoInput) videoInput.click(); } else { if (initialSelectFileButton && !initialSelectFileButton.contains(e.target) && !tryExampleButton.contains(e.target) && videoInput) videoInput.click(); } });
        }
        if (selectFileButton) selectFileButton.addEventListener('click', (e) => { e.stopPropagation(); if(videoInput) videoInput.click(); });
        if (initialSelectFileButton) initialSelectFileButton.addEventListener('click', (e) => { e.stopPropagation(); if(videoInput) videoInput.click(); });
        if (tryExampleButton) tryExampleButton.addEventListener('click', (e) => { e.stopPropagation(); handleExampleVideoLoad(); });

        // Add hover effects for buttons to trigger dropzone hover
        if (initialSelectFileButton) {
            initialSelectFileButton.addEventListener('mouseenter', () => {
                if (!dropZone.classList.contains('file-loaded')) dropZone.classList.add('hover');
            });
            initialSelectFileButton.addEventListener('mouseleave', () => {
                dropZone.classList.remove('hover');
            });
        }
        if (tryExampleButton) {
            tryExampleButton.addEventListener('mouseenter', () => {
                if (!dropZone.classList.contains('file-loaded')) dropZone.classList.add('hover');
            });
            tryExampleButton.addEventListener('mouseleave', () => {
                dropZone.classList.remove('hover');
            });
        }

        if (modeTabs.length > 0 && modeContentDiv) {
            modeTabs.forEach(tab => {
                tab.addEventListener('click', () => {
                   if (processingActive) return;
                   const newMode = tab.getAttribute('data-mode');
                   const previousMode = currentMode;
                   if (!newMode || !modeContentDiv) return; currentMode = newMode;
                   modeTabs.forEach(t => t.classList.remove('active')); tab.classList.add('active');
                   $$('.mode-content > div', modeContentDiv).forEach(contentDiv => { contentDiv.classList.toggle('active', contentDiv.id === `${newMode}Mode`); });
                   outputColumn.classList.toggle('show-grid', newMode === 'contactSheet');

                   Object.values(buttonGroups).forEach(group => { if (group) group.style.display = 'none'; });
                   if (buttonGroups[newMode]) buttonGroups[newMode].style.display = 'flex';

                   Object.values(progressBarElements).forEach(bar => { if (bar) bar.style.display = 'none'; });

                   processingActive = false;
                   cancelExtractionRequested = false;
                   if (currentSamplingProcess?.cancel) currentSamplingProcess.cancel();

                   // Reset Manual Mode
                   if (previousMode === 'manual' && newMode !== 'manual') {
                       manualScreenshotBlobs = [];
                   }
                   if (newMode === 'manual' && previousMode !== 'manual') {
                       $$('.screenshot-container', screenshotsDiv).forEach(container => { 
                           if (container.dataset.blobUrl) URL.revokeObjectURL(container.dataset.blobUrl); 
                       });
                       if(screenshotsDiv) screenshotsDiv.innerHTML = '';
                       if(downloadManualButton) downloadManualButton.disabled = true;
                       if(clearScreenshotsButton) clearScreenshotsButton.disabled = manualScreenshotBlobs.length === 0;
                   }

                   if (newMode === 'contactSheet') {
                       const activeGridSizeTab = $$('.grid-size-tab.active')[0];
                       const rows = parseInt(activeGridSizeTab?.getAttribute('data-rows') || 4);
                       const cols = parseInt(activeGridSizeTab?.getAttribute('data-cols') || 5);
                       const cacheKey = `${cols}x${rows}`;
                       const cachedGrid = gridCache[cacheKey];

                       initContactSheetPreview(rows, cols);

                        // Show/hide time inputs based on current grid size
                        if (updateContactSheetControlsVisibility(rows, cols)) {
                            if (cachedGrid?.data) {
                                contactSheetPreviewData = cachedGrid.data;
                                contactSheetBlob = cachedGrid.blob;
                                generateTimeInputs(rows, cols); // Generate inputs *after* potentially restoring data

                                contactSheetPreviewData.forEach((data, index) => {
                                    if (data?.blob) {
                                        const blobUrl = URL.createObjectURL(data.blob);
                                        contactSheetPreviewData[index].blobUrl = blobUrl; // Update blobUrl in restored data
                                        updatePreviewCell(index, data.blob, data.timestamp);
                                        $(`timeInput_${index}`).value = data.timestamp.toFixed(2);
                                        $(`timeFormatted_${index}`).value = formatTime(data.timestamp);
                                    }
                                });
                            } else {
                                contactSheetPreviewData = new Array(rows * cols).fill(null);
                                contactSheetBlob = null;
                                generateTimeInputs(rows, cols);
                            }
                        } else {
                            // If inputs are hidden, ensure data array is correct size but has no blobs
                            contactSheetPreviewData = new Array(rows * cols).fill(null);
                            contactSheetBlob = null;
                         }

                         activeGridSizeTab?.classList.toggle('completed', cachedGrid?.completed ?? false);
                         if (processContactSheetButton) processContactSheetButton.textContent = cachedGrid?.completed ? 'Generate/Update Sheet' : 'Generate/Update Sheet';
                         if (downloadContactSheetButton) downloadContactSheetButton.disabled = !contactSheetBlob;
                         if (previewContactSheetButton) previewContactSheetButton.disabled = !contactSheetBlob;

                   } else {
                       // Clear general screenshot area if switching away from grid
                        $$('.screenshot-container', screenshotsDiv).forEach(container => { if (container.dataset.blobUrl) URL.revokeObjectURL(container.dataset.blobUrl); });
                        if(screenshotsDiv) screenshotsDiv.innerHTML = '';
                        screenshotBlobs = []; // Clear auto/smart blobs
                        // Keep manual blobs unless explicitly cleared
                   }

                   resetProcessingUI(newMode); // Reset buttons based on video presence
                   updateImageCount(); // Ensure count is updated after mode switch
                });
            });
        }

        const updateContactSheetControlsVisibility = (rows, cols) => {
             const isLargeGrid = rows > 6 || cols > 6;
             contactSheetControlsElement.style.display = isLargeGrid ? 'none' : 'grid';
             largeGridDisclaimer.style.display = isLargeGrid ? 'block' : 'none';
             return !isLargeGrid; // Return true if inputs should be generated
        };


        if (gridSizeTabs.length > 0) {
            gridSizeTabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    if (processingActive) return;
                    const currentActiveTab = $$('.grid-size-tab.active')[0];

                    let rows = parseInt(tab.getAttribute('data-rows') || 4);
                    let cols = parseInt(tab.getAttribute('data-cols') || 5);
                    const isCustom = tab.textContent.trim() === 'Custom';
                     if (customGridControls) customGridControls.style.display = isCustom ? 'block' : 'none';

                    if (isCustom && customGridRows && customGridCols) {
                        rows = Math.max(parseInt(customGridRows.value) || 2, 1);
                        cols = Math.max(parseInt(customGridCols.value) || 3, 1);
                         customGridRows.value = rows; customGridCols.value = cols;
                        tab.setAttribute('data-rows', rows); tab.setAttribute('data-cols', cols);
                    }
                    if (isNaN(rows) || isNaN(cols)) return;

                    const newCacheKey = `${cols}x${rows}`;

                    if (currentActiveTab && currentActiveTab !== tab) {
                        const prevRows = parseInt(currentActiveTab.getAttribute('data-rows'));
                        const prevCols = parseInt(currentActiveTab.getAttribute('data-cols'));
                        const prevCacheKey = `${prevCols}x${prevRows}`;
                         if (contactSheetPreviewData.some(item => item !== null) || contactSheetBlob) {
                              gridCache[prevCacheKey] = { data: [...contactSheetPreviewData], blob: contactSheetBlob, completed: currentActiveTab.classList.contains('completed') };
                               contactSheetPreviewData.forEach(item => { if (item?.blobUrl) URL.revokeObjectURL(item.blobUrl); });
                          }
                    }

                    gridSizeTabs.forEach(t => t.classList.remove('active')); tab.classList.add('active');

                    const cachedGrid = gridCache[newCacheKey];
                    clearContactSheetPreview(true); // Clear first
                    initContactSheetPreview(rows, cols); // Initialize preview grid

                     // Show/hide controls *before* trying to generate inputs
                     const showInputs = updateContactSheetControlsVisibility(rows, cols);

                    if (cachedGrid?.data) {
                        contactSheetPreviewData = cachedGrid.data;
                        contactSheetBlob = cachedGrid.blob;
                         if (showInputs) {
                            generateTimeInputs(rows, cols); // Generate inputs only if not too large
                         }

                        contactSheetPreviewData.forEach((data, index) => {
                            if (data?.blob) {
                                const blobUrl = URL.createObjectURL(data.blob);
                                contactSheetPreviewData[index].blobUrl = blobUrl; // Update blobUrl in restored data
                                updatePreviewCell(index, data.blob, data.timestamp);
                                // Update inputs only if they exist
                                const timeInput = $(`timeInput_${index}`);
                                const timeFormatted = $(`timeFormatted_${index}`);
                                if (timeInput) timeInput.value = data.timestamp.toFixed(2);
                                if (timeFormatted) timeFormatted.value = formatTime(data.timestamp);
                            }
                        });
                        tab.classList.toggle('completed', cachedGrid.completed);
                        if (processContactSheetButton) processContactSheetButton.textContent = cachedGrid.completed ? 'Generate/Update Sheet' : 'Generate/Update Sheet';

                    } else {
                         contactSheetPreviewData = new Array(rows * cols).fill(null);
                         contactSheetBlob = null;
                         if (showInputs) {
                            generateTimeInputs(rows, cols); // Generate default inputs only if not too large
                         }
                         tab.classList.remove('completed');
                         if (processContactSheetButton) processContactSheetButton.textContent = 'Generate/Update Sheet';
                    }

                    if (downloadContactSheetButton) downloadContactSheetButton.disabled = !contactSheetBlob;
                    if (previewContactSheetButton) previewContactSheetButton.disabled = !contactSheetBlob;
                     // Reset update button style on grid change
                     if (processContactSheetButton) {
                        processContactSheetButton.classList.remove('needs-update');
                        processContactSheetButton.style.background = '';
                     }
                     
                     // Recalculate output height when grid size changes
                     calculateGridOutputHeight();
                });
            });
        }

        if (customGridCols && customGridRows) {
            // Handle input events - only allow numbers
            customGridCols.addEventListener('input', (e) => {
                e.target.value = e.target.value.replace(/[^0-9]/g, '');
            });
            
            customGridRows.addEventListener('input', (e) => {
                e.target.value = e.target.value.replace(/[^0-9]/g, '');
            });
            
            // Handle change events - update grid
            const updateCustomGrid = debounce(() => {
                if (processingActive) return;
                const customTab = Array.from(gridSizeTabs).find(tab => tab.textContent.trim() === 'Custom');
                if (!customTab || !customTab.classList.contains('active')) return;

                const rows = Math.max(parseInt(customGridRows.value) || 2, 1);
                const cols = Math.max(parseInt(customGridCols.value) || 3, 1);
                customGridRows.value = rows; 
                customGridCols.value = cols;

                customTab.click();
            }, 500);
            
            customGridCols.addEventListener('change', updateCustomGrid);
            customGridRows.addEventListener('change', updateCustomGrid);
            
            // Handle focus events - select all text
            customGridCols.addEventListener('focus', (e) => e.target.select());
            customGridRows.addEventListener('focus', (e) => e.target.select());
            
            // Handle button clicks for columns
            const customGridColsPrevBtn = $('customGridColsPrevBtn');
            const customGridColsNextBtn = $('customGridColsNextBtn');
            
            if (customGridColsPrevBtn) {
                customGridColsPrevBtn.addEventListener('click', () => {
                    const currentValue = parseInt(customGridCols.value) || 3;
                    const newValue = Math.max(1, currentValue - 1);
                    customGridCols.value = newValue;
                    updateCustomGrid();
                });
            }
            
            if (customGridColsNextBtn) {
                customGridColsNextBtn.addEventListener('click', () => {
                    const currentValue = parseInt(customGridCols.value) || 3;
                    const newValue = currentValue + 1;
                    customGridCols.value = newValue;
                    updateCustomGrid();
                });
            }
            
            // Handle button clicks for rows
            const customGridRowsPrevBtn = $('customGridRowsPrevBtn');
            const customGridRowsNextBtn = $('customGridRowsNextBtn');
            
            if (customGridRowsPrevBtn) {
                customGridRowsPrevBtn.addEventListener('click', () => {
                    const currentValue = parseInt(customGridRows.value) || 2;
                    const newValue = Math.max(1, currentValue - 1);
                    customGridRows.value = newValue;
                    updateCustomGrid();
                });
            }
            
            if (customGridRowsNextBtn) {
                customGridRowsNextBtn.addEventListener('click', () => {
                    const currentValue = parseInt(customGridRows.value) || 2;
                    const newValue = currentValue + 1;
                    customGridRows.value = newValue;
                    updateCustomGrid();
                });
            }
        }

        // Add event listeners for output width controls
        if (gridOutputWidth && gridOutputWidthSlider) {
            gridOutputWidth.addEventListener('input', (e) => {
                // Only allow numbers
                e.target.value = e.target.value.replace(/[^0-9]/g, '');
            });
            
            gridOutputWidth.addEventListener('change', () => {
                const value = parseInt(gridOutputWidth.value) || 3000;
                gridOutputWidthSlider.value = value;
                updateSliderBackground(gridOutputWidthSlider);
                calculateGridOutputHeight();
            });
            
            gridOutputWidthSlider.addEventListener('input', () => {
                const value = parseInt(gridOutputWidthSlider.value) || 3000;
                gridOutputWidth.value = value;
                updateSliderBackground(gridOutputWidthSlider);
                calculateGridOutputHeight();
            });
            
            gridOutputWidth.addEventListener('focus', (e) => e.target.select());
        }

        // Setup global format controls
        initGlobalFormatControls();
        // Setup mode-specific sliders
        setupSlider(intervalInput, intervalValue, 's');
        setupSlider(histThresholdInput, histThresholdValue, '');
        setupSlider(pixelThresholdInput, pixelThresholdValue, '');
        
        // Initialize grid output width slider background
        if (gridOutputWidthSlider) {
            updateSliderBackground(gridOutputWidthSlider);
        }
        
        // Reset grid output width to default values on page load
        if (gridOutputWidth && gridOutputWidthSlider) {
            gridOutputWidth.value = 3000;
            gridOutputWidthSlider.value = 3000;
            updateSliderBackground(gridOutputWidthSlider);
            calculateGridOutputHeight();
        }

        if (removeBarsToggle) removeBarsToggle.addEventListener('change', (e) => {
            removeBarsEnabled = e.target.checked;
            if (removeBarsEnabled && video?.src && video.readyState >= 2) {
                 detectCropBoundariesMulti(() => { updateDropZoneThumbnail(); updateFileInfoDisplay(); });
            } else if (!removeBarsEnabled) {
                cropData = null; updateDropZoneThumbnail(); updateFileInfoDisplay();
            }
        });

        if (addTimestampToggle) addTimestampToggle.addEventListener('change', (e) => {
            addTimestampEnabled = e.target.checked;
        });

        const drawTimestampOverlay = (canvas, timestamp) => {
            // Only draw if Pro Mode is enabled
            const proModeToggle = document.getElementById('proModeToggle');
            if (!proModeToggle || !proModeToggle.checked) return;
            
            const ctx = canvas.getContext('2d');
            
            // Draw timecode overlay if enabled
            const timecodeFormatSelect = document.getElementById('timecodeFormatSelect');
            if (timecodeFormatSelect && timecodeFormatSelect.value !== 'off' && timestamp && timestamp >= 0) {
                const timestampText = formatTimecode(timestamp, timecodeFormatSelect.value, canvas.framerate || 30);
                
                // Calculate font size based on timecode size selection
                let fontSize = 16; // Default M size
                switch (window.timecodeSize || 'M') {
                    case 'S': fontSize = 16; break;
                    case 'L': fontSize = 64; break;
                    case 'XL': fontSize = 96; break;
                    default: fontSize = 32; break; // M
                }
                
                ctx.font = `bold ${fontSize}px "Courier New", "Lucida Console", monospace`;
                ctx.textAlign = 'right';
                ctx.textBaseline = 'bottom';
                const textMetrics = ctx.measureText(timestampText);
                const textWidth = textMetrics.width;
                const textHeight = fontSize + 4; // Adjust height based on font size
                const padding = Math.max(10, fontSize / 4); // Scale padding with font size
                const x = canvas.width - padding;
                const y = canvas.height - padding;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(x - textWidth - padding, y - textHeight - padding, textWidth + padding * 2, textHeight + padding * 2);
                ctx.fillStyle = 'white';
                ctx.fillText(timestampText, x, y);
            }
            
            // Draw custom text overlay if provided
            const customTextInput = document.getElementById('customTextInput');
            if (customTextInput && customTextInput.value.trim()) {
                const customText = customTextInput.value.trim();
                
                // Use same font size as timecode for consistency
                let fontSize = 16; // Default M size
                switch (window.timecodeSize || 'M') {
                    case 'S': fontSize = 16; break;
                    case 'L': fontSize = 64; break;
                    case 'XL': fontSize = 96; break;
                    default: fontSize = 32; break; // M
                }
                
                ctx.font = `bold ${fontSize}px "Courier New", "Lucida Console", monospace`;
                const textMetrics = ctx.measureText(customText);
                const textWidth = textMetrics.width;
                const textHeight = fontSize + 4;
                const padding = Math.max(10, fontSize / 4);
                
                // Position based on selected corner
                let x, y, textAlign, textBaseline;
                const position = window.customTextPosition || 'bottom-left';
                
                switch (position) {
                    case 'bottom-left':
                        x = padding;
                        y = canvas.height - padding;
                        textAlign = 'left';
                        textBaseline = 'bottom';
                        break;
                    case 'top-right':
                        x = canvas.width - padding;
                        y = padding;
                        textAlign = 'right';
                        textBaseline = 'top';
                        break;
                    case 'top-left':
                        x = padding;
                        y = padding;
                        textAlign = 'left';
                        textBaseline = 'top';
                        break;
                    default:
                        x = padding;
                        y = canvas.height - padding;
                        textAlign = 'left';
                        textBaseline = 'bottom';
                }
                
                ctx.textAlign = textAlign;
                ctx.textBaseline = textBaseline;
                
                // Calculate background rectangle position
                let bgX, bgY;
                if (textAlign === 'left') {
                    bgX = x - padding;
                } else {
                    bgX = x - textWidth - padding;
                }
                
                if (textBaseline === 'bottom') {
                    bgY = y - textHeight - padding;
                } else {
                    bgY = y - padding;
                }
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(bgX, bgY, textWidth + padding * 2, textHeight + padding * 2);
                ctx.fillStyle = 'white';
                ctx.fillText(customText, x, y);
            }
        };

        // Helper to format timecode
        function formatTimecode(seconds, format, framerate) {
            if (isNaN(seconds)) seconds = 0;
            framerate = framerate || 30;
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            // Use absolute frame number for ff (timeline style)
            const absFrame = Math.floor(seconds * framerate);
            // Use sub-second frame for :ff (as in SMPTE)
            const subFrame = Math.floor((seconds % 1) * framerate);
            switch (format) {
                case 'hh:mm:ss:ff': return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}:${subFrame.toString().padStart(2, '0')}`;
                case 'hh:mm:ss': return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
                case 'mm:ss:ff': return `${(h*60+m).toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}:${subFrame.toString().padStart(2, '0')}`;
                case 'mm:ss': return `${(h*60+m).toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
                case 'ss:ff': return `${(h*3600+m*60+s).toString().padStart(2, '0')}:${subFrame.toString().padStart(2, '0')}`;
                case 'ss': return `${(h*3600+m*60+s).toString().padStart(2, '0')}`;
                case 'ff': return `${absFrame}`;
                default: return `${(h*60+m).toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
            }
        }

        // Mobile-friendly tooltip handler
        const createMobileTooltip = (element, message) => {
            if (element) {
                element.addEventListener('click', (e) => {
                    if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
                        e.preventDefault();
                        alert(message);
                    }
                });
            }
        };

        // Setup mobile tooltips
        createMobileTooltip($('removeBarsInfoIcon'), 'Automatically detect and crop black bars from letterboxed videos');
        createMobileTooltip($('timestampInfoIcon'), 'Burn-in SMPTE timecode overlay to bottom right corner of generated frames');
        createMobileTooltip($('frameWarningIcon'), 'You need to enable "Pro Mode" -option and use "Set Framerate" -option to set the framerate of your input video for accurate frame display.');
        createMobileTooltip($('framerateInfoIcon'), 'Set your input video\'s framerate. This ensures accurate timecode data for the generated frames and manual fine-tuning.');
        createMobileTooltip($('customTextInfoIcon'), 'Add custom text overlay to generated frames and rotate its position with the button on the right.');
        createMobileTooltip($('overlaySizeInfoIcon'), 'Set the font size for timecode and custom text overlays.');

        if (smartAlgoTabs.length > 0) {
            const updateThresholdSliders = (algo) => {
                if(histThresholdSettings) histThresholdSettings.style.display = (algo === 'histogram') ? 'flex' : 'none';
                if(pixelThresholdSettings) pixelThresholdSettings.style.display = (algo === 'pixeldiff') ? 'flex' : 'none';
                // Also toggle the disclaimer note visibility
                pixelDiffDisclaimer.style.display = (algo === 'pixeldiff') ? 'block' : 'none';
                $$('#autoSmartMode .disclaimer-note:not(#pixelDiffDisclaimer)')[0].style.display = (algo === 'histogram') ? 'block' : 'none';


                requestAnimationFrame(() => {
                    if(histThresholdInput && algo === 'histogram') updateSliderBackground(histThresholdInput);
                    if(pixelThresholdInput && algo === 'pixeldiff') updateSliderBackground(pixelThresholdInput);
                });
            };
            let initialAlgo = 'histogram'; $$('.smart-tab').forEach(tab => { if (tab.classList.contains('active')) initialAlgo = tab.getAttribute('data-algo') || 'histogram'; });
             smartAlgoTabs.forEach(tab => {
                 tab.addEventListener('click', () => {
                     if (processingActive) return; const algo = tab.getAttribute('data-algo'); if(!algo) return; smartAlgorithm = algo;
                     $$('.smart-tab').forEach(t => t.classList.remove('active')); tab.classList.add('active');
                     updateThresholdSliders(algo);
                 });
             });
             smartAlgorithm = initialAlgo;
             updateThresholdSliders(initialAlgo);
         }


        const startAutoExtraction = () => {
             if (!video?.src || processingActive || !intervalInput || video.readyState < video.HAVE_METADATA) {
                 alert("Please load a video file first or wait for it to be ready.");
                 return;
             }
             setProcessingUI('auto');
             screenshotBlobs = [];
             if(screenshotsDiv) screenshotsDiv.innerHTML = '';
             updateImageCount();
             contactSheetBlob = null;

             const interval = parseFloat(intervalInput.value); if (isNaN(interval) || interval <= 0) { resetProcessingUI('auto'); return; }

             const startExtraction = () => {
                 let currentTime = 0.1; const totalDuration = currentVideoDuration; let frameTimeoutId = null; let isCancelled = false;
                 currentSamplingProcess = { cancel: () => { isCancelled = true; cancelExtractionRequested = true; if (frameTimeoutId) clearTimeout(frameTimeoutId); resetProcessingUI('auto'); } }; // Reset UI on cancel

                 function processNextFrame() {
                     if (isCancelled || cancelExtractionRequested || currentTime > totalDuration + 0.1) { if(!isCancelled) resetProcessingUI('auto'); return; } // Check cancel before processing
                     const timestamp = currentTime;
                     if (progressBarFillAuto) progressBarFillAuto.style.width = `${Math.min((currentTime / totalDuration) * 100, 100)}%`;

                     captureFrameAtTime(timestamp, (blob) => {
                         if (isCancelled || cancelExtractionRequested) { return; }
                         if (blob) {
                            createScreenshotContainer(blob, timestamp, screenshotBlobs);
                            updateImageCount();
                         }
                         if (currentTime <= totalDuration + 0.1) {
                              currentTime += interval;
                              frameTimeoutId = setTimeout(processNextFrame, 0);
                         } else {
                              resetProcessingUI('auto');
                         }
                     });
                 }
                 frameTimeoutId = setTimeout(processNextFrame, 0);
             };
             startExtraction();
         };

        const startSmartExtraction = () => {
            if (!video?.src || processingActive || video.readyState < video.HAVE_METADATA) {
                alert("Please load a video file first or wait for it to be ready.");
                return;
            }
            setProcessingUI('autoSmart');
            screenshotBlobs = [];
            if(screenshotsDiv) screenshotsDiv.innerHTML = '';
            updateImageCount();
            contactSheetBlob = null;

            const smartInterval = 0.5;
            const sampleFactor = 8;
            const histThreshold = histThresholdInput ? parseFloat(histThresholdInput.value) : 0.35;
            const pixelThreshold = pixelThresholdInput ? parseFloat(pixelThresholdInput.value) : 35;

            const startExtraction = () => {
                 let currentTime = 0.1; const totalDuration = currentVideoDuration; let previousImageData = null; let previousHist = null; let previousPixelData = null;
                 let frameTimeoutId = null; let isCancelled = false;
                 currentSamplingProcess = { cancel: () => { isCancelled = true; cancelExtractionRequested = true; if (frameTimeoutId) clearTimeout(frameTimeoutId); resetProcessingUI('autoSmart'); } }; // Reset UI on cancel

                function processNextSmartFrame() {
                    if (isCancelled || cancelExtractionRequested || currentTime > totalDuration + 0.1) { if(!isCancelled) resetProcessingUI('autoSmart'); return; }
                    const timestamp = currentTime;
                     if (progressBarFillSmart) progressBarFillSmart.style.width = `${Math.min((currentTime / totalDuration) * 100, 100)}%`;

                    captureFrameAtTime(timestamp, (blob) => {
                        if (isCancelled || cancelExtractionRequested) { return; }

                        if (!blob) {
                            if (currentTime <= totalDuration + 0.1) {
                                currentTime += smartInterval; frameTimeoutId = setTimeout(processNextSmartFrame, 0);
                            } else { resetProcessingUI('autoSmart'); }
                            return;
                        }

                        const tempCanvas = document.createElement('canvas'); const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
                        const img = new Image();
                         const blobUrl = URL.createObjectURL(blob);
                         img.src = blobUrl;

                        img.onload = () => {
                             URL.revokeObjectURL(blobUrl);
                             if (isCancelled || cancelExtractionRequested) { return; }

                             try {
                                 tempCanvas.width = img.width; tempCanvas.height = img.height; if (!tempCtx) throw new Error("Could not get temp canvas context"); tempCtx.drawImage(img, 0, 0);
                                 const currentImageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);

                                 let captureThisFrame = false;
                                 if (!previousImageData) {
                                     captureThisFrame = true;
                                     if (smartAlgorithm === "histogram") previousHist = computeHistogram(currentImageData, sampleFactor);
                                     if (smartAlgorithm === 'pixeldiff') previousPixelData = currentImageData.data.slice();
                                 } else {
                                     if (smartAlgorithm === "histogram") {
                                         const currentHist = computeHistogram(currentImageData, sampleFactor);
                                         if (!previousHist || histogramDifference(currentHist, previousHist) >= histThreshold) { captureThisFrame = true; previousHist = currentHist; }
                                     } else if (smartAlgorithm === "pixeldiff") {
                                         const diff = computePixelDiff(currentImageData.data, previousPixelData, sampleFactor);
                                         if (diff >= pixelThreshold) { captureThisFrame = true; previousPixelData = currentImageData.data.slice(); }
                                     }
                                 }

                                 if (captureThisFrame) {
                                     createScreenshotContainer(blob, timestamp, screenshotBlobs);
                                     updateImageCount();
                                     previousImageData = currentImageData;
                                 }

                                 if (currentTime <= totalDuration + 0.1) { currentTime += smartInterval; frameTimeoutId = setTimeout(processNextSmartFrame, 0); }
                                 else resetProcessingUI('autoSmart');

                             } catch (error) {
                                 console.error("[Process Smart] Error:", error);
                                 if (currentTime <= totalDuration + 0.1) { currentTime += smartInterval; frameTimeoutId = setTimeout(processNextSmartFrame, 0); }
                                 else resetProcessingUI('autoSmart');
                             }
                        };

                        img.onerror = () => {
                             URL.revokeObjectURL(blobUrl);
                            console.error("[Process Smart] Failed to load blob into image");
                            if (currentTime <= totalDuration + 0.1) { currentTime += smartInterval; frameTimeoutId = setTimeout(processNextSmartFrame, 0); }
                            else resetProcessingUI('autoSmart');
                        };
                    });
                }
                 frameTimeoutId = setTimeout(processNextSmartFrame, 0);
            };
            startExtraction();
        };

        if (extractManualButton) extractManualButton.addEventListener('click', () => {
             if (!manualVideo?.src || manualVideo.readyState < 1 || processingActive || !canvas) return;
             try {
                 const { type, quality } = getCurrentFormatSettings();
                 const ctx = canvas.getContext('2d'); if(!ctx) throw new Error("Canvas context not available");
                 const effectiveCropData = removeBarsEnabled && cropData ? cropData : { cropX: 0, cropY: 0, cropWidth: manualVideo.videoWidth, cropHeight: manualVideo.videoHeight };
                 if (effectiveCropData.cropWidth <= 0 || effectiveCropData.cropHeight <= 0) throw new Error("Invalid video or crop dimensions for Save Frame.");

                 canvas.width = effectiveCropData.cropWidth; canvas.height = effectiveCropData.cropHeight;
                 ctx.drawImage(manualVideo, effectiveCropData.cropX, effectiveCropData.cropY, effectiveCropData.cropWidth, effectiveCropData.cropHeight, 0, 0, canvas.width, canvas.height);

                 const timestamp = manualVideo.currentTime;
                 drawTimestampOverlay(canvas, timestamp);
                 canvas.toBlob((blob) => {
                     if (blob) {
                         const url = URL.createObjectURL(blob);
                         const tempLink = document.createElement('a'); tempLink.href = url;
                         const extension = getFileExtensionFromType(type);
                         tempLink.download = `quick_frame_${formatTime(manualVideo.currentTime).replace(':','-')}.${extension}`;
                         document.body.appendChild(tempLink); tempLink.click(); document.body.removeChild(tempLink); URL.revokeObjectURL(url);
                     }
                 }, type, quality);
             } catch(error) { console.error("[Manual Save Frame] Error:", error); alert("An error occurred during Save Frame: " + error.message); }
         });

        if (addManualButton) addManualButton.addEventListener('click', () => {
             // Scissors icon animation only for Manual Cut Frame button
             addManualButton.classList.add('cutting'); setTimeout(() => { addManualButton.classList.remove('cutting'); }, 300);

             if (!manualVideo?.src || manualVideo.readyState < 1 || processingActive || !canvas) return;

             try {
                 const { type, quality } = getCurrentFormatSettings();
                 const ctx = canvas.getContext('2d'); if(!ctx) throw new Error("Canvas context not available");
                 const effectiveCropData = removeBarsEnabled && cropData ? cropData : { cropX: 0, cropY: 0, cropWidth: manualVideo.videoWidth, cropHeight: manualVideo.videoHeight };
                 if (effectiveCropData.cropWidth <= 0 || effectiveCropData.cropHeight <= 0) throw new Error("Invalid video or crop dimensions for Manual Add.");

                 canvas.width = effectiveCropData.cropWidth; canvas.height = effectiveCropData.cropHeight;
                 ctx.drawImage(manualVideo, effectiveCropData.cropX, effectiveCropData.cropY, effectiveCropData.cropWidth, effectiveCropData.cropHeight, 0, 0, canvas.width, canvas.height);

                 const timestamp = manualVideo.currentTime;
                 drawTimestampOverlay(canvas, timestamp);
                 canvas.toBlob((blob) => {
                     if (blob) {
                        createScreenshotContainer(blob, timestamp, manualScreenshotBlobs);
                        updateImageCount();
                     }
                 }, type, quality);
             } catch(error) { console.error("[Manual Add] Error:", error); alert("An error occurred while adding the frame: " + error.message); }
         });

        if(downloadAllButton) downloadAllButton.addEventListener('click', () => { if (!processingActive) downloadBlobsAsZip(screenshotBlobs.filter(item => item?.blob), "auto_screenshots"); });
        if(downloadAllSmartButton) downloadAllSmartButton.addEventListener('click', () => { if (!processingActive) downloadBlobsAsZip(screenshotBlobs.filter(item => item?.blob), "smart_screenshots"); });
        if(downloadManualButton) downloadManualButton.addEventListener('click', () => { if (!processingActive) downloadBlobsAsZip(manualScreenshotBlobs.filter(item => item?.blob), "manual_screenshots"); });

        if(previewContactSheetButton) previewContactSheetButton.addEventListener('click', () => {
             if (!processingActive && contactSheetBlob) {
                 const url = URL.createObjectURL(contactSheetBlob); window.open(url, '_blank');
             } else { alert("Please generate or update the grid first."); }
         });
        if(downloadContactSheetButton) downloadContactSheetButton.addEventListener('click', () => {
             if (!processingActive && contactSheetBlob) {
                 const url = URL.createObjectURL(contactSheetBlob);
                 const tempLink = document.createElement('a'); tempLink.href = url;
                 tempLink.download = `grid_${uploadedFile?.name.split('.')[0] || 'video'}.jpg`;
                 document.body.appendChild(tempLink); tempLink.click(); document.body.removeChild(tempLink); URL.revokeObjectURL(url);
             } else { alert("Please generate or update the grid first."); }
         });

        if (clearScreenshotsButton) clearScreenshotsButton.addEventListener('click', () => {
             if (processingActive) return;
             const hasAnyOutput = (screenshotBlobs.length + manualScreenshotBlobs.length > 0) || contactSheetPreviewData.some(d => d !== null) || contactSheetBlob;
             if (hasAnyOutput && confirm("Are you sure you want to clear all generated output (screenshots and grid preview)?")) {
                 screenshotBlobs.concat(manualScreenshotBlobs).forEach(item => { if(item?.blobUrl) URL.revokeObjectURL(item.blobUrl); });
                 if(screenshotsDiv) screenshotsDiv.innerHTML = '';
                 screenshotBlobs = []; manualScreenshotBlobs = [];

                 clearContactSheetPreview(true);
                 contactSheetBlob = null;

                 Object.keys(gridCache).forEach(key => { gridCache[key] = { data: null, blob: null, completed: false }; });
                 $$('.grid-size-tab').forEach(tab => tab.classList.remove('completed'));

                 if(downloadContactSheetButton) downloadContactSheetButton.disabled = true;
                 if(previewContactSheetButton) previewContactSheetButton.disabled = true;
                 if(processContactSheetButton) processContactSheetButton.textContent = 'Generate/Update Grid';
                 updateImageCount();
             }
        });

        // Initial setup calls
        currentMode = $$('.mode-tab.active')[0]?.getAttribute('data-mode') || 'manual';
        smartAlgorithm = $$('.smart-tab.active')[0]?.getAttribute('data-algo') || 'histogram';
        $$('input[type="range"]').forEach(updateSliderBackground);

         if (buttonGroups[currentMode]) {
            Object.values(buttonGroups).forEach(group => { if (group) group.style.display = 'none'; });
            buttonGroups[currentMode].style.display = 'flex';
         }

        resetProcessingUI('all');
        updateDropZoneUI(false, null);
        updateImageCount();
        initGlobalFormatControls();

        const initialActiveGridTab = $$('.grid-size-tab.active')[0];
        if (initialActiveGridTab) {
            const rows = parseInt(initialActiveGridTab.getAttribute('data-rows') || 4);
            const cols = parseInt(initialActiveGridTab.getAttribute('data-cols') || 5);
            initContactSheetPreview(rows, cols);
             if (updateContactSheetControlsVisibility(rows, cols)) {
                 generateTimeInputs(rows, cols);
             }

            if (initialActiveGridTab.textContent.trim() === 'Custom' && customGridControls) {
                customGridControls.style.display = 'block';
                if (customGridRows && customGridCols) {
                    customGridRows.value = initialActiveGridTab.getAttribute('data-rows') || '2';
                    customGridCols.value = initialActiveGridTab.getAttribute('data-cols') || '3';
                }
            }
        } else {
             initContactSheetPreview(4, 5);
             generateTimeInputs(4, 5);
        }

        // Manual fine-tune controls functionality
        const setupManualFineTuneControls = () => {
            const manualTimeInput = $('manualTimeInput');
            const manualFrameInput = $('manualFrameInput');
            const manualTimePrevBtn = $('manualTimePrevBtn');
            const manualTimeNextBtn = $('manualTimeNextBtn');
            const manualFramePrevBtn = $('manualFramePrevBtn');
            const manualFrameNextBtn = $('manualFrameNextBtn');
            const manualTimeDragBtn = $('manualTimeDragBtn');
            const manualFrameDragBtn = $('manualFrameDragBtn');
            
            if (!manualTimeInput || !manualFrameInput || !manualVideo) return;
            
            // Calculate frame rate (assuming 30fps if not available)
            const getFrameRate = () => {
                const framerateInput = document.getElementById('framerateInput');
                if (!framerateInput) return 30;
                
                // Handle both comma and dot as decimal separators
                const value = framerateInput.value.replace(',', '.');
                const framerate = parseFloat(value);
                return isNaN(framerate) ? 30 : framerate;
            };
            
            const frameRate = getFrameRate();
            
            // Update time and frame displays from video currentTime
            const updateManualDisplays = () => {
                if (!manualVideo.src || manualVideo.readyState < 1) return;
                
                const currentTime = manualVideo.currentTime;
                const frameRate = getFrameRate();
                const currentFrame = Math.round(currentTime * frameRate);
                
                manualTimeInput.value = formatTime(currentTime);
                manualFrameInput.value = currentFrame;
            };
            
            // Update video position from time input
            const updateVideoFromTime = (newTime) => {
                if (!manualVideo.src || manualVideo.readyState < 1) return;
                const clampedTime = Math.max(0, Math.min(newTime, manualVideo.duration || 0));
                manualVideo.currentTime = clampedTime;
            };
            
            // Update video position from frame input
            const updateVideoFromFrame = (newFrame) => {
                if (!manualVideo.src || manualVideo.readyState < 1) return;
                const frameRate = getFrameRate();
                const newTime = newFrame / frameRate;
                const clampedTime = Math.max(0, Math.min(newTime, manualVideo.duration || 0));
                manualVideo.currentTime = clampedTime;
            };
            
            manualTimeInput.addEventListener('change', (e) => {
                const newTime = parseTimeString(e.target.value);
                if (newTime >= 0) {
                    updateVideoFromTime(newTime);
                }
            });
            
            manualFrameInput.addEventListener('input', (e) => {
                // Only allow numbers
                e.target.value = e.target.value.replace(/[^0-9]/g, '');
            });
            
            manualFrameInput.addEventListener('change', (e) => {
                const newFrame = parseInt(e.target.value);
                if (!isNaN(newFrame) && newFrame >= 0) {
                    updateVideoFromFrame(newFrame);
                }
            });
            
            let isDraggingTime = false;
            let startXTime = 0;
            let startValueTime = 0;
            let sensitivityTime = 0.05;
            
            if (manualTimeDragBtn) {
                manualTimeDragBtn.addEventListener('mousedown', (e) => {
                    isDraggingTime = true;
                    startXTime = e.clientX;
                    startValueTime = parseTimeString(manualTimeInput.value);
                    document.body.style.cursor = 'ew-resize';
                    document.addEventListener('mousemove', handleTimeMouseMove);
                    document.addEventListener('mouseup', handleTimeMouseUp);
                    e.preventDefault();
                });
            }
            
            const handleTimeMouseMove = (e) => {
                if (!isDraggingTime) return;
                const deltaX = e.clientX - startXTime;
                const newValue = Math.max(0, Math.min(startValueTime + (deltaX * sensitivityTime), manualVideo.duration || 0));
                manualTimeInput.value = formatTime(newValue);
                updateVideoFromTime(newValue);
            };
            
            const handleTimeMouseUp = () => {
                if (!isDraggingTime) return;
                isDraggingTime = false;
                document.body.style.cursor = '';
                document.removeEventListener('mousemove', handleTimeMouseMove);
                document.removeEventListener('mouseup', handleTimeMouseUp);
            };
            
            let isDraggingFrame = false;
            let startXFrame = 0;
            let startValueFrame = 0;
            let sensitivityFrame = 1;
            
            if (manualFrameDragBtn) {
                manualFrameDragBtn.addEventListener('mousedown', (e) => {
                    isDraggingFrame = true;
                    startXFrame = e.clientX;
                    startValueFrame = parseInt(manualFrameInput.value);
                    document.body.style.cursor = 'ew-resize';
                    document.addEventListener('mousemove', handleFrameMouseMove);
                    document.addEventListener('mouseup', handleFrameMouseUp);
                    e.preventDefault();
                });
            }
            
            const handleFrameMouseMove = (e) => {
                if (!isDraggingFrame) return;
                const deltaX = e.clientX - startXFrame;
                const newValue = Math.max(0, startValueFrame + Math.round(deltaX * sensitivityFrame));
                manualFrameInput.value = newValue;
                updateVideoFromFrame(newValue);
            };
            
            const handleFrameMouseUp = () => {
                if (!isDraggingFrame) return;
                isDraggingFrame = false;
                document.body.style.cursor = '';
                document.removeEventListener('mousemove', handleFrameMouseMove);
                document.removeEventListener('mouseup', handleFrameMouseUp);
            };
            
            if (manualTimePrevBtn) {
                manualTimePrevBtn.addEventListener('click', () => {
                    const currentTime = parseTimeString(manualTimeInput.value);
                    const newTime = Math.max(0, currentTime - 1);
                    updateVideoFromTime(newTime);
                });
            }
            
            if (manualTimeNextBtn) {
                manualTimeNextBtn.addEventListener('click', () => {
                    const currentTime = parseTimeString(manualTimeInput.value);
                    const newTime = Math.min(manualVideo.duration || 0, currentTime + 1);
                    updateVideoFromTime(newTime);
                });
            }
            
            if (manualFramePrevBtn) {
                manualFramePrevBtn.addEventListener('click', () => {
                    const currentFrame = parseInt(manualFrameInput.value);
                    const newFrame = Math.max(0, currentFrame - 1);
                    updateVideoFromFrame(newFrame);
                });
            }
            
            if (manualFrameNextBtn) {
                manualFrameNextBtn.addEventListener('click', () => {
                    const currentFrame = parseInt(manualFrameInput.value);
                    const newFrame = currentFrame + 1;
                    updateVideoFromFrame(newFrame);
                });
            }
            
            manualTimeInput.addEventListener('focus', (e) => e.target.select());
            manualFrameInput.addEventListener('focus', (e) => e.target.select());
            
            // Listen to video time updates
            manualVideo.addEventListener('timeupdate', updateManualDisplays);
            
            // Initial update
            updateManualDisplays();
        };

        const manualDragControl = $('manualDragControl');
        
        let isDraggingManual = false;
        let startXManual = 0;
        let startTimeManual = 0;
        let sensitivityManual = 0.05;

        if (manualDragControl) {
            // Mouse events for desktop
            manualDragControl.addEventListener('mousedown', (e) => {
                isDraggingManual = true;
                startXManual = e.clientX;
                startTimeManual = manualVideo.currentTime;
                document.body.style.cursor = 'ew-resize';
                document.addEventListener('mousemove', handleManualDragMove);
                document.addEventListener('mouseup', handleManualDragUp);
                e.preventDefault();
            });

            // Touch events for mobile
            manualDragControl.addEventListener('touchstart', (e) => {
                isDraggingManual = true;
                startXManual = e.touches[0].clientX;
                startTimeManual = manualVideo.currentTime;
                document.addEventListener('touchmove', handleManualDragMoveTouch, { passive: false });
                document.addEventListener('touchend', handleManualDragUpTouch);
                e.preventDefault();
            });
        }

        const handleManualDragMove = (e) => {
            if (!isDraggingManual) return;
            const deltaX = e.clientX - startXManual;
            const newTime = Math.max(0, Math.min(startTimeManual + (deltaX * sensitivityManual), manualVideo.duration || 0));
            manualVideo.currentTime = newTime;
        };

        const handleManualDragUp = () => {
            if (!isDraggingManual) return;
            isDraggingManual = false;
            document.body.style.cursor = '';
            document.removeEventListener('mousemove', handleManualDragMove);
            document.removeEventListener('mouseup', handleManualDragUp);
        };

        const handleManualDragMoveTouch = (e) => {
            if (!isDraggingManual) return;
            const deltaX = e.touches[0].clientX - startXManual;
            const newTime = Math.max(0, Math.min(startTimeManual + (deltaX * sensitivityManual), manualVideo.duration || 0));
            manualVideo.currentTime = newTime;
            e.preventDefault();
        };

        const handleManualDragUpTouch = () => {
            if (!isDraggingManual) return;
            isDraggingManual = false;
            document.removeEventListener('touchmove', handleManualDragMoveTouch);
            document.removeEventListener('touchend', handleManualDragUpTouch);
        };

      } catch (error) { console.error("Error during script execution:", error); const errorDisplay = document.createElement('div'); errorDisplay.textContent = `Initialization Error: ${error.message}. Please refresh or check console (F12).`; errorDisplay.style.cssText = 'color: var(--danger-color); padding: 1rem; background-color: var(--bg-secondary); border: 1px solid var(--danger-color); margin: 1rem; border-radius: var(--border-radius-md);'; document.body.prepend(errorDisplay); }
    });

    if (filenamePrefix) filenamePrefix.addEventListener('input', updateNamingSettingsExample);
    if (includeTimestamp) includeTimestamp.addEventListener('change', updateNamingSettingsExample);
    if (numberingStyleSelect) numberingStyleSelect.addEventListener('change', updateNamingSettingsExample);
    function updateNamingSettingsExample() {
      if (!namingSettingsExampleText) return;
      const prefix = filenamePrefix?.value ?? namingSettings.prefix;
      const numberingStyle = numberingStyleSelect?.value || namingSettings.numberingStyle;
      const includeTs = includeTimestamp?.checked ?? namingSettings.includeTimestamp;
      const includeFr = includeFrame?.checked ?? namingSettings.includeFrame;
      const framerate = parseInt(framerateInput?.value || namingSettings.framerate);
      const exampleIndex = 0;
      const exampleTimestamp = 10;
      let filename = prefix;
      filename += (exampleIndex + 1).toString().padStart(numberingStyle.length, '0');
      if (includeTs) filename += '_0-10';
      if (includeFr) {
        const frameNum = Math.round(exampleTimestamp * framerate);
        filename += `_${frameNum}`;
      }
      filename += '.png';
      namingSettingsExampleText.textContent = filename;
    }

    if (includeFrame) {
      includeFrame.addEventListener('change', () => {
        updateNamingSettingsExample();
      });
    }

    if (framerateInput) {
      framerateInput.addEventListener('input', () => {
        let val = framerateInput.value.replace(',', '.');
        val = val.replace(/[^0-9.]/g, '');
        const parts = val.split('.');
        if (parts.length > 2) {
          val = parts[0] + '.' + parts.slice(1).join('');
        }
        
        let num = parseFloat(val);
        if (isNaN(num)) num = 30;
        
        framerateInput.value = val;
        updateNamingSettingsExample();
        const manualFrameInput = document.getElementById('manualFrameInput');
        const manualVideo = document.getElementById('manualVideo');
        const fr = num;
        if (manualFrameInput && manualVideo && !isNaN(manualVideo.currentTime)) {
          manualFrameInput.value = Math.round(manualVideo.currentTime * fr);
        }
      });

      const frameratePrevBtn = document.getElementById('frameratePrevBtn');
      const framerateNextBtn = document.getElementById('framerateNextBtn');
      if (frameratePrevBtn) {
        frameratePrevBtn.addEventListener('click', (e) => {
          e.preventDefault();
          const currentValue = framerateInput.value.replace(',', '.');
          let num = parseFloat(currentValue) || 30;
          num = num - 1;
          framerateInput.value = Math.round(num);
          framerateInput.dispatchEvent(new Event('input'));
        });
      }
      if (framerateNextBtn) {
        framerateNextBtn.addEventListener('click', (e) => {
          e.preventDefault();
          const currentValue = framerateInput.value.replace(',', '.');
          let num = parseFloat(currentValue) || 30;
          num = num + 1;
          framerateInput.value = Math.round(num);
          framerateInput.dispatchEvent(new Event('input'));
        });
      }
    }

    document.addEventListener('DOMContentLoaded', () => {
      const manualFrameInput = document.getElementById('manualFrameInput');
      const manualTimeInput = document.getElementById('manualTimeInput');
      const manualVideo = document.getElementById('manualVideo');
      const framerateInput = document.getElementById('framerateInput');
      function getCurrentFramerate() {
        return parseInt(framerateInput?.value) || 30;
      }
      if (manualVideo && manualFrameInput && framerateInput) {
        manualVideo.addEventListener('timeupdate', () => {
          manualFrameInput.value = Math.round(manualVideo.currentTime * getCurrentFramerate());
        });
        manualFrameInput.addEventListener('change', (e) => {
          const frame = parseInt(e.target.value);
          if (!isNaN(frame)) {
            manualVideo.currentTime = frame / getCurrentFramerate();
          }
        });
      }
      
      window.timecodeSize = 'M';
      const timecodeSizeTabs = document.querySelectorAll('.timecode-size-tab');
      timecodeSizeTabs.forEach(tab => {
        tab.addEventListener('click', () => {
          const size = tab.getAttribute('data-size');
          if (!size) return;
          
          timecodeSizeTabs.forEach(t => t.classList.remove('active'));
          tab.classList.add('active');
          window.timecodeSize = size;
        });
      });
      
      // Custom text corner position toggle
      window.customTextPosition = 'bottom-left'; // bottom-left, top-right, top-left
      const cornerPositionBtn = document.getElementById('cornerPositionBtn');
      if (cornerPositionBtn) {
        cornerPositionBtn.addEventListener('click', () => {
          const positions = ['bottom-left', 'top-left', 'top-right'];
          const currentIndex = positions.indexOf(window.customTextPosition);
          const nextIndex = (currentIndex + 1) % positions.length;
          window.customTextPosition = positions[nextIndex];
          
          // Update button appearance based on position
          const svg = cornerPositionBtn.querySelector('svg');
          if (window.customTextPosition === 'bottom-left') {
            cornerPositionBtn.title = 'Text position: Bottom Left';
            svg.style.transform = 'rotate(0deg)';
          } else if (window.customTextPosition === 'top-right') {
            cornerPositionBtn.title = 'Text position: Top Right';
            svg.style.transform = 'rotate(180deg)';
          } else if (window.customTextPosition === 'top-left') {
            cornerPositionBtn.title = 'Text position: Top Left';
            svg.style.transform = 'rotate(90deg)';
          }
        });
        
        // Set initial title and rotation
        cornerPositionBtn.title = 'Text position: Bottom Left';
        const svg = cornerPositionBtn.querySelector('svg');
        svg.style.transform = 'rotate(0deg)';
      }
    });

    // Pro Mode
    const proModeToggle = document.getElementById('proModeToggle');
    const addTimestampGroup = document.getElementById('addTimestampGroup');
    const timecodeSizeGroup = document.getElementById('timecodeSizeGroup');
    const customTextGroup = document.getElementById('customTextGroup');
    const customTextInput = document.getElementById('customTextInput');
    const customTextInfoIcon = document.getElementById('customTextInfoIcon');
    const framerateRow = document.getElementById('framerateRow');
    const timecodeFormatSelect = document.getElementById('timecodeFormatSelect');
    let timecodeFormat = 'off';

    function initializeProModeDefaults() {
      if (framerateInput) framerateInput.value = '30';
      if (timecodeFormatSelect) timecodeFormatSelect.value = 'off';
      if (proModeToggle) proModeToggle.checked = false;
      if (addTimestampGroup) addTimestampGroup.style.display = 'none';
      if (customTextGroup) customTextGroup.style.display = 'none';
      if (framerateRow) framerateRow.style.display = 'none';
      if (customTextInput) customTextInput.value = '';
      
      // Don't hide timecodeSizeGroup here, let the timecode format logic handle it
    }
    
    if (proModeToggle && addTimestampGroup) {
      proModeToggle.checked = false;
      addTimestampGroup.style.display = 'none';
      if (framerateRow) framerateRow.style.display = 'none';
      
      if (framerateInput) {
        framerateInput.value = '30';
      }
      
      if (timecodeFormatSelect) {
        timecodeFormatSelect.value = 'off';
      }
      
      proModeToggle.addEventListener('change', () => {
        const isEnabled = proModeToggle.checked;
        addTimestampGroup.style.display = isEnabled ? '' : 'none';
        customTextGroup.style.display = isEnabled ? 'flex' : 'none';
        timecodeSizeGroup.style.display = isEnabled ? 'flex' : 'none';
        framerateRow.style.display = isEnabled ? 'flex' : 'none';
        
        if (!isEnabled) {
          initializeProModeDefaults();
        }
      });
    }
    
    initializeProModeDefaults();

    if (timecodeFormatSelect) {
      timecodeFormatSelect.addEventListener('change', (e) => {
        timecodeFormat = e.target.value;
        addTimestampEnabled = timecodeFormat !== 'off';
      });
      timecodeFormat = timecodeFormatSelect.value;
      addTimestampEnabled = timecodeFormat !== 'off';
    }


  </script>

</body>
</html>