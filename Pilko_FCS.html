<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pilko Frame Capture Studio</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cairo+Play:wght@400&family=Inter:wght@400;500;600&family=Source+Code+Pro:wght@400&display=swap" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/remixicon@3.5.0/fonts/remixicon.css" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    :root {
      --bg-primary: #0a0f1f;
      --bg-secondary: #161d31;
      --bg-tertiary: #242c44;
      --text-primary: #e0e6f7;
      --text-secondary: #aeb9dd;
      --text-tertiary: #8a94b6;
      --border-color: #3a4466;
      --border-dashed: #525c8f;

      --accent-primary: #00c6ff;
      --accent-primary-dark: #00a8ff;
      --accent-secondary: #5eead4;
      --accent-secondary-dark: #2dd4bf;
      --accent-tertiary: #ff8cdc;
      --accent-tertiary-dark: #ff6ac1;
      --accent-interval: #9a6eff;
      --accent-interval-dark: #855bff;
      --danger-color: #f43f5e;
      --danger-color-dark: #e11d48;

      --gradient-primary: linear-gradient(90deg, var(--accent-primary), var(--accent-primary-dark));
      --gradient-secondary: linear-gradient(90deg, var(--accent-secondary), var(--accent-secondary-dark));
      --gradient-tertiary: linear-gradient(90deg, var(--accent-tertiary), var(--accent-tertiary-dark));
      --gradient-interval: linear-gradient(90deg, var(--accent-interval), var(--accent-interval-dark));
      --gradient-danger: linear-gradient(90deg, var(--danger-color), var(--danger-color-dark));
      --gradient-disabled: linear-gradient(90deg, var(--bg-tertiary), var(--bg-tertiary));

      --white: #ffffff;
      --black: #000000;

      --border-radius-sm: 3px;
      --border-radius-md: 6px;
      --border-radius-lg: 10px;
      --border-radius-full: 9999px;
      --content-padding: 1.25rem;
      --settings-column-width: 460px;
      --scrollbar-width: 8px;
      --separator-width: 2px;
      --data-font: 'Source Code Pro', monospace;

      --input-bg: var(--bg-tertiary);
      --text-color: var(--text-primary);
    }

    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    body { background-color: var(--bg-primary); color: var(--text-primary); font-family: 'Inter', "Helvetica Neue", Arial, sans-serif; line-height: 1.5; font-size: 15px; min-height: 100vh; display: flex; overflow: hidden; }
    html, body { margin: 0; padding: 0; width: 100%; height: 100%; }

    ::-webkit-scrollbar { width: var(--scrollbar-width); height: var(--scrollbar-width); }
    ::-webkit-scrollbar-track { background: var(--bg-secondary); border-radius: var(--border-radius-full); }
    ::-webkit-scrollbar-thumb { background-color: var(--bg-tertiary); border-radius: var(--border-radius-full); border: 1px solid var(--bg-secondary); }
    ::-webkit-scrollbar-thumb:hover { background-color: var(--border-color); }
    * { scrollbar-width: thin; scrollbar-color: var(--bg-tertiary) var(--bg-secondary); }

    .app-container { flex: 1; display: flex; position: relative; width: 100%; height: 100%; overflow: hidden; }
    .vertical-separator { position: absolute; top: 0; bottom: 0; left: var(--settings-column-width); width: var(--separator-width); background-image: linear-gradient(to bottom, var(--border-dashed) 60%, transparent 40%); background-size: 100% 8px; background-repeat: repeat-y; z-index: 10; pointer-events: none; transition: background-image 0.3s ease; }
    .vertical-separator.loading { background-image: linear-gradient(to bottom, var(--accent-interval) 60%, transparent 40%); background-size: 100% 12px; animation: loadingAnimation 10s linear infinite; }
    .vertical-separator.loading-smart { background-image: linear-gradient(to bottom, var(--accent-secondary) 60%, transparent 40%); background-size: 100% 12px; animation: loadingAnimation 10s linear infinite; }
    .vertical-separator.loading-contact-sheet { background-image: linear-gradient(to bottom, var(--accent-tertiary) 60%, transparent 40%); background-size: 100% 12px; animation: loadingAnimation 8s linear infinite; }
    @keyframes loadingAnimation { 0% { background-position: 0 0; } 100% { background-position: 0 100vh; } }

    .settings-column { flex: 0 0 var(--settings-column-width); position: relative; height: 100%; overflow-y: auto; overflow-x: hidden; direction: rtl; background-color: var(--bg-secondary); padding: 0; }
    .settings-content-wrapper { direction: ltr; width: 100%; padding: var(--content-padding); display: flex; flex-direction: column; height: 100%; }

    .output-column { flex: 1; display: flex; flex-direction: column; background-color: var(--bg-primary); overflow-y: auto; padding: var(--content-padding); }
    #screenshots { display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 0.8rem; align-content: start; }

    .output-column.show-contact-sheet #screenshots { display: none; }
    .output-column:not(.show-contact-sheet) #contactSheetPreview { display: none; }


    h1 { font-family: 'Cairo Play', sans-serif; text-align: center; padding-bottom: 1rem; font-weight: 400; font-size: 2em; color: var(--white); position: relative; cursor: pointer; user-select: none; transition: color 0.3s ease; }
    h1::after {
      content: '';
      position: absolute;
      left: 0;
      bottom: 0;
      width: 100%;
      height: 2px;
      background-image: linear-gradient(to right, var(--accent-primary) 50%, transparent 50%);
      background-size: 20px 2px;
      background-repeat: repeat-x;
      opacity: 0;
      transition: opacity 0.4s ease;
      z-index: 1;
    }
    h1:hover {
      color: var(--accent-primary);
      text-shadow: 0 0 10px rgba(0, 198, 255, 0.3);
      margin: 0 0.5rem;
    }
    h1:hover::after {
      opacity: 1;
      animation: moveLines 1.5s linear infinite;
      margin-bottom: -0.1rem;
    }
    h1:active { transform: scale(0.98); }
    @keyframes moveLines {
      0% { background-position: 0px; }
      100% { background-position: 40px; }
    }

    #dropZone {
      border: 2px dashed var(--border-dashed);
      border-radius: var(--border-radius-lg);
      background: linear-gradient(145deg, var(--bg-tertiary), var(--bg-secondary));
      cursor: pointer;
      transition: background 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease, padding 0.3s ease;
      margin-bottom: 1.5rem;
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.15);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 1.5rem 1rem;
      flex-shrink: 0;
      position: relative;
      overflow: hidden;
    }

    #dropZone::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-image: var(--dropzone-bg-image, none);
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      opacity: 0;
      transition: opacity 0.5s ease;
      z-index: 0;
      min-height: 100%;
    }

    #dropZone.has-bg-image::before {
      opacity: 0.2;
    }

    #dropZone > * {
      position: relative;
      z-index: 1;
    }

    #dropZone:hover { border-color: var(--accent-primary); box-shadow: 0 5px 12px rgba(0, 198, 255, 0.15); }
    #dropZone #uploadIcon { margin-bottom: 0.75rem; color: var(--text-tertiary); transition: color 0.3s ease, transform 0.3s ease; display: block; }
    #dropZone:hover #uploadIcon { color: var(--accent-primary); transform: scale(1.1); }
    #dropZone #uploadIcon svg { width: 44px; height: 44px; fill: currentColor; }
    #dropZone #dropZoneText { margin-bottom: 1rem; font-size: 0.95rem; color: var(--text-tertiary); display: block; }
    #dropZone #loadedFileInfo { display: none; }
    #dropZone.file-loaded { padding: 1rem 1.25rem 0.75rem; align-items: stretch; text-align: left; justify-content: flex-start; cursor: default; }
    #dropZone.file-loaded #uploadIcon, #dropZone.file-loaded #dropZoneText { display: none; }
    #dropZone.file-loaded #loadedFileInfo { display: block; width: 100%; }
    #loadedFileName { font-size: 0.95rem; font-weight: 500; color: var(--text-primary); margin-bottom: 0; display: flex; align-items: center; word-break: break-all; flex: 1; margin-right: 1rem; }
    #loadedFileName::before { content: '✓'; color: var(--accent-secondary); font-size: 1.2em; margin-right: 0.5rem; font-weight: bold; }

    .file-name-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.75rem; width: 100%; }

    #loadedFileStats { font-size: 0.85rem; color: var(--text-tertiary); }
    #loadedFileStats .info-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.5rem; white-space: nowrap; }
    #loadedFileStats .info-row:last-child { margin-bottom: 0; }
    #loadedFileStats .info-label { font-weight: 500; color: var(--text-secondary); margin-right: 1rem; }
    #loadedFileStats .info-value {
        font-family: var(--data-font);
        text-align: right;
        color: var(--text-primary);
        font-weight: 500;
        font-size: 0.9rem;
    }
    #loadedFileStats .leader { display: none; }

    #initialSelectFileButton { padding: 0.6rem 1.5rem; font-size: 0.9rem; background-color: rgba(255, 255, 255, 0.05); border: 1px solid var(--border-color); border-radius: var(--border-radius-md); color: var(--text-primary); cursor: pointer; transition: background-color 0.2s, border-color 0.2s, color 0.2s, box-shadow 0.2s; font-weight: 500; width: fit-content; align-self: center; }
    #dropZone:not(.file-loaded):hover #initialSelectFileButton { background-color: rgba(255, 255, 255, 0.1); border-color: var(--text-tertiary); box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1); }

    #selectFileButton {
      font-size: 0.8rem;
      padding: 0.4rem 1rem;
      background-color: transparent;
      border: 1px solid var(--text-primary);
      color: var(--text-primary);
      border-radius: var(--border-radius-md);
      cursor: pointer;
      transition: background-color 0.2s;
    }
    #selectFileButton:hover { background-color: var(--text-primary); color: var(--bg-primary); }

    #dropZone.file-loaded #initialSelectFileButton { display: none; }

    #videoInput { display: none; }

    #imageCountDisplay { text-align: center; font-size: 0.9rem; color: var(--text-tertiary); margin-top: 1.5rem; margin-bottom: 0.75rem; padding: 0.4rem 0; background-color: var(--bg-tertiary); border-radius: var(--border-radius-md); border: 1px solid var(--border-color); flex-shrink: 0; }
    #imageCountValue {
        font-weight: 600;
        font-family: var(--data-font);
        margin-left: 0.5ch;
    }
    #imageCountValue.interval-mode { color: var(--accent-interval); }
    #imageCountValue.smart-mode { color: var(--accent-secondary); }
    #imageCountValue.manual-mode { color: var(--accent-primary); }
    #imageCountValue.contact-sheet-mode { color: var(--accent-tertiary); }

    .setting-row { display: flex; align-items: center; flex-wrap: wrap; margin-bottom: 1.25rem; background-color: var(--bg-tertiary); padding: 0.8rem 1rem; border-radius: var(--border-radius-md); border: 1px solid var(--border-color); flex-shrink: 0; }
    .setting-label { flex: 1; font-size: 0.9rem; color: var(--text-primary); font-weight: 500; margin-right: 0.8rem; margin: 0; cursor: default; display: inline-flex; align-items: center; }
    .info-icon-inline { font-size: 1em; margin-left: 0.5em; color: var(--text-tertiary); cursor: help; transition: color 0.2s ease; }
    .info-icon-inline:hover { color: var(--accent-primary); }

    .toggle-row { display: flex; align-items: center; justify-content: space-between; }
    .toggle-label { display: flex; align-items: center; gap: 0.5rem; }
    .toggle-switch { position: relative; display: inline-block; width: 48px; height: 24px; flex-shrink: 0; margin-left: auto; /* Push toggle to the right */ }
    .toggle-input { opacity: 0; width: 0; height: 0; }
    .toggle-label-switch { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--bg-primary); transition: .3s; border-radius: 24px; border: 1px solid var(--border-color); }
    .toggle-label-switch:before { position: absolute; content: ""; height: 18px; width: 18px; left: 2px; bottom: 2px; background-color: var(--text-tertiary); transition: .3s; border-radius: 50%; box-shadow: 0 1px 2px rgba(0,0,0,0.15); }
    .toggle-input:checked + .toggle-label-switch { background: var(--border-color); border-color: transparent; }
    .toggle-input:checked + .toggle-label-switch:before { transform: translateX(24px); background-color: var(--white); }

    #format-options-row { display: flex; }
    .format-controls { display: flex; }
    #outputFormatSelect {
        background-color: var(--input-bg);
        color: var(--text-primary);
        border: 1px solid var(--border-color);
        border-radius: var(--border-radius-sm);
        padding: 0.35rem 0.6rem;
        font-size: 0.85rem;
        font-family: inherit;
        cursor: pointer;
        appearance: none;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23aeb9dd'%3E%3Cpath d='M12 16L6 10H18L12 16Z'%3E%3C/path%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-position: right 0.5rem center;
        background-size: 1em;
        min-width: 90px;
        transition: border-color 0.2s ease;
    }
    #outputFormatSelect:focus {
        outline: none;
        border-color: var(--accent-primary);
        box-shadow: 0 0 0 2px rgba(0, 198, 255, 0.3);
    }

    #jpegQualityGlobalRow, #webpQualityGlobalRow {
        display: none;
        flex-basis: 100%;
        margin-top: 0.75rem;
        background-color: transparent;
        border: none;
        margin-bottom: 0;
    }

    .setting-group-title {
        font-size: 0.9rem;
        color: var(--text-primary);
        font-weight: 500;
        margin-bottom: 0.5rem;
        flex-basis: 100%;
    }

    .segmented-controls { display: flex; border-radius: var(--border-radius-md); overflow: hidden; background-color: var(--bg-tertiary); margin-bottom: 1.25rem; border: 1px solid var(--border-color); flex-shrink: 0; width: 100%; /* Ensure segmented controls take full width */ }
    .segmented-controls button { flex: 1; background-color: transparent; text-align: center; border: none; padding: 0.65rem 0.5rem; color: var(--text-tertiary); cursor: pointer; transition: background 0.2s, color 0.3s, box-shadow 0.2s; font-family: inherit; font-size: 0.85rem; font-weight: 500; border-left: 1px solid var(--border-color); position: relative; white-space: nowrap; }
    .segmented-controls button:first-child { border-left: none; }
    .segmented-controls button:hover:not(.active) { background-color: var(--border-color); color: var(--text-primary); }
    .mode-tabs button[data-mode="auto"].active { background: var(--gradient-interval); }
    .mode-tabs button[data-mode="autoSmart"].active { background: var(--gradient-secondary); }
    .mode-tabs button[data-mode="manual"].active { background: var(--gradient-primary); }
    .mode-tabs button[data-mode="contactSheet"].active { background: var(--gradient-tertiary); }
    .mode-tabs button.active { color: var(--bg-primary); font-weight: 600; box-shadow: inset 0 1px 3px rgba(0,0,0,0.2); }
    .smart-algo-tabs button.active { background: var(--gradient-secondary); color: var(--bg-primary); font-weight: 600; box-shadow: inset 0 1px 2px rgba(0,0,0,0.15); }
    .grid-size-tabs button.active { background: var(--gradient-tertiary); color: var(--bg-primary); font-weight: 600; box-shadow: inset 0 1px 2px rgba(0,0,0,0.15); }
    .grid-size-tabs button {
        position: relative;
        padding-right: 24px;
    }
    .grid-size-tabs button.completed::after {
        content: "✓";
        position: absolute;
        right: 8px;
        top: 50%;
        transform: translateY(-50%);
        font-weight: bold;
        color: var(--accent-tertiary);
    }
    .grid-size-tabs button.active.completed::after {
        color: var(--bg-primary);
    }
    .smart-algo-tabs, .grid-size-tabs { margin-bottom: 0.8rem; }
    .smart-algo-tabs button, .grid-size-tabs button { padding: 0.5rem 0.5rem; font-size: 0.8rem; }

    .mode-content { flex-grow: 1; overflow-y: auto; padding-right: 5px; }
    .mode-content > div { display: none; }
    .mode-content > div.active { display: block; }

    .slider-row { display: flex; align-items: center; gap: 1rem; margin-bottom: 0; padding-bottom: 0.75rem; flex-wrap: wrap; }
    .slider-label, h3.slider-label { width: 100px; text-align: left; font-size: 0.85rem; color: var(--text-tertiary); flex-shrink: 0; margin: 0; font-weight: normal; }
    .slider-wrapper { flex: 1; display: flex; align-items: center; gap: 0.8rem; min-width: 150px; }
    .value-display {
        font-weight: 500;
        min-width: 40px;
        text-align: right;
        font-family: var(--data-font);
        color: var(--text-primary);
        font-size: 0.9rem;
    }
    input[type="range"] { -webkit-appearance: none; -moz-appearance: none; appearance: none; width: 100%; height: 6px; background: var(--bg-tertiary); border-radius: var(--border-radius-full); outline: none; cursor: pointer; transition: background 0.2s; }
    input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 18px; height: 18px; border-radius: 50%; background: var(--white); border: none; box-shadow: 0 1px 4px rgba(0, 0, 0, 0.25); transition: transform 0.1s ease-out; }
    input[type="range"]::-moz-range-thumb { width: 18px; height: 18px; border-radius: 50%; background: var(--white); border: none; box-shadow: 0 1px 4px rgba(0, 0, 0, 0.25); transition: transform 0.1s ease-out; }
    input[type="range"]:active::-webkit-slider-thumb, input[type="range"]:active::-moz-range-thumb { transform: scale(1.1); }

    #jpegQualityGlobalRow input[type="range"]:focus-visible,
    #webpQualityGlobalRow input[type="range"]:focus-visible { outline: 2px solid var(--accent-primary); outline-offset: 2px; }
    #autoSmartMode input[type="range"]:focus-visible { outline-color: var(--accent-secondary); }
    #manualMode input[type="range"]:focus-visible { outline-color: var(--accent-primary); }
    #contactSheetMode input[type="range"]:focus-visible { outline-color: var(--accent-tertiary); }


    .button-group { display: flex; flex-direction: column; gap: 0.75rem; margin-top: 1rem; }
    .action-button { width: 100%; padding: 0.75rem 1.5rem; font-size: 0.95rem; border: none; border-radius: var(--border-radius-md); color: var(--bg-primary); cursor: pointer; transition: background 0.3s ease, opacity 0.2s, color 0.2s, box-shadow 0.2s ease; text-align: center; font-weight: 600; background-size: 200% auto; box-shadow: 0 3px 5px rgba(0, 0, 0, 0.1); display: inline-flex; align-items: center; justify-content: center;}
    .action-button:hover:enabled { box-shadow: 0 5px 10px rgba(0, 0, 0, 0.15); background-position: right center; }
    .action-button:active:enabled { transform: scale(0.98); box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); }
    .action-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      box-shadow: none;
      filter: saturate(0.4) brightness(0.85);
    }
    /* Icon Styles */
    .action-button i, .secondary-button i {
      margin-left: 0.5em;
      vertical-align: middle;
      font-size: 1.1em;
      line-height: 1;
    }
     .action-button.secondary-button i {
         color: inherit;
     }

     #addManualButton i, #extractManualButton i, #clearScreenshotsButton .delete-icon-svg {
         margin-right: 0;
         margin-left: 0.5em;
     }
      #addManualButton, #extractManualButton {
        padding-left: 1.2rem;
      }

    #previewContactSheetButton i { color: var(--accent-tertiary); }
    #previewContactSheetButton:hover:enabled i { color: var(--accent-tertiary-dark); }
    #downloadContactSheetButton i { color: var(--accent-tertiary); }
    #downloadContactSheetButton:hover:enabled i { color: var(--accent-tertiary-dark); }
    #downloadManualButton i { color: var(--accent-primary); }
    #downloadManualButton:hover:enabled i { color: var(--accent-primary-dark); }
    #downloadAllButton i { color: var(--accent-interval); }
    #downloadAllButton:hover:enabled i { color: var(--accent-interval-dark); }
    #downloadAllSmartButton i { color: var(--accent-secondary); }
    #downloadAllSmartButton:hover:enabled i { color: var(--accent-secondary-dark); }

    .secondary-button:disabled i { opacity: 0.6; }


    #processButton, #intervalModeButtons .action-button:not(.secondary-button) { background: var(--gradient-interval); }
    #processSmartButton, #smartModeButtons .action-button:not(.secondary-button) { background: var(--gradient-secondary); }
    #processContactSheetButton, #contactSheetModeButtons .action-button:not(.secondary-button) { background: var(--gradient-tertiary); }
    #addManualButton, #manualModeButtons .action-button:not(.secondary-button) { background: var(--gradient-primary); }

    .action-button.cancel-active { background: var(--gradient-danger) !important; color: var(--white) !important; }
    .action-button.cancel-active:hover:enabled { background: var(--gradient-danger) !important; filter: brightness(1.1); }

    #downloadAllButton, #downloadAllSmartButton, #downloadManualButton, #downloadContactSheetButton { background: transparent; border: 1px solid var(--accent-tertiary); color: var(--accent-tertiary); padding: calc(0.75rem - 1px) calc(1.5rem - 1px); box-shadow: none; }
    #downloadAllButton { border-color: var(--accent-interval); color: var(--accent-interval); }
    #downloadAllButton:hover:enabled { background-color: rgba(154, 110, 255, 0.1); border-color: var(--accent-interval-dark); color: var(--accent-interval-dark); }
    #downloadAllSmartButton { border-color: var(--accent-secondary); color: var(--accent-secondary); }
    #downloadAllSmartButton:hover:enabled { background-color: rgba(45, 212, 191, 0.1); border-color: var(--accent-secondary-dark); color: var(--accent-secondary-dark); }
    #downloadManualButton { border-color: var(--accent-primary); color: var(--accent-primary); }
    #downloadManualButton:hover:enabled { background-color: rgba(0, 198, 255, 0.1); border-color: var(--accent-primary-dark); color: var(--accent-primary-dark); }
    #downloadContactSheetButton { border-color: var(--accent-tertiary); color: var(--accent-tertiary); }
    #downloadContactSheetButton:hover:enabled { background-color: rgba(255, 106, 193, 0.1); border-color: var(--accent-tertiary-dark); color: var(--accent-tertiary-dark); box-shadow: none; }

    #downloadAllButton:disabled { background: transparent; border-color: var(--accent-interval); color: var(--accent-interval); opacity: 0.5; box-shadow: none; }
    #downloadAllSmartButton:disabled { background: transparent; border-color: var(--accent-secondary); color: var(--accent-secondary); opacity: 0.5; box-shadow: none; }
    #downloadManualButton:disabled { background: transparent; border-color: var(--accent-primary); color: var(--accent-primary); opacity: 0.5; box-shadow: none; }
    #downloadContactSheetButton:disabled { background: transparent; border-color: var(--accent-tertiary); color: var(--accent-tertiary); opacity: 0.5; box-shadow: none; }

    .clear-delete-button {
        border-radius: var(--border-radius-md);
        cursor: pointer;
        transition: background-color 0.2s, color 0.2s, border-color 0.2s, box-shadow 0.2s, opacity 0.2s;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-weight: 500;
        background-color: rgba(244, 63, 94, 0.1);
        color: var(--danger-color);
        border: 1px solid var(--danger-color);
        box-shadow: 0 1px 4px rgba(244, 63, 94, 0.1);
    }
    .clear-delete-button:hover:enabled {
        background-color: var(--danger-color);
        color: var(--black);
        box-shadow: none;
    }
    .clear-delete-button:disabled {
        opacity: 0.4;
        cursor: not-allowed;
        box-shadow: none;
        background-color: rgba(244, 63, 94, 0.1);
        color: var(--danger-color);
        border: 1px solid var(--danger-color);
    }
    #clearScreenshotsButton {
        margin-top: 0;
        padding: 0.6rem 1rem 0.6rem 0.8rem;
        font-size: 0.85rem;
        width: auto;
        flex-shrink: 0;
    }
    #clearScreenshotsButton .delete-icon-svg {
        margin-right: 0.5em;
    }

    .delete-icon-svg {
      width: 1.1em;
      height: 1.1em;
      fill: currentColor;
      vertical-align: middle;
    }

    #manualVideo {
        width: 100%;
        border-radius: var(--border-radius-lg);
        background-color: var(--black);
        margin-bottom: 1rem;
        border: 1px solid var(--border-color);
        display: block;
        min-height: 200px;
    }

    #addManualButton i {
      display: inline-block;
    }

    #addManualButton.cutting i {
      animation: cut-animation 0.3s ease-in-out;
    }

    /* Scissors cutting animation */
    @keyframes cut-animation {
      0% { transform: rotate(0) scaleY(1); }
      40% { transform: rotate(-20deg) scaleY(-1) scale(1.05); }
      100% { transform: rotate(0) scaleY(1); }
    }

    #addManualButton:hover {
      box-shadow: 0 5px 10px rgba(0, 0, 0, 0.15);
      background-position: right center;
    }
    #addManualButton:active {
      transform: scale(0.98);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .progress-bar-container { width: 100%; height: 8px; background-color: var(--bg-tertiary); border-radius: var(--border-radius-full); overflow: hidden; margin-top: 0.8rem; display: none; border: 1px solid var(--border-color); }
    .progress-bar-fill { height: 100%; width: 0%; border-radius: var(--border-radius-full); transition: width 0.3s ease-out; }
    #progressBarAuto .progress-bar-fill { background: var(--gradient-interval); }
    #progressBarSmart .progress-bar-fill { background: var(--gradient-secondary); }
    #progressBarContactSheet .progress-bar-fill { background: var(--gradient-tertiary); }

    .screenshot-container {
        position: relative;
        overflow: hidden;
        border-radius: var(--border-radius-md);
        border: 1px solid var(--border-color);
        background-color: var(--bg-secondary);
        transition: box-shadow 0.3s ease, border-color 0.3s ease;
    }
    .screenshot-container:hover {
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        border-color: var(--accent-primary);
    }
    .screenshot-container .img-container {
        display: block;
        line-height: 0;
    }
    .screenshot-container img {
        display: block;
        width: 100%;
        height: auto;
        object-fit: cover;
        border-radius: var(--border-radius-md);
        animation: fadeIn 0.5s ease-in-out;
    }
    .screenshot-overlay, .screenshot-container .lightbox-delete-btn {
        position: absolute;
        opacity: 0;
        transition: opacity 0.2s ease-in-out;
        pointer-events: none;
    }

    .screenshot-container:hover .screenshot-overlay, .screenshot-container:hover .lightbox-delete-btn {
        opacity: 1;
        pointer-events: auto;
    }

    .screenshot-overlay {
        left: 0;
        bottom: 0;
        right: 0;
        background: linear-gradient(to top, rgba(0,0,0,0.7), transparent);
        color: var(--white);
        font-size: 0.8rem;
        padding: 1rem 0.6rem 0.4rem;
        text-align: right;
        font-family: 'Source Code Pro', monospace;
    }

    .lightbox-delete-btn {
        padding: 0.5rem 0.75rem;
        font-size: 16px;
        margin-right: 10px;
    }

    .screenshot-container .lightbox-delete-btn {
        position: absolute;
        bottom: 6px;
        left: 6px;
        padding: 0.3rem 0.5rem;
        font-size: 14px;
        opacity: 0;
        width: auto;
        height: auto;
        min-width: 28px;
        min-height: 28px;
    }
     .screenshot-container .lightbox-delete-btn .delete-icon-svg {
         width: 1em;
         height: 1em;
     }

    @keyframes fadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }

    #video, #canvas, #contactSheetCanvas { display: none; }
    #frameCanvas { display: none; }

    #contactSheetVideo { width: 100%; border-radius: var(--border-radius-lg); background-color: var(--black); margin-bottom: 1rem; aspect-ratio: 16 / 9; border: 1px solid var(--border-color); }
    .fine-tune-message { color: var(--accent-tertiary); font-size: 0.85rem; margin: 0.5rem 0 1rem; text-align: center; display: none; }
    .contact-sheet-controls { display: grid; grid-template-columns: repeat(5, 1fr); gap: 0.2rem; margin-bottom: 1rem; }
    .time-input-container { display: flex; flex-direction: column; gap: 0.3rem; position: relative; }
    .time-input-wrapper {
        position: relative;
        display: inline-block;
        width: 100%;
        height: 2rem;
    }
    .time-input {
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        opacity: 0;
        z-index: 1;
        pointer-events: none;
    }
    .time-formatted {
        width: 100%;
        height: 100%;
        font-family: monospace;
        text-align: center;
        position: relative;
        padding: 0.4rem;
        border-radius: var(--border-radius-sm);
        border: 1px solid var(--border-color);
        background-color: var(--input-bg);
        color: var(--text-color);
        box-sizing: border-box;
        cursor: ns-resize;
        user-select: none;
        transition: background-color 0.15s ease;
    }
    .time-formatted:hover {
        background-color: var(--bg-tertiary);
        border-color: var(--accent-tertiary);
    }
    .time-formatted:focus {
        outline: none;
        border-color: var(--accent-tertiary);
    }
    .time-formatted::after {
        content: "↕";
        position: absolute;
        right: 0.5rem;
        top: 50%;
        transform: translateY(-50%);
        color: var(--text-tertiary);
        font-size: 0.9rem;
        opacity: 0.6;
    }
    .time-formatted:hover::after {
        opacity: 1;
        color: var(--accent-tertiary);
    }

    #contactSheetPreview {
        width: 100%;
        margin: 0 auto;
        display: grid;
        grid-template: repeat(var(--grid-rows, 4), 1fr) / repeat(var(--grid-cols, 5), 1fr);
        gap: 2px;
        overflow: hidden;
        background-color: var(--border-color);
        border: 1px solid var(--border-color);
        border-radius: var(--border-radius-md);
    }
    .grid-cell {
        background-color: var(--bg-secondary);
        position: relative;
        overflow: hidden;
        border: none;
        display: flex;
        width: 100%;
        height: 100%;
        min-height: 70px;
        align-items: center;
        justify-content: center;
    }
    .grid-cell.filled {
        cursor: pointer;
    }
    .grid-cell img {
        max-width: 100%;
        min-width: none;
        max-height: 100%;
        min-height: max-content;
        object-fit: contain;
        display: block;
        opacity: 0;
        transition: opacity 0.3s ease;
    }
    .grid-cell.filled img {
        opacity: 1;
        animation: fadeIn 0.3s ease-in-out;
    }
    .grid-cell .screenshot-overlay {
        opacity: 0;
        transition: opacity 0.2s ease-in-out;
        pointer-events: none;
        position: absolute;
    }
    .grid-cell:hover .screenshot-overlay { opacity: 1; pointer-events: auto; }
    .contact-sheet-label { color: var(--accent-tertiary); font-size: 0.9rem; font-weight: 500; margin: 1rem 0 0.5rem; text-align: center; width: 100%; }

    .time-input-container .time-formatted {
        transition: border-color 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease;
    }
    .time-input-container.highlight .time-formatted {
        border-color: var(--accent-tertiary);
        box-shadow: 0 0 0 2px rgba(255, 140, 220, 0.3);
        background-color: rgba(255, 140, 220, 0.05);
    }
    .grid-cell {
        transition: outline 0.2s ease;
    }
    .grid-cell.highlight {
        outline: 2px solid var(--accent-tertiary);
        outline-offset: -1px;
        position: relative;
        z-index: 2;
    }
     .grid-cell.input-hover-highlight {
        outline: 2px solid var(--accent-tertiary);
        outline-offset: -1px;
        position: relative;
        z-index: 1;
     }
    .grid-cell.highlight img {
        opacity: 1;
    }
    .frame-adjust-buttons {
        position: absolute;
        bottom: 8px;
        left: 50%;
        transform: translateX(-50%);
        display: none;
        gap: 2px;
        z-index: 5;
        background: transparent;
        width: auto;
        justify-content: center;
    }

    .grid-cell.highlight:not(.input-hover-highlight) .frame-adjust-buttons {
        display: flex;
    }

    .frame-adjust-btn {
        width: auto;
        min-width: 28px;
        height: 28px;
        border-radius: 4px;
        background-color: rgba(0, 0, 0, 0.75);
        color: white;
        border: 1px solid rgba(255, 255, 255, 0.6);
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 0.3em;
        padding: 0 0.4em;
        font-weight: bold;
        font-size: 16px;
        cursor: pointer;
        transition: background-color 0.15s ease, transform 0.15s ease;
        user-select: none;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.4);
    }
    .frame-adjust-btn:hover {
        background-color: var(--accent-tertiary);
        transform: scale(1.1);
    }
    .frame-adjust-btn:active {
        transform: scale(0.95);
        background-color: var(--accent-tertiary-dark);
    }
    .frame-adjust-btn i {
        font-size: 1.1em;
        vertical-align: middle;
    }
    .frame-adjust-btn .icon-flipped {
        transform: scaleX(-1);
    }


    #contactSheetMode .video-container, #contactSheetMode #contactSheetVideo {
        display: none;
    }
    .disclaimer-note {
        text-align: center;
        color: var(--text-tertiary);
        font-style: italic;
        margin: 1rem 0 0.5rem;
        font-size: 0.85rem;
        padding: 0.3rem 0.6rem;
        background-color: rgba(36, 44, 68, 0.5);
        border-radius: var(--border-radius-sm);
    }
    #largeGridMessage {
        display: none;
    }


    .sticky-button-container {
        position: sticky;
        bottom: 0;
        background-color: var(--bg-secondary);
        padding-top: 1rem;
        margin-top: auto;
        border-top: 1px solid var(--border-color);
        z-index: 10;
        display: flex;
        flex-direction: column;
    }

    .sticky-button-container .button-group {
        display: flex;
        flex-direction: column;
        margin-bottom: 0.75rem;
    }

    .status-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0.5rem;
    }

    .status-row #clearScreenshotsButton {
        margin-right: 0.75rem;
    }

    .status-row #imageCountDisplay {
        flex: 1;
        margin-top: 0;
        margin-bottom: 0;
    }

    .status-row .info-icon {
        margin-left: 1rem;
        color: var(--text-tertiary);
        cursor: pointer;
        transition: color 0.2s ease;
        font-size: 1.1rem;
    }

    .status-row .info-icon:hover {
        color: var(--accent-primary);
    }

    .status-row #toolInfoButton {
        background-color: var(--bg-secondary);
        border: 1px solid var(--border-color);
        color: var(--text-tertiary);
        border-radius: var(--border-radius-md);
        cursor: pointer;
        padding: 0.45rem;
        transition: all 0.2s ease;
        margin-left: 0.75rem;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 500;
        font-size: 0.9rem;
        min-width: 2.2rem;
        aspect-ratio: 1;
    }

    .status-row #toolInfoButton:hover {
        background-color: var(--bg-tertiary);
        border-color: var(--text-tertiary);
        color: var(--text-primary);
    }

    .status-row #toolInfoButton:active {
        transform: scale(0.95);
    }

    .status-row #toolInfoButton i {
        font-size: 1.1rem;
    }

    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.75);
        z-index: 1000;
        display: flex;
        justify-content: center;
        align-items: center;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease, visibility 0.3s ease;
    }

    .modal-overlay.active {
        opacity: 1;
        visibility: visible;
    }

    .info-box-content {
        background: var(--bg-secondary);
        border-radius: var(--border-radius-lg);
        max-width: 600px;
        max-height: 90vh;
        overflow-y: auto;
        padding: 1.5rem;
        position: relative;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
        transform: translateY(20px);
        transition: transform 0.3s ease;
    }

    .modal-overlay.active .info-box-content {
        transform: translateY(0);
    }

    .modal-close {
        position: absolute;
        top: 1rem;
        right: 1rem;
        color: var(--text-tertiary);
        background: none;
        border: none;
        font-size: 1.5rem;
        cursor: pointer;
        transition: color 0.2s ease;
    }

    .modal-close:hover {
        color: var(--accent-primary);
    }

    .modal-title {
        font-size: 1.5rem;
        margin-bottom: 1rem;
        color: var(--text-primary);
        padding-bottom: 0.75rem;
    }

    .modal-body {
        color: var(--text-tertiary);
        line-height: 1.6;
    }

    .modal-body p {
        margin-bottom: 1rem;
    }

    .modal-body h3 {
        color: var(--text-primary);
        margin: 1.5rem 0 0.5rem;
        font-size: 1.1rem;
    }

    .modal-body ul {
        padding-left: 1.5rem;
        margin-bottom: 1rem;
    }

    .modal-body li {
        margin-bottom: 0.5rem;
    }
     .modal-body a {
        color: var(--accent-primary);
        text-decoration: none;
        transition: color 0.2s ease;
     }
      .modal-body a:hover {
         color: var(--accent-primary-dark);
         text-decoration: underline;
      }


    .sticky-button-container #progressBarAuto,
    .sticky-button-container #progressBarSmart,
    .sticky-button-container #progressBarContactSheet {
        margin-top: 0;
    }

    .progress-bar-wrapper {
        height: 12px;
        margin-bottom: 0.75rem;
        position: relative;
    }

    .progress-bar-container {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 100%;
        background-color: var(--bg-tertiary);
        border-radius: var(--border-radius-sm);
        overflow: hidden;
    }

    .progress-bar-fill {
        height: 100%;
        width: 0%;
        background: var(--gradient-interval);
        border-radius: var(--border-radius-sm);
        transition: width 0.1s ease;
    }

    #progressBarSmart .progress-bar-fill {
        background: var(--gradient-secondary);
    }

    #progressBarContactSheet .progress-bar-fill {
        background: var(--gradient-tertiary);
    }


    .action-button-row {
        display: flex;
        gap: 0.75rem;
        width: 100%;
    }
    .action-button-row .action-button {
        flex: 1;
    }

    .secondary-button {
        background: transparent;
        border: 1px solid var(--accent-tertiary);
        color: var(--accent-tertiary);
        padding: calc(0.75rem - 1px) calc(1.5rem - 1px);
        box-shadow: none;
    }
    .secondary-button:hover:enabled {
        background-color: rgba(255, 106, 193, 0.1);
        border-color: var(--accent-tertiary-dark);
        color: var(--accent-tertiary-dark);
        box-shadow: none;
    }

    #manualModeButtons .secondary-button {
        border-color: var(--accent-primary);
        color: var(--accent-primary);
    }
    #manualModeButtons .secondary-button:hover:enabled {
        background-color: rgba(0, 198, 255, 0.1);
        border-color: var(--accent-primary-dark);
        color: var(--accent-primary-dark);
    }
    #smartModeButtons .secondary-button {
        border-color: var(--accent-secondary);
        color: var(--accent-secondary);
    }
    #smartModeButtons .secondary-button:hover:enabled {
        background-color: rgba(94, 234, 212, 0.1);
        border-color: var(--accent-secondary-dark);
        color: var(--accent-secondary-dark);
    }

    #extractManualButton {
        border-color: var(--accent-primary) !important;
        color: var(--accent-primary) !important;
    }
    #extractManualButton:hover:enabled {
        background-color: rgba(0, 198, 255, 0.1) !important;
        border-color: var(--accent-primary-dark) !important;
        color: var(--accent-primary-dark) !important;
    }

    #processButton { background: var(--gradient-interval); }

    .screenshot-lightbox-content {
        max-width: 90%;
        max-height: 90vh;
        display: flex;
        flex-direction: column;
        padding: 0;
        position: relative;
        background-color: var(--bg-secondary);
    }

    .screenshot-lightbox-content .modal-close {
        position: absolute;
        top: 10px;
        right: 10px;
        background-color: rgba(0, 0, 0, 0.5);
        color: var(--white);
        border-radius: 50%;
        width: 36px;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10;
    }

    
    .screenshot-lightbox-container {
        display: flex;
        overflow: hidden;
        position: relative;
    }

    .screenshot-lightbox-container img {
        max-width: 100%;
        max-height: 100%;
        object-fit: contain;
        margin: auto;
    }

    .lightbox-nav-btn {
        background-color: var(--bg-tertiary);
        color: var(--text-primary);
        border: 1px solid var(--border-color);
        padding: 0.5rem 0.75rem;
        border-radius: var(--border-radius-sm);
        cursor: pointer;
        font-size: 0.9rem;
        line-height: 1;
        transition: background-color 0.2s, border-color 0.2s, color 0.2s;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        white-space: nowrap;
        margin: 0 5px;
    }
     .lightbox-nav-btn:hover:enabled {
        background-color: var(--border-color);
        border-color: var(--text-secondary);
        color: var(--text-primary);
     }
     .lightbox-nav-btn:disabled {
        background-color: var(--bg-tertiary);
        color: var(--text-secondary);
        cursor: not-allowed;
        opacity: 0.6;
        border-color: var(--border-color);
     }
     .lightbox-nav-btn i {
        font-size: 1.1em;
        margin: 0 0.3em;
        vertical-align: middle;
     }
     .lightbox-nav-btn .nav-text {
        margin: 0 0.4em;
    }
    .lightbox-nav-btn .nav-icon {
       font-size: 1.2em;
       line-height: 1;
    }

    #lightboxDownload {
        background-color: var(--bg-tertiary);
        color: var(--text-primary);
        border: 1px solid var(--border-color);
        padding: 0.5rem 1rem;
        border-radius: var(--border-radius-sm);
        font-weight: 500;
        gap: 0.5em;
         display: inline-flex;
        align-items: center;
        justify-content: center;
        text-decoration: none;
        transition: background-color 0.2s, border-color 0.2s, color 0.2s;
    }
    #lightboxDownload:hover:enabled {
        background-color: var(--border-color);
        border-color: var(--text-secondary);
        color: var(--text-primary);
    }
     #lightboxDownload i {
        font-size: 1.1em;
     }


    .prev-btn, .next-btn {
        position: static;
        transform: none;
        opacity: 1;
        width: auto;
        height: auto;
    }

    .screenshot-lightbox-info {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 20px;
        background-color: var(--bg-secondary);
        border-top: 1px solid var(--border-color);
        height: 60px;
        flex-shrink: 0;
    }

    .lightbox-controls-left {
        display: flex;
        align-items: center;
        gap: 10px;
    }
     #lightboxFrameNumber {
         color: var(--text-secondary);
         font-size: 0.9em;
         margin-left: 5px;
         font-family: var(--data-font);
     }
     .screenshot-lightbox-content:not(.contact-sheet-mode) #lightboxFrameNumber {
         display: none;
     }
     .screenshot-lightbox-content.contact-sheet-mode #lightboxDeleteBtn {
         display: none;
     }
    .lightbox-frame-adjust-controls {
        display: none;
        align-items: center;
        gap: 5px;
    }
    .screenshot-lightbox-content.contact-sheet-mode .lightbox-frame-adjust-controls {
        display: inline-flex;
    }
    .lightbox-adjust-btn {
        background-color: var(--bg-tertiary);
        color: var(--text-primary);
        border: 1px solid var(--border-color);
        padding: 0.3rem 0.6rem;
        border-radius: var(--border-radius-sm);
        cursor: pointer;
        font-size: 0.9rem;
        line-height: 1;
        transition: background-color 0.2s, border-color 0.2s;
        display: inline-flex;
        align-items: center;
        gap: 0.2em;
    }
     .lightbox-adjust-btn i {
        font-size: 1em;
        vertical-align: middle;
     }
     .lightbox-adjust-btn .icon-flipped {
         transform: scaleX(-1);
     }
    .lightbox-adjust-btn:hover {
        background-color: var(--border-color);
        border-color: var(--text-secondary);
    }


    #lightboxTimestamp {
        font-family: 'Source Code Pro', monospace;
        color: var(--text-primary);
        font-size: 1rem;
        margin: 0 15px;
        min-width: 60px;
        text-align: center;
    }

    .lightbox-nav-controls {
        display: flex;
        flex-direction: row;
        align-items: center;
        gap: 5px;
    }

    #lightboxDeleteBtn {
        margin-right: 10px;
        min-width: 36px;
        min-height: 36px;
    }

    .mode-description {
        color: var(--text-tertiary);
        font-size: 0.9rem;
        margin-bottom: 1rem;
        background-color: rgba(36, 44, 68, 0.5);
        border-radius: var(--border-radius-sm);
        padding: 0.5rem 0.8rem;
    }

    #customGridControls input[type="number"] {
        background-color: var(--input-bg);
        border: 1px solid var(--border-color);
        color: var(--text-color);
        border-radius: var(--border-radius-sm);
        padding: 0.3rem 0.5rem;
        font-family: var(--data-font);
        text-align: center;
        width: 55px;
        margin-left: 0.5rem;
     }
      #customGridControls input[type="number"]:focus {
        outline: none;
        border-color: var(--accent-tertiary);
        box-shadow: 0 0 0 2px rgba(255, 140, 220, 0.3);
     }
      #customGridControls span {
        color: var(--text-secondary);
        font-weight: bold;
        margin: 0 0.25rem;
     }
     #customGridControls label {
        color: var(--text-secondary);
     }

     #processContactSheetButton.needs-update {
        background: var(--gradient-tertiary);
        animation: pulse-tertiary 1.5s infinite;
     }
     #downloadContactSheetButton.needs-update, #previewContactSheetButton.needs-update {
        border-color: var(--accent-tertiary);
     }

     .disclaimer-note {
        text-align: center;
        color: var(--text-tertiary);
        font-style: italic;
        margin: 0.75rem 0 0.5rem;
        font-size: 0.85rem;
        padding: 0.3rem 0.6rem;
        background-color: rgba(36, 44, 68, 0.5);
        border-radius: var(--border-radius-sm);
    }
    #largeGridDisclaimer {
        display: none;
        margin-bottom: 1rem;
    }


     @keyframes pulse-tertiary {
        0% { box-shadow: 0 0 0 0 rgba(255, 140, 220, 0.4); }
        70% { box-shadow: 0 0 0 6px rgba(255, 140, 220, 0); }
        100% { box-shadow: 0 0 0 0 rgba(255, 140, 220, 0); }
     }

     @media (max-width: 800px) {
        body { overflow-y: auto; height: auto; }
        .app-container { flex-direction: column; height: auto; overflow: visible; }
        .vertical-separator { display: none; }
        .settings-column { flex-basis: auto; width: 100%; height: auto; max-height: none; border-right: none; overflow-y: visible; padding: 0; }
        .settings-content-wrapper { direction: ltr; padding: var(--content-padding); height: auto; }
        .output-column { width: 100%; overflow-y: visible; }
        #screenshots { padding: 0; }
        .mode-content { overflow: visible; }
        .lightbox-nav-btn .nav-text { display: none; }
        #lightboxDownload span { display: none; }
    }

  </style>
</head>
<body>

  <div class="app-container">

    <div class="vertical-separator"></div>

    <div class="settings-column">
      <div class="settings-content-wrapper">
        <h1 id="pageTitle" data-text="Pilko Frame Capture Studio">Pilko Frame Capture Studio</h1>

        <div id="dropZone">
            <div id="uploadIcon"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM14 13v4h-4v-4H7l5-5 5 5h-3z"/></svg></div>
            <div id="dropZoneText">Drag & drop video file or</div>
            <div id="loadedFileInfo">
                <div class="file-name-row">
                    <div id="loadedFileName">Filename goes here</div>
                    <button id="selectFileButton" class="file-loaded-button">Change File</button>
                </div>
                <div id="loadedFileStats">
                    <div class="info-row"><div class="info-label">Resolution</div><div class="info-value" id="resolutionValue">-</div></div>
                    <div class="info-row"><div class="info-label">Duration</div><div class="info-value" id="lengthValue">-</div></div>
                    <div class="info-row"><div class="info-label">Aspect Ratio</div><div class="info-value" id="aspectRatioValue">-</div></div>
                    <div class="info-row"><div class="info-label">Bitrate</div><div class="info-value" id="bitrateValue">-</div></div>
                </div>
            </div>
            <button id="initialSelectFileButton" type="button">Select File</button>
            <input type="file" id="videoInput" accept="video/*">
        </div>

        <div class="setting-row toggle-row">
            <label class="setting-label toggle-label">
                Remove Black Bars
                <i class="ri-question-line info-icon-inline" title="Automatically detect and crop black bars from letterboxed videos"></i>
            </label>
            <div class="toggle-switch">
                <input type="checkbox" id="removeBarsToggle" class="toggle-input">
                <label for="removeBarsToggle" class="toggle-label-switch"></label>
            </div>
        </div>

        <!-- Global Format Selection -->
        <div id="format-options-row" class="setting-row">
            <label class="setting-label format-label">Output Format</label>
            <div class="format-controls">
                <select id="outputFormatSelect">
                    <option value="png" selected>PNG</option>
                    <option value="jpeg">JPEG</option>
                    <option value="webp">WEBP</option>
                </select>
            </div>
            <div class="slider-row" id="jpegQualityGlobalRow">
                <h3 class="slider-label">JPEG Quality</h3>
                <div class="slider-wrapper">
                    <input type="range" id="jpegQualityGlobal" min="1" max="100" value="90" step="1">
                    <span id="jpegQualityGlobalValue" class="value-display">90%</span>
                </div>
            </div>
            <div class="slider-row" id="webpQualityGlobalRow">
                <h3 class="slider-label">WEBP Quality</h3>
                <div class="slider-wrapper">
                    <input type="range" id="webpQualityGlobal" min="1" max="100" value="90" step="1">
                    <span id="webpQualityGlobalValue" class="value-display">90%</span>
                </div>
            </div>
        </div>
        <!-- End Global Format Selection -->

        <div class="segmented-controls mode-tabs">
            <button class="mode-tab active" data-mode="manual">Manual</button>
            <button class="mode-tab" data-mode="auto">Interval</button>
            <button class="mode-tab" data-mode="autoSmart">Smart Auto</button>
            <button class="mode-tab" data-mode="contactSheet">Contact Sheet</button>
        </div>

        <div class="mode-content">
            <div id="manualMode" class="active">
              <p class="mode-description">Use the video player to navigate and press Cut Frame to capture screenshots.</p>
              <video id="manualVideo" controls></video>
            </div>
            <div id="autoMode">
                <p class="mode-description">Extract screenshots at regular time intervals. Lower value creates more images, higher value creates fewer.</p>
                <div class="slider-row"><h3 class="slider-label" style="font-size: 0.9rem; color: var(--text-primary); font-weight: 500;">Interval</h3>
                <div class="slider-wrapper"><input type="range" id="intervalInput" min="1" max="30" value="10" step="1"><span id="intervalValue" class="value-display"></span></div></div>
            </div>
            <div id="autoSmartMode">
               <p class="mode-description">Identify scenes and visual changes. Adjust threshold to control sensitivity to changes.</p>
                <h3 class="setting-group-title">Algorithm</h3>
                <div class="segmented-controls smart-algo-tabs">
                   <button class="smart-tab active" data-algo="histogram">Histogram Diff</button>
                   <button class="smart-tab" data-algo="pixeldiff">Pixel Diff</button>
                </div>
                <div class="slider-row" id="histThresholdSettings">
                   <h3 class="slider-label">Hist Thresh</h3>
                   <div class="slider-wrapper">
                       <input type="range" id="histThresholdInput" min="0.05" max="0.75" value="0.40" step="0.01">
                       <span id="histThresholdValue" class="value-display"></span>
                   </div>
                </div>
                <p class="disclaimer-note">Compares color and brightness distribution between frames. Higher threshold means more sensitive to changes. <strong>Recommended value: 0.40</strong></p>
                <div class="slider-row" id="pixelThresholdSettings" style="display:none;">
                   <h3 class="slider-label">Pixel Thresh</h3>
                   <div class="slider-wrapper">
                       <input type="range" id="pixelThresholdInput" min="5" max="100" value="35" step="1">
                       <span id="pixelThresholdValue" class="value-display"></span>
                   </div>
                </div>
                 <p class="disclaimer-note" id="pixelDiffDisclaimer" style="display: none;">Lower threshold = more sensitive to pixel changes (more frames). <strong>Recommended value: 35</strong></p>
            </div>
            <div id="contactSheetMode">
                <p class="mode-description">Choose a grid size for screenshots. After generating, adjust times below or in the thumbnails.</p>
                <h3 class="setting-group-title">Grid Size</h3>
                <div class="segmented-controls grid-size-tabs">
                    <button class="grid-size-tab active" data-rows="4" data-cols="5">5×4</button>
                    <button class="grid-size-tab" data-rows="3" data-cols="4">4×3</button>
                    <button class="grid-size-tab" data-rows="2" data-cols="3">Custom</button>
                </div>
                <div id="customGridControls" style="display: none; margin-bottom: 1.25rem;">
                    <div style="display: flex; align-items: center; gap: 10px; justify-content: center;">
                        <label style="display: flex; align-items: center;">
                            <span>Columns:</span>
                            <input type="number" id="customGridCols" min="1" value="3">
                        </label>
                        <span>×</span>
                        <label style="display: flex; align-items: center;">
                            <span>Rows:</span>
                            <input type="number" id="customGridRows" min="1" value="2">
                        </label>
                    </div>
                </div>
                <div class="video-container">
                <video id="contactSheetVideo" controls></video>
                </div>
                 <p id="largeGridDisclaimer" class="disclaimer-note">Time inputs hidden for grids larger than 6x6.</p>
                <div class="contact-sheet-controls">
                </div>
            </div>
        </div>

        <div class="sticky-button-container">
            <div class="button-group" id="intervalModeButtons">
                <button id="processButton" class="action-button">Extract Screenshots <i class="ri-scissors-line"></i></button>
                <button id="downloadAllButton" class="action-button secondary-button" disabled>Download All <i class="ri-download-2-line"></i></button>
            </div>

            <div class="button-group" id="smartModeButtons" style="display:none;">
                <button id="processSmartButton" class="action-button">Extract Smart Shots <i class="ri-scissors-line"></i></button>
                <button id="downloadAllSmartButton" class="action-button secondary-button" disabled>Download All <i class="ri-download-2-line"></i></button>
            </div>

            <div class="button-group" id="manualModeButtons" style="display:flex;">
                <button id="addManualButton" class="action-button" type="button">Cut Frame <i class="ri-scissors-line"></i></button>
                <div class="action-button-row">
                    <button id="extractManualButton" class="action-button secondary-button" type="button">Save Frame <i class="ri-download-line"></i></button>
                    <button id="downloadManualButton" class="action-button secondary-button" type="button" disabled>Download All <i class="ri-download-2-line"></i></button>
                </div>
            </div>

            <div class="button-group" id="contactSheetModeButtons" style="display:none;">
                <button id="processContactSheetButton" class="action-button">Generate/Update Sheet</button>
                <div class="action-button-row">
                    <button id="previewContactSheetButton" class="action-button secondary-button" disabled>Preview <i class="ri-image-line"></i></button>
                    <button id="downloadContactSheetButton" class="action-button secondary-button" disabled>Download <i class="ri-download-2-line"></i></button>
                </div>
            </div>

            <div class="progress-bar-wrapper">
                <div id="progressBarAuto" class="progress-bar-container" style="display:none;"><div id="progressBarFillAuto" class="progress-bar-fill"></div></div>
                <div id="progressBarSmart" class="progress-bar-container" style="display:none;"><div id="progressBarFillSmart" class="progress-bar-fill"></div></div>
                <div id="progressBarContactSheet" class="progress-bar-container" style="display:none;"><div id="progressBarFillContactSheet" class="progress-bar-fill"></div></div>
            </div>

            <div class="status-row">
                <button id="clearScreenshotsButton" type="button" class="clear-delete-button" disabled>
                    <svg class="delete-icon-svg" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 1024 1024"><path fill="currentColor" d="M360 184h-8c4.4 0 8-3.6 8-8zm304 0v-8c0 4.4 3.6 8 8 8h-8v72h72v-80c0-35.3-28.7-64-64-64H352c-35.3 0-64 28.7-64 64v80h72zm504 72H160c-17.7 0-32 14.3-32 32v32c0 4.4 3.6 8 8 8h60.4l24.7 523c1.6 34.1 29.8 61 63.9 61h454c34.2 0 62.3-26.8 63.9-61l24.7-523H888c4.4 0 8-3.6 8-8v-32c0-17.7-14.3-32-32-32M731.3 840H292.7l-24.2-512h487z"/></svg>
                    Clear Output
                </button>
                <div id="imageCountDisplay">Generated Images:<span id="imageCountValue">0</span></div>
                <button id="toolInfoButton" type="button" title="About this tool"><i class="ri-information-line"></i></button>
            </div>
        </div>

      </div>
    </div>

    <div class="output-column" id="outputColumn">
      <div id="screenshots">
      </div>
      <div id="contactSheetPreview">
      </div>
    </div>

  </div>

  <video id="video" style="display:none;"></video>
  <canvas id="canvas"></canvas>
  <canvas id="frameCanvas" style="display:none;"></canvas>
  <canvas id="contactSheetCanvas" style="display:none;"></canvas>

  <div class="modal-overlay" id="toolInfoModal">
    <div class="info-box-content">
      <button class="modal-close" id="modalClose"><i class="ri-close-line"></i></button>
      <h2 class="modal-title">Pilko Frame Capture Studio</h2>
      <div class="modal-body">
        <p>Pilko Frame Capture Studio is a web tool that lets you extract screenshots from your videos in many different ways locally within your browser.</p>

        <h3>Extraction Modes</h3>
          <ul>
            <li><strong style="color: var(--accent-primary)">Manual</strong><br><span>Manually select and capture specific frames from the video player.</span></li>
            <li><strong style="color: var(--accent-interval)">Interval</strong><br><span>Extract frames at regular time intervals (seconds).</span></li>
            <li><strong style="color: var(--accent-secondary)">Smart Auto</strong><br><span>Automatically extract visually distinct frames using advanced algorithms.</span></li>
              <ul>
                <li><strong style="color: var(--accent-secondary)">Histogram Diff</strong> compares the overall distribution of colors and brightness levels between frames. If the distribution is different enough (determined by the slider value) in a scene change, it triggers a frame capture.</li>
                <li><strong style="color: var(--accent-secondary)">Pixel Diff</strong> measures the percentage of pixels that have changed between frames. If the percentage is above the threshold (determined by the slider value), a frame capture will be triggered.</li>
              </ul>
            </li>
            <li><strong style="color: var(--accent-tertiary)">Contact Sheet</strong><br><span>Generate a grid of screenshots to a single image.</span></li>
          </ul>

        <h3>Supported Formats</h3>
        <ul>
          <li><strong style="color: var(--text-primary)">PNG</strong> - Lossless frame capture from video source.</li>
          <li><strong style="color: var(--text-primary)">JPEG</strong> - Compressed frame capture with adjustable quality.</li>
          <li><strong style="color: var(--text-primary)">WEBP</strong> - Compressed frame capture with adjustable quality.</li>
        </ul>

        <h3>Processing & Privacy</h3>
        <p>All video processing and screenshot extraction happen locally within the browser, with no cloud or server-side dependencies, ensuring your privacy.<br>This website already performs all processing locally, but you can also self-host it for full peace of mind. View the source code on <a href="https://github.com/your-repo-link" target="_blank" rel="noopener noreferrer" style="color: var(--text-primary)">GitHub</a>.</p>

      </div>
    </div>
  </div>

  <div class="modal-overlay" id="screenshotLightbox">
    <div class="info-box-content screenshot-lightbox-content">
      <button class="modal-close" id="lightboxClose"><i class="ri-close-line"></i></button>
      <div class="screenshot-lightbox-container">
        <img id="lightboxImage" src="" alt="Screenshot fullscreen view">
      </div>
      <div class="screenshot-lightbox-info">
        <div class="lightbox-controls-left">
           <button class="clear-delete-button lightbox-delete-btn" id="lightboxDeleteBtn" title="Delete this screenshot (Hotkeys: 🡫, S)">
             <!-- SVG Icon by JS -->
           </button>
           <span id="lightboxFrameNumber"></span> 
        </div>
        <div class="lightbox-nav-controls">
            <div class="lightbox-frame-adjust-controls">
                <button class="lightbox-adjust-btn" id="lightboxAdjustPrev" title="Cut backward by 1s (Hotkey: Q)">-<i class="ri-scissors-line icon-flipped"></i></button>
            </div>
            <button class="lightbox-nav-btn prev-btn" id="lightboxPrevBtn" title="Hotkeys: 🡨, A">
              <span class="nav-icon"><i class="ri-arrow-left-line"></i></span>
              <span class="nav-text">Previous Frame</span>
            </button>
            <span id="lightboxTimestamp"></span>
            <button class="lightbox-nav-btn next-btn" id="lightboxNextBtn" title="Hotkeys: 🡪, D">
              <span class="nav-text">Next Frame</span>
              <span class="nav-icon"><i class="ri-arrow-right-line"></i></span>
            </button>
             <div class="lightbox-frame-adjust-controls">
                <button class="lightbox-adjust-btn" id="lightboxAdjustNext" title="Cut forward by 1s (Hotkey: E)"><i class="ri-scissors-line"></i>+</button>
            </div>
        </div>
        <a id="lightboxDownload" href="#" download="screenshot.png" class="lightbox-action-btn lightbox-download-btn"><span>Download</span> <i class="ri-download-2-line"></i></a>
      </div>
    </div>
  </div>

  <script>
    'use strict';

    const DELETE_ICON_SVG = `<svg class="delete-icon-svg" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 1024 1024"><path fill="currentColor" d="M360 184h-8c4.4 0 8-3.6 8-8zm304 0v-8c0 4.4 3.6 8 8 8h-8v72h72v-80c0-35.3-28.7-64-64-64H352c-35.3 0-64 28.7-64 64v80h72zm504 72H160c-17.7 0-32 14.3-32 32v32c0 4.4 3.6 8 8 8h60.4l24.7 523c1.6 34.1 29.8 61 63.9 61h454c34.2 0 62.3-26.8 63.9-61l24.7-523H888c4.4 0 8-3.6 8-8v-32c0-17.7-14.3-32-32-32M731.3 840H292.7l-24.2-512h487z"/></svg>`;

    let verticalSeparatorElement = null;
    let cropData = null;
    let removeBarsEnabled = false;
    let gridCache = {
      '5x4': { data: null, blob: null, completed: false },
      '4x3': { data: null, blob: null, completed: false },
      '3x2': { data: null, blob: null, completed: false }
    };

    const toolInfoIcon = document.getElementById('toolInfoButton');
    const toolInfoModal = document.getElementById('toolInfoModal');
    const modalClose = document.getElementById('modalClose');

    const screenshotLightbox = document.getElementById('screenshotLightbox');
    const lightboxClose = document.getElementById('lightboxClose');

    function toggleModal(modal, show) {
        if (show) {
            modal.classList.add('active');
            document.body.style.overflow = 'hidden';
        } else {
            modal.classList.remove('active');
            document.body.style.overflow = '';
        }
    }

    if (toolInfoIcon && toolInfoModal && modalClose) {
        toolInfoIcon.addEventListener('click', () => toggleModal(toolInfoModal, true));
        modalClose.addEventListener('click', () => toggleModal(toolInfoModal, false));
        toolInfoModal.addEventListener('click', (e) => { if (e.target === toolInfoModal) toggleModal(toolInfoModal, false); });
        document.addEventListener('keydown', (e) => { if (e.key === 'Escape' && toolInfoModal.classList.contains('active')) toggleModal(toolInfoModal, false); });
    }

    if (screenshotLightbox && lightboxClose) {
        lightboxClose.addEventListener('click', () => toggleModal(screenshotLightbox, false));
        screenshotLightbox.addEventListener('click', (e) => {
            if (e.target === screenshotLightbox || e.target.closest('.screenshot-lightbox-container')) {
                // Close when clicking overlay or container, not controls
                if (!e.target.closest('.screenshot-lightbox-info') && e.target !== lightboxClose && !lightboxClose.contains(e.target)) {
                     toggleModal(screenshotLightbox, false);
                }
            }
        });
        // Hotkeys in Lightbox
         document.addEventListener('keydown', (e) => {
            if (screenshotLightbox.classList.contains('active')) {
                 if (e.key === 'Escape') toggleModal(screenshotLightbox, false);
                 if (e.key === 'ArrowLeft' || e.key === 'a') document.getElementById('lightboxPrevBtn')?.click();
                 if (e.key === 'ArrowRight' || e.key === 'd') document.getElementById('lightboxNextBtn')?.click();
                 if (e.key === 'ArrowDown' || e.key === 's') document.getElementById('lightboxDeleteBtn')?.click();
                 if (e.key === 'q') document.getElementById('lightboxAdjustPrev')?.click();
                 if (e.key === 'e') document.getElementById('lightboxAdjustNext')?.click();
             }
        });
    }

    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    document.addEventListener('DOMContentLoaded', () => {
      try {
        const $ = (id) => document.getElementById(id);
        const $$ = (selector, parent = document) => parent.querySelectorAll(selector);

        const dropZone = $('dropZone');
        const videoInput = $('videoInput');
        const selectFileButton = $('selectFileButton');
        const initialSelectFileButton = $('initialSelectFileButton');
        const resolutionValue = $('resolutionValue');
        const lengthValue = $('lengthValue');
        const aspectRatioValue = $('aspectRatioValue');
        const bitrateValue = $('bitrateValue');
        const imageCountDisplay = $('imageCountDisplay');
        const imageCountValue = $('imageCountValue');
        const modeTabs = $$('.mode-tab');
        const modeContentDiv = $$('.mode-content')[0];
        const intervalInput = $('intervalInput');
        const intervalValue = $('intervalValue');
        // Global Format/Quality Controls
        const outputFormatSelect = $('outputFormatSelect');
        const jpegQualityGlobalRow = $('jpegQualityGlobalRow');
        const jpegQualityGlobal = $('jpegQualityGlobal');
        const jpegQualityGlobalValue = $('jpegQualityGlobalValue');
        const webpQualityGlobalRow = $('webpQualityGlobalRow');
        const webpQualityGlobal = $('webpQualityGlobal');
        const webpQualityGlobalValue = $('webpQualityGlobalValue');
        // Smart Auto Controls
        const smartAlgoTabs = $$('.smart-tab');
        const histThresholdSettings = $('histThresholdSettings');
        const pixelThresholdSettings = $('pixelThresholdSettings');
        const histThresholdInput = $('histThresholdInput');
        const histThresholdValue = $('histThresholdValue');
        const pixelThresholdInput = $('pixelThresholdInput');
        const pixelThresholdValue = $('pixelThresholdValue');
        const pixelDiffDisclaimer = $('pixelDiffDisclaimer');
        // Buttons & Progress
        const processButton = $('processButton');
        const downloadAllButton = $('downloadAllButton');
        const progressBarAuto = $('progressBarAuto');
        const progressBarFillAuto = $('progressBarFillAuto');
        const processSmartButton = $('processSmartButton');
        const downloadAllSmartButton = $('downloadAllSmartButton');
        const progressBarSmart = $('progressBarSmart');
        const progressBarFillSmart = $('progressBarFillSmart');
        // Manual Controls
        const manualVideo = $('manualVideo');
        const extractManualButton = $('extractManualButton');
        const addManualButton = $('addManualButton');
        const downloadManualButton = $('downloadManualButton');
        // Contact Sheet Controls
        const contactSheetVideo = $('contactSheetVideo');
        const contactSheetControlsElement = $$('.contact-sheet-controls')[0];
        const processContactSheetButton = $('processContactSheetButton');
        const downloadContactSheetButton = $('downloadContactSheetButton');
        const previewContactSheetButton = $('previewContactSheetButton');
        const progressBarContactSheet = $('progressBarContactSheet');
        let progressBarFillContactSheet = $('progressBarFillContactSheet');
        const contactSheetCanvas = $('contactSheetCanvas');
        const contactSheetPreviewElement = $('contactSheetPreview');
        const largeGridDisclaimer = $('largeGridDisclaimer');
        // Other
        const removeBarsToggle = $('removeBarsToggle');
        const screenshotsDiv = $('screenshots');
        const video = $('video');
        const canvas = $('canvas');
        const frameCanvas = $('frameCanvas');
        const clearScreenshotsButton = $('clearScreenshotsButton');
        const outputColumn = $('outputColumn');
        const gridSizeTabs = $$('.grid-size-tab');
        const customGridControls = $('customGridControls');
        const customGridCols = $('customGridCols');
        const customGridRows = $('customGridRows');

        verticalSeparatorElement = $$('.vertical-separator')[0];

        [dropZone, videoInput, selectFileButton, video, manualVideo, canvas, frameCanvas, contactSheetCanvas, modeContentDiv, screenshotsDiv, clearScreenshotsButton, processContactSheetButton, downloadContactSheetButton, previewContactSheetButton, progressBarContactSheet, $('loadedFileInfo'), $('loadedFileName'), imageCountDisplay, imageCountValue, contactSheetVideo, contactSheetControlsElement, contactSheetPreviewElement, largeGridDisclaimer, outputColumn, histThresholdInput, histThresholdValue, histThresholdSettings, pixelThresholdInput, pixelThresholdValue, pixelThresholdSettings, outputFormatSelect, jpegQualityGlobalRow, jpegQualityGlobal, jpegQualityGlobalValue, webpQualityGlobalRow, webpQualityGlobal, webpQualityGlobalValue, pixelDiffDisclaimer].forEach(el => {
            if (!el) throw new Error(`Missing critical HTML element: ${el?.id || 'unknown'}`);
        });
        if (!progressBarFillContactSheet) throw new Error("Missing critical HTML element: progressBarFillContactSheet");

        let currentMode = 'manual';
        let smartAlgorithm = 'histogram';
        let uploadedFile = null;
        let currentVideoDuration = 0;
        let processingActive = false;
        let cancelExtractionRequested = false;
        let screenshotBlobs = [];
        let manualScreenshotBlobs = [];
        let contactSheetBlob = null; // This holds the *final generated* image blob
        let contactSheetPreviewData = new Array(20).fill(null); // Holds data for *preview* cells {blob, timestamp, blobUrl}
        let currentSamplingProcess = null;

        if (imageCountValue) imageCountValue.classList.add('manual-mode');

        const buttonGroups = {
            auto: $('intervalModeButtons'),
            autoSmart: $('smartModeButtons'),
            contactSheet: $('contactSheetModeButtons'),
            manual: $('manualModeButtons')
        };
        Object.values(buttonGroups).forEach(group => { if (group) group.style.display = 'none'; });
        if (buttonGroups.manual) buttonGroups.manual.style.display = 'flex';

        const progressBarElements = {
            auto: progressBarAuto,
            autoSmart: progressBarSmart,
            contactSheet: progressBarContactSheet
        };
        const progressBarFillElements = {
             auto: progressBarFillAuto,
             autoSmart: progressBarFillSmart,
             contactSheet: progressBarFillContactSheet
        };

        const formatTime = (seconds) => {
            if (isNaN(seconds)) seconds = 0;
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            const ms = Math.floor((seconds % 1) * 100);
            return h > 0 ? `${h}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}` : `${m}:${s.toString().padStart(2, '0')}`;
        };
        const parseTimeString = (timeStr) => {
            try {
                if (!timeStr.includes(':')) {
                    const directSeconds = parseFloat(timeStr);
                    return isNaN(directSeconds) ? 0 : directSeconds;
                }
                const parts = timeStr.trim().split(':').map(parseFloat);
                if (parts.length === 2 && !parts.some(isNaN)) return parts[0] * 60 + parts[1];
                if (parts.length === 3 && !parts.some(isNaN)) return parts[0] * 3600 + parts[1] * 60 + parts[2];
                console.warn("Invalid time format:", timeStr);
                return 0;
            } catch { return 0; }
        };
        const gcd = (a, b) => b ? gcd(b, a % b) : a;
        const getCommonAspectRatio = (width, height) => {
            if (!width || !height) return '-';
            const rawRatio = width / height;
            const commonRatios = [{ ratio: 16/9, display: "16:9" },{ ratio: 4/3, display: "4:3" },{ ratio: 21/9, display: "21:9" },{ ratio: 2/1, display: "2:1" },{ ratio: 1.85/1, display: "1.85:1" },{ ratio: 2.35/1, display: "2.35:1" },{ ratio: 2.39/1, display: "2.39:1" },{ ratio: 2.40/1, display: "2.4:1" },{ ratio: 3/2, display: "3:2" },{ ratio: 5/4, display: "5:4" },{ ratio: 1/1, display: "1:1" },{ ratio: 9/16, display: "9:16" }];
            const TOLERANCE = 0.005;
            for (const { ratio, display } of commonRatios) { if (Math.abs(rawRatio - ratio) / ratio < TOLERANCE) return display; }
            const a = Math.round(width), b = Math.round(height);
            const divisor = gcd(a, b);
            return `${a / divisor}:${b / divisor}`;
        };
        const getStandardizedResolution = (width, height) => {
             if (!width || !height) return '-';
            const roundWidth = (w) => { if (w % 10 === 0) return w; const lastDigit = w % 10; return lastDigit <= 4 ? w - lastDigit : w + (10 - lastDigit); };
            return `${roundWidth(Math.round(width))}×${roundWidth(Math.round(height))}`;
        };
        const updateFileInfoDisplay = () => {
            if (!video?.duration || !isFinite(video.duration) || !video?.videoWidth || !video?.videoHeight || !resolutionValue || !lengthValue || !aspectRatioValue || !bitrateValue) {
                return;
            }
            currentVideoDuration = video.duration;
            let width = video.videoWidth, height = video.videoHeight;
            if (removeBarsEnabled && cropData && cropData.cropWidth > 0 && cropData.cropHeight > 0) { width = cropData.cropWidth; height = cropData.cropHeight; }
            lengthValue.textContent = formatTime(currentVideoDuration);
            resolutionValue.textContent = getStandardizedResolution(width, height);
            aspectRatioValue.textContent = getCommonAspectRatio(width, height);
            if (uploadedFile?.size > 0 && currentVideoDuration > 0) { const bitrateKbps = Math.round((uploadedFile.size * 8) / currentVideoDuration / 1000); bitrateValue.textContent = `${bitrateKbps} kbps`; } else { bitrateValue.textContent = "N/A"; }
        };
        const updateImageCount = () => { // Counting
            const screenshotCount = screenshotBlobs.length;
            const manualCount = manualScreenshotBlobs.length;
            let totalCount = 0;
             if (currentMode === 'manual') totalCount = manualCount;
             else if (currentMode === 'auto' || currentMode === 'autoSmart') totalCount = screenshotCount;
             else if (currentMode === 'contactSheet') totalCount = contactSheetPreviewData.filter(d => d?.blob).length;

            if (imageCountValue) {
                imageCountValue.textContent = totalCount;
                imageCountValue.classList.remove('interval-mode', 'smart-mode', 'manual-mode', 'contact-sheet-mode');
                if (currentMode === 'auto') imageCountValue.classList.add('interval-mode');
                else if (currentMode === 'autoSmart') imageCountValue.classList.add('smart-mode');
                else if (currentMode === 'manual') imageCountValue.classList.add('manual-mode');
                else if (currentMode === 'contactSheet') imageCountValue.classList.add('contact-sheet-mode');
            }
            const hasAutoOrSmartScreenshots = screenshotBlobs.length > 0;
            const hasManualScreenshots = manualScreenshotBlobs.length > 0;
            const hasContactSheetPreview = contactSheetPreviewData.some(d => d !== null);

            if(downloadAllButton) downloadAllButton.disabled = !hasAutoOrSmartScreenshots || processingActive;
            if(downloadAllSmartButton) downloadAllSmartButton.disabled = !hasAutoOrSmartScreenshots || processingActive;
            if(downloadManualButton) downloadManualButton.disabled = !hasManualScreenshots || processingActive;
            // Contact Sheet buttons depend on whether a blob exists *and* it's not marked as needing update
            const needsUpdate = processContactSheetButton?.classList.contains('needs-update');
            if(downloadContactSheetButton) downloadContactSheetButton.disabled = !contactSheetBlob || processingActive || needsUpdate;
            if(previewContactSheetButton) previewContactSheetButton.disabled = !contactSheetBlob || processingActive || needsUpdate;
            if(clearScreenshotsButton) clearScreenshotsButton.disabled = !hasAutoOrSmartScreenshots && !hasManualScreenshots && !hasContactSheetPreview && !contactSheetBlob;
        };
        const updateDropZoneUI = (isFileLoaded, filename) => {
          if(!dropZone || !selectFileButton || !$('loadedFileName')) return;
          const appContainer = $$('.app-container')[0];
          dropZone.classList.toggle('file-loaded', isFileLoaded);
          if (appContainer) appContainer.classList.toggle('file-loaded', isFileLoaded);
          if (isFileLoaded && filename) {
            $('loadedFileName').textContent = filename;
            selectFileButton.textContent = "Change File";
            selectFileButton.classList.add('file-selected');
            // Don't call updateFileInfoDisplay here, wait for 'loadedmetadata'
          } else {
            dropZone.classList.remove('file-loaded');
            if (appContainer) appContainer.classList.remove('file-loaded');
            dropZone.classList.remove('has-bg-image');
            const oldBgUrl = dropZone.dataset.bgUrl;
            if (oldBgUrl) URL.revokeObjectURL(oldBgUrl);
            dropZone.dataset.bgUrl = '';
            document.documentElement.style.setProperty('--dropzone-bg-image', 'none');
            $('loadedFileName').textContent = '';
            selectFileButton.textContent = "Change File";
            selectFileButton.classList.remove('file-selected');
            if(resolutionValue) resolutionValue.textContent = '-'; if(lengthValue) lengthValue.textContent = '-'; if(aspectRatioValue) aspectRatioValue.textContent = '-'; if(bitrateValue) bitrateValue.textContent = '-';
          }
        };
        const resetProcessingUI = (mode = 'all') => {
            processingActive = false; cancelExtractionRequested = false; currentSamplingProcess = null;
            if (verticalSeparatorElement) verticalSeparatorElement.classList.remove('loading', 'loading-smart', 'loading-contact-sheet');

            const resetBtn = (btn, text, startHandler, iconClass = null) => {
                 if (!btn) return;
                 // Enable button only if video source exists
                 btn.disabled = !video?.src;
                 // Clear existing content and add text/icon
                 btn.innerHTML = ''; // Clear first
                 
                 // All buttons now have icon after text
                 btn.appendChild(document.createTextNode(text));
                 if (iconClass) {
                     const icon = document.createElement('i');
                     icon.className = iconClass;
                     btn.appendChild(icon);
                 }

                 btn.classList.remove('cancel-active');
                 btn.classList.remove('needs-update');
                 btn.style.background = '';
                 btn.removeEventListener('click', handleCancelClick);

                 const existingListeners = btn._startHandlers || {};
                 Object.values(existingListeners).forEach(handler => btn.removeEventListener('click', handler));
                 if (startHandler) {
                     btn.addEventListener('click', startHandler);
                     btn._startHandlers = { [mode]: startHandler };
                 } else {
                    btn._startHandlers = {};
                 }
             };

            resetBtn(processButton, 'Extract Screenshots', startAutoExtraction, 'ri-scissors-line');
            resetBtn(processSmartButton, 'Extract Smart Shots', startSmartExtraction, 'ri-scissors-line');
            resetBtn(processContactSheetButton, 'Generate/Update Sheet', generateContactSheet);
            resetBtn(addManualButton, 'Cut Frame', addManualButton.onclick, 'ri-scissors-line');
            resetBtn(extractManualButton, 'Save Frame', extractManualButton.onclick, 'ri-download-line');

            if (addManualButton) addManualButton.disabled = !video?.src;
            if (extractManualButton) extractManualButton.disabled = !video?.src;

            Object.entries(progressBarElements).forEach(([key, bar]) => {
                if (bar && (mode === key || mode === 'all')) bar.style.display = 'none';
                if (progressBarFillElements[key]) progressBarFillElements[key].style.width = '0%';
            });

            // Reset contact sheet specific button titles etc.
            if(downloadContactSheetButton) {
                downloadContactSheetButton.title = '';
                downloadContactSheetButton.classList.remove('needs-update');
            }
            if(previewContactSheetButton) {
                previewContactSheetButton.title = '';
                previewContactSheetButton.classList.remove('needs-update');
            }

            updateImageCount(); // Recalculate download/clear button states
        };

        const setProcessingUI = (mode) => {
            processingActive = true; cancelExtractionRequested = false;
            [processButton, processSmartButton, processContactSheetButton, downloadAllButton, downloadAllSmartButton, downloadManualButton, downloadContactSheetButton, previewContactSheetButton, addManualButton, extractManualButton, clearScreenshotsButton].forEach(btn => {
                if (btn) btn.disabled = true;
            });

            let processBtn, progressBar, loadingClass, startHandler;
            if (mode === 'auto') { processBtn = processButton; progressBar = progressBarElements.auto; loadingClass = 'loading'; startHandler = startAutoExtraction; }
            else if (mode === 'autoSmart') { processBtn = processSmartButton; progressBar = progressBarElements.autoSmart; loadingClass = 'loading-smart'; startHandler = startSmartExtraction; }
            else if (mode === 'contactSheet') { processBtn = processContactSheetButton; progressBar = progressBarElements.contactSheet; loadingClass = 'loading-contact-sheet'; startHandler = generateContactSheet;}
            else return;

            if (verticalSeparatorElement && loadingClass) verticalSeparatorElement.classList.add(loadingClass);
            if (progressBar) progressBar.style.display = 'block';
            if (progressBarFillElements[mode]) progressBarFillElements[mode].style.width = '0%'; // Reset progress fill

             // Clear icon before setting text
             const icon = processBtn.querySelector('i, svg');
             if(icon) icon.remove();

            processBtn.textContent = 'Cancel Extraction';
            processBtn.classList.add('cancel-active');
            processBtn.classList.remove('needs-update');
            processBtn.style.background = '';

            const existingHandlers = processBtn._startHandlers || {};
             Object.values(existingHandlers).forEach(handler => processBtn.removeEventListener('click', handler));
             processBtn._startHandlers = {};

            processBtn.removeEventListener('click', handleCancelClick);
            processBtn.addEventListener('click', handleCancelClick);
            processBtn.disabled = false; // Enable the cancel button
        };

        const handleCancelClick = () => {
            cancelExtractionRequested = true;
            if (currentSamplingProcess?.cancel) currentSamplingProcess.cancel();
        };

        const computeHistogram = (imageData, sampleFactor = 4) => { const data = imageData.data; const hist = new Array(256).fill(0); let count = 0; const step = 4 * sampleFactor; for (let i = 0; i < data.length; i += step) { const gray = Math.round(0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]); hist[gray]++; count++; } return count === 0 ? hist : hist.map(val => val / count); };
        const histogramDifference = (hist1, hist2) => (!hist1 || !hist2 || hist1.length !== hist2.length) ? 1 : hist1.reduce((acc, val, i) => acc + Math.abs(val - hist2[i]), 0);
        const computePixelDiff = (data1, data2, sampleFactor = 4) => { let diff = 0; let count = 0; const step = 4 * sampleFactor; for (let i = 0; i < data1.length; i += step) { diff += Math.abs(data1[i] - data2[i]) + Math.abs(data1[i+1] - data2[i+1]) + Math.abs(data1[i+2] - data2[i+2]); count++; } return count > 0 ? (diff / (count * 3)) : 0; };

         const deleteScreenshot = (itemToDelete, blobArrayRef) => {
             const indexToRemove = blobArrayRef.indexOf(itemToDelete);
             if (indexToRemove > -1) {
                 const [removedItem] = blobArrayRef.splice(indexToRemove, 1);
                 if (removedItem?.blobUrl) URL.revokeObjectURL(removedItem.blobUrl);

                 const parentDiv = (blobArrayRef === manualScreenshotBlobs || blobArrayRef === screenshotBlobs) ? screenshotsDiv : null;
                 if (!parentDiv) return -1;

                 const containerToRemove = parentDiv.querySelector(`.screenshot-container[data-index="${indexToRemove}"]`);

                 if (containerToRemove) {
                     containerToRemove.remove();
                 } else {
                     console.warn("Could not find DOM element to remove for index:", indexToRemove, "Timestamp:", removedItem.timestamp);
                 }

                 // Re-index remaining DOM elements *after* removal
                 const remainingContainers = $$('.screenshot-container', parentDiv);
                 remainingContainers.forEach((container, newIndex) => {
                     container.dataset.index = newIndex.toString();
                 });

                 updateImageCount();
                 return indexToRemove;
             }
             return -1;
         };

        const createScreenshotContainer = (blob, timestamp = -1, blobArrayRef = screenshotBlobs) => {
            if(!screenshotsDiv || !blob) return null;
            const container = document.createElement('div');
            container.className = "screenshot-container";
            container.dataset.timestamp = timestamp.toString();
            const blobUrl = URL.createObjectURL(blob);

            const blobData = { blob, timestamp, blobUrl };
            let insertBeforeNode = null;
            if (blobArrayRef === manualScreenshotBlobs || blobArrayRef === screenshotBlobs) {
                for (let i = 0; i < blobArrayRef.length; i++) {
                    if (blobArrayRef[i].timestamp > timestamp) {
                        insertBeforeNode = screenshotsDiv.querySelector(`.screenshot-container[data-index="${i}"]`);
                        blobArrayRef.splice(i, 0, blobData);
                        break;
                    }
                }
            }
            if (!insertBeforeNode) {
                blobArrayRef.push(blobData);
            }

            const currentIndex = blobArrayRef.indexOf(blobData);
            container.dataset.index = currentIndex.toString();
            container.dataset.blobUrl = blobUrl;

            const img = document.createElement('img');
            img.className = "screenshot-img";
            img.src = blobUrl;

            const imgContainer = document.createElement('div');
            imgContainer.className = 'img-container';
            imgContainer.style.cursor = 'pointer';
            imgContainer.appendChild(img);
            container.appendChild(imgContainer);

            imgContainer.addEventListener('click', () => {
                 const indexFromData = parseInt(container.dataset.index);
                 let clickedItem = null;
                 let actualIndex = -1;

                 // Verify index and get item directly
                 if (!isNaN(indexFromData) && indexFromData >= 0 && indexFromData < blobArrayRef.length) {
                      clickedItem = blobArrayRef[indexFromData];
                      actualIndex = indexFromData;
                 }

                 if (actualIndex > -1 && clickedItem) {
                     openLightbox(clickedItem, blobArrayRef, actualIndex);
                 } else {
                    console.error("Could not determine item for lightbox. Index:", indexFromData, "Array length:", blobArrayRef.length);
                 }
             });


            if (timestamp >= 0) {
                const overlay = document.createElement('div');
                overlay.className = "screenshot-overlay";
                overlay.textContent = formatTime(timestamp);
                container.appendChild(overlay);
            }

            const delBtn = document.createElement('button');
            delBtn.className = "clear-delete-button lightbox-delete-btn";
            delBtn.title = "Remove this screenshot";
            delBtn.innerHTML = DELETE_ICON_SVG;
            delBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const currentItemIndex = blobArrayRef.indexOf(blobData);
                if (currentItemIndex > -1) {
                    deleteScreenshot(blobData, blobArrayRef);
                    if (screenshotLightbox?.classList.contains('active')) {
                        toggleModal(screenshotLightbox, false);
                    }
                } else {
                    console.error("Item to delete not found in array.");
                }
            });

            container.appendChild(delBtn);

             // Insert or append DOM node
            if (insertBeforeNode) {
                screenshotsDiv.insertBefore(container, insertBeforeNode);
            } else {
                screenshotsDiv.appendChild(container);
            }

            // Re-index *all* screenshot containers after insertion/append
            const allContainers = $$('.screenshot-container', screenshotsDiv);
            allContainers.forEach((cont, idx) => {
                cont.dataset.index = idx.toString();
            });


            return container;
        };


        const openLightbox = (item, blobArrayRef, currentIndex) => {
             const lightboxImage = $('lightboxImage');
             const lightboxTimestamp = $('lightboxTimestamp');
             const lightboxDownload = $('lightboxDownload');
             const prevBtn = $('lightboxPrevBtn');
             const nextBtn = $('lightboxNextBtn');
             const deleteBtnContainer = $('lightboxDeleteBtn').parentNode;
             let deleteBtn = $('lightboxDeleteBtn');
             const lightboxAdjustControls = $$('.lightbox-frame-adjust-controls')[0];
             const lightboxAdjustPrev = $('lightboxAdjustPrev');
             const lightboxAdjustNext = $('lightboxAdjustNext');
             const lightboxContent = $$('.info-box-content.screenshot-lightbox-content')[0];
             const frameNumberSpan = $('lightboxFrameNumber');

             if (!lightboxImage || !lightboxTimestamp || !lightboxDownload || !screenshotLightbox || !prevBtn || !nextBtn || !item || !deleteBtnContainer || !lightboxAdjustControls || !lightboxAdjustPrev || !lightboxAdjustNext || !lightboxContent || !frameNumberSpan) return;

             const arrayType = blobArrayRef === contactSheetPreviewData ? 'contactSheet' : (blobArrayRef === manualScreenshotBlobs ? 'manual' : 'auto');
             screenshotLightbox.dataset.currentIndex = currentIndex.toString();
             screenshotLightbox.dataset.arrayType = arrayType;
             screenshotLightbox.dataset.itemId = item.timestamp;

             // Show/hide contact sheet specific controls
             const isContactSheet = arrayType === 'contactSheet';
             lightboxAdjustControls.style.display = isContactSheet ? 'inline-flex' : 'none';
             lightboxContent.classList.toggle('contact-sheet-mode', isContactSheet);


             updateLightboxContent(currentIndex, blobArrayRef);
             toggleModal(screenshotLightbox, true);

             prevBtn.onclick = () => navigateLightbox(-1);
             nextBtn.onclick = () => navigateLightbox(1);

             // --- Delete Button Handling ---
             const newDeleteBtn = document.createElement('button');
             newDeleteBtn.id = 'lightboxDeleteBtn';
             newDeleteBtn.className = "clear-delete-button lightbox-delete-btn";
             newDeleteBtn.title = "Delete this screenshot (Hotkeys: 🡫, S)";
             newDeleteBtn.innerHTML = DELETE_ICON_SVG;
             // Hide if contact sheet
             if (isContactSheet) {
                 newDeleteBtn.style.display = 'none';
             }
             deleteBtnContainer.replaceChild(newDeleteBtn, deleteBtn);
             deleteBtn = newDeleteBtn;

             deleteBtn.onclick = () => {
                 const currentIdx = parseInt(screenshotLightbox.dataset.currentIndex || '0');
                 const currentArrayType = screenshotLightbox.dataset.arrayType || 'auto';
                 let currentBlobArrayRef;
                 if (currentArrayType === 'contactSheet') currentBlobArrayRef = contactSheetPreviewData;
                 else if (currentArrayType === 'manual') currentBlobArrayRef = manualScreenshotBlobs;
                 else currentBlobArrayRef = screenshotBlobs;

                 if (currentIdx >= 0 && currentIdx < currentBlobArrayRef.length) {
                     const itemToDelete = currentBlobArrayRef[currentIdx];
                     if (currentArrayType === 'contactSheet') {
                     } else {
                         const deletedIndex = deleteScreenshot(itemToDelete, currentBlobArrayRef);
                         if (deletedIndex > -1) {
                             if (currentBlobArrayRef.length === 0) {
                                 toggleModal(screenshotLightbox, false); return;
                             }
                             const newIndex = Math.min(deletedIndex, currentBlobArrayRef.length - 1);
                             screenshotLightbox.dataset.currentIndex = newIndex.toString();
                             updateLightboxContent(newIndex, currentBlobArrayRef);
                             updateNavButtonVisibility(newIndex, currentBlobArrayRef.length);
                         }
                     }
                 }
             };

             // --- Lightbox Frame Adjustment Handling ---
             if (isContactSheet) {
                lightboxAdjustPrev.onclick = () => adjustFrameTimeFromLightbox(-1);
                lightboxAdjustNext.onclick = () => adjustFrameTimeFromLightbox(1);
             }

             updateNavButtonVisibility(currentIndex, blobArrayRef.length);
         };

        const adjustFrameTimeFromLightbox = (offset) => {
            if (!screenshotLightbox.classList.contains('active')) return;
            const currentIndex = parseInt(screenshotLightbox.dataset.currentIndex || '-1');
            if (currentIndex >= 0 && screenshotLightbox.dataset.arrayType === 'contactSheet') {
                adjustFrameTime(currentIndex, offset);
                 // Lightbox image itself will be updated via handleFineTuneChange -> updatePreviewCell -> updateLightboxContent
            }
        };


         const updateLightboxContent = (index, blobArrayRef) => {
             const lightboxImage = $('lightboxImage');
             const lightboxTimestamp = $('lightboxTimestamp');
             const lightboxDownload = $('lightboxDownload');
             const frameNumberSpan = $('lightboxFrameNumber');
             const isContactSheet = blobArrayRef === contactSheetPreviewData;

             if (index >= 0 && index < blobArrayRef.length && lightboxImage && lightboxTimestamp && lightboxDownload && frameNumberSpan) {
                 const item = blobArrayRef[index];
                 // Handle case where item might be null (e.g., deleted contact sheet cell)
                 if (!item || !item.blobUrl) {
                     lightboxImage.src = ''; // Clear image
                     lightboxTimestamp.textContent = '-';
                     lightboxDownload.href = '#';
                     frameNumberSpan.textContent = ''; // Clear frame number
                     return;
                 }
                 const newBlobUrl = item.blobUrl;

                 lightboxImage.src = newBlobUrl;
                 lightboxImage.dataset.blobUrl = newBlobUrl;

                 lightboxTimestamp.textContent = item.timestamp >= 0 ? formatTime(item.timestamp) : '';
                 frameNumberSpan.textContent = isContactSheet ? `Frame ${index + 1}` : '';

                 const extension = item.blob?.type ? (item.blob.type === 'image/jpeg' ? 'jpg' : item.blob.type.split('/')[1]) : 'png';
                 const timeSuffix = (item.timestamp !== undefined && item.timestamp >= 0) ? `_${formatTime(item.timestamp).replace(':','-')}` : `_${index + 1}`;
                 const filename = `screenshot${timeSuffix}.${extension}`;
                 lightboxDownload.href = newBlobUrl;
                 lightboxDownload.download = filename;
             }
         };

        const navigateLightbox = (direction) => {
            if (!screenshotLightbox) return;
            const currentIndex = parseInt(screenshotLightbox.dataset.currentIndex || '0');
            const arrayType = screenshotLightbox.dataset.arrayType || 'auto';
            let blobArrayRef;
            if (arrayType === 'contactSheet') blobArrayRef = contactSheetPreviewData;
            else if (arrayType === 'manual') blobArrayRef = manualScreenshotBlobs;
            else blobArrayRef = screenshotBlobs;

            let newIndex = currentIndex + direction;
            while (arrayType === 'contactSheet' && newIndex >= 0 && newIndex < blobArrayRef.length && !blobArrayRef[newIndex]) {
                newIndex += direction;
            }

            if (newIndex >= 0 && newIndex < blobArrayRef.length) {
                screenshotLightbox.dataset.currentIndex = newIndex.toString();
                updateLightboxContent(newIndex, blobArrayRef);
                updateNavButtonVisibility(newIndex, blobArrayRef.length);
            }
        };

        const updateNavButtonVisibility = (currentIndex, totalItems) => {
            const prevBtn = $('lightboxPrevBtn');
            const nextBtn = $('lightboxNextBtn');
            if (prevBtn && nextBtn) { prevBtn.disabled = currentIndex <= 0; nextBtn.disabled = currentIndex >= totalItems - 1; }
        };

        const getFileExtensionFromType = (type) => (!type || type === 'image/png') ? 'png' : (type === 'image/jpeg' ? 'jpg' : type.split('/')[1] || 'png');

        // Global controls for output format
        const getCurrentFormatSettings = () => {
             const selectedFormat = outputFormatSelect.value || 'png';
             let quality = 1.0;
             if (selectedFormat === 'jpeg') {
                quality = parseFloat(jpegQualityGlobal?.value || 90) / 100;
             } else if (selectedFormat === 'webp') {
                quality = parseFloat(webpQualityGlobal?.value || 90) / 100;
             }
             return { type: `image/${selectedFormat}`, quality };
         };

         const downloadBlobsAsZip = (blobDataArray, baseFilename = "screenshots") => {
             if (!blobDataArray || blobDataArray.length === 0 || !window.JSZip) { alert(blobDataArray?.length === 0 ? "No screenshots to download." : "Error: JSZip library not loaded."); return; }
             const zip = new JSZip();
             const { type } = getCurrentFormatSettings();
             const extension = getFileExtensionFromType(type);

             blobDataArray.forEach((item, index) => {
                 if (!item || !item.blob) return;
                 const timeSuffix = (item.timestamp !== undefined && item.timestamp >= 0) ? `_${formatTime(item.timestamp).replace(':','-')}` : `_${index + 1}`;
                 const filename = `${baseFilename}${timeSuffix}.${extension}`;
                 zip.file(filename, item.blob);
             });
             zip.generateAsync({ type: "blob" }).then((content) => {
                 const url = URL.createObjectURL(content);
                 const tempLink = document.createElement('a');
                 tempLink.href = url;
                 tempLink.download = `${baseFilename}.zip`;
                 document.body.appendChild(tempLink);
                 tempLink.click();
                 document.body.removeChild(tempLink);
                 URL.revokeObjectURL(url);
             }).catch(err => { console.error("Error generating ZIP:", err); alert("Error creating ZIP file: " + err.message); });
         };

        const handleFileLoad = (file) => {
            if (!video || !manualVideo || !contactSheetVideo || !file) return;
            uploadedFile = file;
            const fileURL = URL.createObjectURL(file);

             if (video.src && video.src.startsWith('blob:')) URL.revokeObjectURL(video.src);
             if (manualVideo.src && manualVideo.src.startsWith('blob:')) URL.revokeObjectURL(manualVideo.src);
             if (contactSheetVideo.src && contactSheetVideo.src.startsWith('blob:')) URL.revokeObjectURL(contactSheetVideo.src);

            video.src = fileURL;
            manualVideo.src = fileURL;
            contactSheetVideo.src = fileURL;
            updateDropZoneUI(true, file.name);
            resetUIOnNewVideo(); // Reset counts, buttons, previews

            const onMetadataLoaded = () => {
                updateFileInfoDisplay();
                updateDropZoneThumbnail(); // Attempt thumbnail after metadata
                resetProcessingUI('all'); // Enable relevant buttons now that we have duration etc.
                // Initial setup for contact sheet inputs based on new duration
                 if (currentMode === 'contactSheet') {
                    const activeGridSizeTab = $$('.grid-size-tab.active')[0];
                    const rows = parseInt(activeGridSizeTab?.getAttribute('data-rows') || 4);
                    const cols = parseInt(activeGridSizeTab?.getAttribute('data-cols') || 5);
                     if (updateContactSheetControlsVisibility(rows, cols)) {
                        generateTimeInputs(rows, cols);
                     }
                 }
            };

            if (video.readyState >= video.HAVE_METADATA) {
                setTimeout(onMetadataLoaded, 100); // Give it a moment :D
            } else {
                video.addEventListener('loadedmetadata', onMetadataLoaded, { once: true });
            }

            video.addEventListener('error', (e) => {
                 console.error("Video loading error:", e);
                 alert(`Error loading video: ${file.name}. It might be corrupted or in an unsupported format.`);
                 updateDropZoneUI(false, null);
                 resetUIOnNewVideo();
            });

            if (removeBarsToggle?.checked) {
                video.addEventListener('canplay', () => {
                     setTimeout(() => {
                         detectCropBoundariesMulti(() => {
                             updateDropZoneThumbnail();
                             updateFileInfoDisplay();
                         });
                     }, 200);
                }, { once: true });
            }
        };
        const resetUIOnNewVideo = () => {
             $$('.screenshot-container', screenshotsDiv).forEach(container => {
                 if (container.dataset.blobUrl) URL.revokeObjectURL(container.dataset.blobUrl);
             });
            if(screenshotsDiv) screenshotsDiv.innerHTML = '';
            screenshotBlobs = []; manualScreenshotBlobs = []; contactSheetBlob = null; cropData = null; currentVideoDuration = 0;
            clearContactSheetPreview(true);
            Object.keys(gridCache).forEach(key => gridCache[key] = { data: null, blob: null, completed: false });
            $$('.grid-size-tab').forEach(tab => tab.classList.remove('completed'));
            updateImageCount(); resetProcessingUI('all'); // Reset buttons (will be disabled until src loads)
            if(resolutionValue) resolutionValue.textContent = '-'; if(lengthValue) lengthValue.textContent = '-'; if(aspectRatioValue) aspectRatioValue.textContent = '-'; if(bitrateValue) bitrateValue.textContent = '-';

        };

        const sampleVideoFrames = (options) => {
             const { videoElement = video, sampleTimestamps, outputType, useCrop, processFrameCallback, onCompleteCallback, onProgressCallback, onErrorCallback } = options;
             let localCancelRequested = false;
             let currentSampleIndex = 0;
             const collectedData = new Array(sampleTimestamps.length).fill(null);
             let frameRequestHandle = null;

             if (!videoElement?.src || videoElement.readyState < videoElement.HAVE_METADATA || videoElement.duration <= 0 || !sampleTimestamps?.length) {
                 const error = new Error(!videoElement?.src ? "Video not loaded." : !sampleTimestamps?.length ? "No timestamps provided." : "Video not ready for sampling.");
                 console.error("sampleVideoFrames error:", error.message);
                 if (onErrorCallback) onErrorCallback(error); else console.error(error);
                 if (onCompleteCallback) onCompleteCallback(collectedData);
                 return { cancel: () => { localCancelRequested = true; } };
             }

             const totalSamples = sampleTimestamps.length;
             const checkCancelled = () => localCancelRequested || cancelExtractionRequested;

             const processNext = () => {
                 if (checkCancelled()) { console.log("Sampling cancelled."); if (onCompleteCallback) onCompleteCallback(collectedData); return; }
                 if (currentSampleIndex >= totalSamples) { console.log("Sampling complete."); if (onCompleteCallback) onCompleteCallback(collectedData); return; }

                 const timestamp = sampleTimestamps[currentSampleIndex];
                 // Use the currentSampleIndex as the original index for this sampling run
                 const originalIndex = currentSampleIndex;

                 if (onProgressCallback) onProgressCallback(Math.min(Math.round((currentSampleIndex / totalSamples) * 100), 100));

                 captureFrameAtTime(timestamp, (blob) => {
                     if (checkCancelled()) { if (onCompleteCallback) onCompleteCallback(collectedData); return; }

                     if (!blob) {
                         console.warn(`Failed to capture frame at ${timestamp.toFixed(2)}s (Index: ${originalIndex})`);
                     } else {
                         try {
                             processFrameCallback(blob, timestamp, originalIndex); // Pass original index
                             collectedData[currentSampleIndex] = { blob, timestamp };
                         } catch (processError) {
                             console.error(`Error in processFrameCallback at ${timestamp.toFixed(2)}s (Index: ${originalIndex}):`, processError);
                             if (onErrorCallback) onErrorCallback(processError);
                         }
                     }

                     currentSampleIndex++;
                     if (!checkCancelled()) {
                       frameRequestHandle = requestAnimationFrame(processNext);
                     } else {
                        if (onCompleteCallback) onCompleteCallback(collectedData);
                     }
                 }, { videoElement, useCrop, skipProgress: true });
             };

             // Add a small delay before starting the first frame, especially for contact sheet
             frameRequestHandle = setTimeout(() => {
                 if (!checkCancelled()) requestAnimationFrame(processNext);
             }, 150); // Delay before starting the rAF loop


             return { cancel: () => {
                 localCancelRequested = true;
                 if (frameRequestHandle) {
                    cancelAnimationFrame(frameRequestHandle);
                    clearTimeout(frameRequestHandle); // Clear timeout too if it hasn't fired
                    frameRequestHandle = null;
                 }
                 resetProcessingUI(currentMode); // Reset UI immediately on cancel
             }};
         };

         const captureFrameAtTime = (time, callback, options = {}) => {
            const { videoElement = video, useCrop = removeBarsEnabled, skipProgress = false } = options;
            if (!videoElement || !videoElement.src || videoElement.readyState < 1 || !canvas) { callback(null); return; }

            let seekTimeout;
            let onSeeked, onError;

            const cleanupListeners = () => {
                clearTimeout(seekTimeout);
                videoElement.removeEventListener('seeked', onSeeked);
                videoElement.removeEventListener('error', onError);
            };

            const drawLogic = () => {
                 try {
                     const ctx = canvas.getContext('2d', { willReadFrequently: true });
                     if (!ctx) throw new Error('Canvas context not available');
                     const effectiveCropData = useCrop && cropData ? cropData : { cropX: 0, cropY: 0, cropWidth: videoElement.videoWidth, cropHeight: videoElement.videoHeight };
                     if (effectiveCropData.cropWidth <= 0 || effectiveCropData.cropHeight <= 0) throw new Error(`Invalid effective crop dimensions: ${effectiveCropData.cropWidth}x${effectiveCropData.cropHeight}`);

                     canvas.width = effectiveCropData.cropWidth; canvas.height = effectiveCropData.cropHeight;
                     ctx.drawImage(videoElement, effectiveCropData.cropX, effectiveCropData.cropY, effectiveCropData.cropWidth, effectiveCropData.cropHeight, 0, 0, canvas.width, canvas.height);

                     const { type, quality } = getCurrentFormatSettings();
                     canvas.toBlob((blob) => callback(blob), type, quality);
                 } catch (error) {
                     console.error(`[captureFrameAtTime] Draw error at ${time.toFixed(2)}s:`, error);
                     callback(null);
                 }
             };

            seekTimeout = setTimeout(() => {
                console.warn(`Seek timeout for time ${time.toFixed(2)}s`);
                cleanupListeners();
                callback(null);
            }, 7000);

            onSeeked = () => {
                cleanupListeners();
                setTimeout(drawLogic, 50); // Delay draw after seek completes
            };

            onError = (e) => {
                console.error(`[captureFrameAtTime] Video Error at ${time.toFixed(2)}s:`, e);
                cleanupListeners();
                callback(null);
            };

            videoElement.addEventListener('seeked', onSeeked, { once: true });
            videoElement.addEventListener('error', onError, { once: true });

            try {
                 const duration = videoElement.duration;
                 if (!duration || !isFinite(duration)) {
                     throw new Error("Video duration is invalid or not available.");
                 }
                 const targetTime = Math.max(0, Math.min(time, duration ? duration - 0.01 : 0));

                 // Always set currentTime, rely on 'seeked' event or timeout
                 if (videoElement.currentTime.toFixed(2) !== targetTime.toFixed(2)) { // Use fixed precision for comparison
                    videoElement.currentTime = targetTime;
                 } else {
                    // Already at the right time, might not trigger 'seeked'
                    cleanupListeners();
                    // console.log(`[captureFrameAtTime] Already at time ${targetTime.toFixed(2)}, triggering draw manually.`);
                    setTimeout(drawLogic, 60); // Manually trigger draw logic slightly later
                 }

            } catch (error) {
                console.error(`[captureFrameAtTime] Seek Error setting time to ${time.toFixed(2)}:`, error);
                cleanupListeners();
                callback(null);
            }
        };


        const detectCropBoundariesMulti = (callback) => {
            if (!video?.src || video.readyState < 2 || !video.duration || !isFinite(video.duration) || video.videoWidth === 0 || video.videoHeight === 0) {
                console.warn("Video not ready for crop detection.");
                cropData = { cropX: 0, cropY: 0, cropWidth: video.videoWidth || 1, cropHeight: video.videoHeight || 1 };
                if (callback) callback();
                return;
            }
            const sampleTimes = [0.3, 0.5, 0.7].map(p => Math.min(Math.max(p * video.duration, 0.1), video.duration - 0.1));
            let sampleResults = [];
            let currentSample = 0;

            function analyzeFrame(callbackFrame) {
                const tempCanvas = document.createElement('canvas'); tempCanvas.width = video.videoWidth; tempCanvas.height = video.videoHeight;
                const ctx = tempCanvas.getContext("2d"); if(!ctx) { console.error("Failed to get context for crop analysis"); callbackFrame({ topCrop: 0, bottomCrop: video.videoHeight - 1, leftCrop: 0, rightCrop: video.videoWidth - 1 }); return; }
                try {
                    ctx.drawImage(video, 0, 0, video.videoWidth, video.videoHeight);
                    const imageData = ctx.getImageData(0, 0, video.videoWidth, video.videoHeight); const data = imageData.data, width = video.videoWidth, height = video.videoHeight;
                    const pixelThreshold = 15, lineRatioThreshold = 0.98; let topCrop = 0, bottomCrop = height - 1, leftCrop = 0, rightCrop = width - 1;

                    const isBlackRow = (y) => { let blackPxCount = 0; for (let x = 0; x < width; x++) { const i = (y * width + x) * 4; if (data[i] < pixelThreshold && data[i + 1] < pixelThreshold && data[i + 2] < pixelThreshold) blackPxCount++; } return blackPxCount / width >= lineRatioThreshold; };
                    const isBlackCol = (x, yStart, yEnd) => { let blackPxCount = 0; for (let y = yStart; y <= yEnd; y++) { const i = (y * width + x) * 4; if (data[i] < pixelThreshold && data[i + 1] < pixelThreshold && data[i + 2] < pixelThreshold) blackPxCount++; } return blackPxCount / (yEnd - yStart + 1) >= lineRatioThreshold; };

                    for (let y = 0; y < height / 2; y++) { if (!isBlackRow(y)) { topCrop = y; break; } topCrop = y; }
                    for (let y = height - 1; y >= height / 2; y--) { if (!isBlackRow(y)) { bottomCrop = y; break; } bottomCrop = y; }
                    for (let x = 0; x < width / 2; x++) { if (!isBlackCol(x, topCrop, bottomCrop)) { leftCrop = x; break; } leftCrop = x; }
                    for (let x = width - 1; x >= width / 2; x--) { if (!isBlackCol(x, topCrop, bottomCrop)) { rightCrop = x; break; } rightCrop = x; }
                    callbackFrame({ topCrop, bottomCrop, leftCrop, rightCrop });
                } catch (e) {
                    console.error("Error analyzing frame for crop:", e);
                    callbackFrame({ topCrop: 0, bottomCrop: video.videoHeight - 1, leftCrop: 0, rightCrop: video.videoWidth - 1 });
                }
            }

            function median(arr) { const sorted = arr.slice().sort((a, b) => a - b); return sorted[Math.floor(sorted.length / 2)]; }

            function processNextSample() {
                if (currentSample >= sampleTimes.length) {
                    if (sampleResults.length > 0) {
                        const finalTop = median(sampleResults.map(r => r.topCrop)); const finalBottom = median(sampleResults.map(r => r.bottomCrop));
                        const finalLeft = median(sampleResults.map(r => r.leftCrop)); const finalRight = median(sampleResults.map(r => r.rightCrop));
                        cropData = { cropX: finalLeft, cropY: finalTop, cropWidth: Math.max(1, finalRight - finalLeft + 1), cropHeight: Math.max(1, finalBottom - finalTop + 1) };
                    } else {
                         cropData = { cropX: 0, cropY: 0, cropWidth: video.videoWidth || 1, cropHeight: video.videoHeight || 1 };
                    }
                    console.log("Detected black bars crop data:", cropData); if (callback) callback(); return;
                }
                const sampleTime = sampleTimes[currentSample];
                let seekedHandler, errorHandler;

                const cleanupSampleListeners = () => {
                    video.removeEventListener("seeked", seekedHandler);
                    video.removeEventListener("error", errorHandler);
                };

                seekedHandler = () => {
                    cleanupSampleListeners();
                    setTimeout(() => analyzeFrame(boundaries => { sampleResults.push(boundaries); currentSample++; processNextSample(); }), 50);
                };
                errorHandler = (e) => {
                    console.error("Seek error during crop detection sample:", e);
                    cleanupSampleListeners();
                    sampleResults.push({ topCrop: 0, bottomCrop: video.videoHeight - 1, leftCrop: 0, rightCrop: video.videoWidth - 1 }); // Assume no crop on error
                    currentSample++;
                    processNextSample();
                };

                video.addEventListener("seeked", seekedHandler, { once: true });
                video.addEventListener("error", errorHandler, { once: true });
                try { if (Math.abs(video.currentTime - sampleTime) > 0.1) video.currentTime = sampleTime; else { cleanupSampleListeners(); seekedHandler(); } } // Trigger manually if close
                catch (err) { errorHandler(err); }
            }
            processNextSample();
        };

        const updateSliderBackground = (slider) => {
            if (!slider) return;
            const val = parseFloat(slider.value);
            const min = parseFloat(slider.min || 0);
            const max = parseFloat(slider.max || 100);
            const pct = max > min ? ((val - min) * 100) / (max - min) : 0;
            let color = 'var(--accent-interval)';
             // Determine color based on the slider ID for global sliders
             if (slider.id === 'jpegQualityGlobal' || slider.id === 'webpQualityGlobal') {
                 color = 'var(--accent-primary)'; // Use a neutral or primary accent for global settings
             }
             else if (slider.closest('#autoSmartMode')) { color = 'var(--accent-secondary)'; }
             else if (slider.closest('#manualMode')) { color = 'var(--accent-primary)'; }
             else if (slider.closest('#contactSheetMode')) { color = 'var(--accent-tertiary)'; }
            slider.style.background = `linear-gradient(to right, ${color} 0%, ${color} ${pct}%, var(--bg-tertiary) ${pct}%, var(--bg-tertiary) 100%)`;
        };

        const setupSlider = (slider, displaySpan, suffix) => {
            if (!slider || !displaySpan) return;
            const updateUI = () => { displaySpan.textContent = slider.value + suffix; updateSliderBackground(slider); };
            slider.addEventListener('input', updateUI); updateUI();
        };

        const initGlobalFormatControls = () => {
             const updateVisibility = () => {
                const selectedFormat = outputFormatSelect.value;
                jpegQualityGlobalRow.style.display = (selectedFormat === 'jpeg') ? 'flex' : 'none';
                webpQualityGlobalRow.style.display = (selectedFormat === 'webp') ? 'flex' : 'none';
                if (selectedFormat === 'jpeg') updateSliderBackground(jpegQualityGlobal);
                if (selectedFormat === 'webp') updateSliderBackground(webpQualityGlobal);
             };

             outputFormatSelect.addEventListener('change', updateVisibility);
             setupSlider(jpegQualityGlobal, jpegQualityGlobalValue, '%');
             setupSlider(webpQualityGlobal, webpQualityGlobalValue, '%');
             updateVisibility(); // Initial call
        };

        const updateDropZoneThumbnail = () => {
            if (!video?.src || video.readyState < 1 || !dropZone || !video.duration || !isFinite(video.duration)) return;
            const previewTime = Math.min(Math.max(video.duration * 0.25, 0.1), video.duration - 0.01);
            captureFrameAtTime(previewTime, (blob) => {
                if (!blob || !dropZone) return;
                const blobUrl = URL.createObjectURL(blob);
                const oldBgUrl = dropZone.dataset.bgUrl;
                if (oldBgUrl) URL.revokeObjectURL(oldBgUrl);
                dropZone.dataset.bgUrl = blobUrl;
                document.documentElement.style.setProperty('--dropzone-bg-image', `url(${blobUrl})`);
                dropZone.classList.add('has-bg-image');
            }, { videoElement: video });
        };

        const initContactSheetPreview = (rows = 4, cols = 5) => {
            if (!contactSheetPreviewElement) return;
            contactSheetPreviewElement.innerHTML = '';
            document.documentElement.style.setProperty('--grid-rows', rows);
            document.documentElement.style.setProperty('--grid-cols', cols);
            contactSheetPreviewData = new Array(rows * cols).fill(null);

            for (let i = 0; i < rows * cols; i++) {
                const cell = document.createElement('div');
                cell.className = 'grid-cell'; cell.dataset.index = i;
                const img = document.createElement('img'); img.alt = `Frame ${i+1}`; cell.appendChild(img);
                // Add click listener for lightbox
                 cell.addEventListener('click', (e) => {
                     if (!e.target.closest('.frame-adjust-btn') && cell.classList.contains('filled')) {
                        const index = parseInt(cell.dataset.index);
                        if (!isNaN(index) && index >= 0 && index < contactSheetPreviewData.length && contactSheetPreviewData[index]) {
                             openLightbox(contactSheetPreviewData[index], contactSheetPreviewData, index);
                        }
                     }
                 });

                const btnContainer = document.createElement('div'); btnContainer.className = 'frame-adjust-buttons';
                const createAdjustBtn = (text, offset, title) => {
                    const btn = document.createElement('div'); btn.className = 'frame-adjust-btn';
                    // Add icon based on text
                    if (text === '-') btn.innerHTML = `-<i class="ri-scissors-line icon-flipped"></i>`; // Flipped icon
                    else if (text === '+') btn.innerHTML = `<i class="ri-scissors-line"></i>+`;
                    else btn.textContent = text;
                    btn.title = title;
                    btn.addEventListener('click', (e) => { e.stopPropagation(); adjustFrameTime(i, offset); }); return btn;
                };
                btnContainer.appendChild(createAdjustBtn('-', -1, 'Cut forward by 1s'));
                btnContainer.appendChild(createAdjustBtn('+', 1, 'Cut backward by 1s'));
                cell.appendChild(btnContainer);

                cell.addEventListener('mouseenter', () => {
                    cell.classList.add('highlight'); // Highlight cell on hover
                    const timeInputCont = contactSheetControlsElement?.querySelector(`.time-input-container[data-index="${i}"]`);
                    if (timeInputCont) timeInputCont.classList.add('highlight');
                });
                cell.addEventListener('mouseleave', () => {
                    cell.classList.remove('highlight'); // Remove cell highlight
                     const timeInputCont = contactSheetControlsElement?.querySelector(`.time-input-container[data-index="${i}"]`);
                    if (timeInputCont) timeInputCont.classList.remove('highlight');
                });

                contactSheetPreviewElement.appendChild(cell);
            }
        };

        const adjustFrameTime = debounce((index, offsetSeconds) => {
            const timeInput = $(`timeInput_${index}`); if (!timeInput) return;
            const currentValue = parseFloat(timeInput.value); if (isNaN(currentValue)) return;
            const newValue = Math.max(0, Math.min(currentValue + offsetSeconds, currentVideoDuration ? currentVideoDuration - 0.01 : 0));
            updateTimeValue(index, newValue, true);
        }, 150);

        const updateTimeValue = (index, seconds, triggerFrameUpdate = false) => {
            if (isNaN(seconds)) seconds = 0;
            const clampedTime = Math.min(Math.max(0, seconds), currentVideoDuration ? currentVideoDuration - 0.01 : 0);
            const numberInput = $(`timeInput_${index}`);
            const formatted = $(`timeFormatted_${index}`);
            if (numberInput) numberInput.value = clampedTime.toFixed(2);
            if (formatted) formatted.value = formatTime(clampedTime);
            if (triggerFrameUpdate) handleFineTuneChange(index, clampedTime);
        };

        // This function now ONLY updates the preview cell and marks the sheet as needing regeneration
        const handleFineTuneChange = debounce((index, newTime) => {
            if (isNaN(newTime) || newTime < 0 || !video?.src || video.readyState < 1) return;
             captureFrameAtTime(newTime, (blob) => {
                 if (blob) {
                     updatePreviewCell(index, blob, newTime); // Update visual cell and data array

                     // Mark sheet as needing regeneration
                     contactSheetBlob = null; // Invalidate the final blob
                     const activeTab = $$('.grid-size-tab.active')[0];
                     if (activeTab) activeTab.classList.remove('completed');
                     const { rows, cols } = activeTab ? activeTab.dataset : { rows: 4, cols: 5 };
                     const cacheKey = `${cols}x${rows}`;
                     if (gridCache[cacheKey]) {
                         gridCache[cacheKey].completed = false;
                         gridCache[cacheKey].blob = null; // Also clear blob from cache
                     }

                     // Update button states/styles
                     if (processContactSheetButton) {
                         processContactSheetButton.textContent = 'Update Sheet Image';
                         processContactSheetButton.classList.add('needs-update');
                         // Use correct tertiary gradient for update indicator
                         processContactSheetButton.style.background = 'var(--gradient-tertiary)';
                     }
                     if (previewContactSheetButton) {
                         previewContactSheetButton.disabled = true; // Disable until updated
                         previewContactSheetButton.classList.add('needs-update'); // Add class for potential styling
                         previewContactSheetButton.title = "Sheet has been modified. Click 'Update Sheet Image'.";
                     }
                     if (downloadContactSheetButton) {
                         downloadContactSheetButton.disabled = true; // Disable until updated
                         downloadContactSheetButton.classList.add('needs-update'); // Add class for potential styling
                         downloadContactSheetButton.title = "Sheet has been modified. Click 'Update Sheet Image'.";
                     }

                     // If lightbox is open for this specific index, update it too
                     if (screenshotLightbox.classList.contains('active') && parseInt(screenshotLightbox.dataset.currentIndex) === index) {
                        updateLightboxContent(index, contactSheetPreviewData);
                     }

                     updateImageCount(); // Ensure overall counts/states are refreshed

                 } else { console.warn(`Fine-tuning failed for cell ${index} at ${newTime.toFixed(2)}s`); }
             });
        }, 300);


        const clearContactSheetPreview = (clearInputs = true) => {
            contactSheetPreviewData.forEach(data => { if (data?.blobUrl) URL.revokeObjectURL(data.blobUrl); });
            const gridCells = $$('.grid-cell', contactSheetPreviewElement);
            // Ensure preview data array matches current grid size before resetting
            contactSheetPreviewData = new Array(gridCells.length).fill(null);
            gridCells.forEach(cell => {
                 cell.classList.remove('filled'); cell.style.cursor = 'default';
                 const img = cell.querySelector('img'); if (img) img.src = '';
                 const overlay = cell.querySelector('.screenshot-overlay'); if (overlay) overlay.remove();
                 delete cell.dataset.blobUrl; delete cell.dataset.timestamp;
            });
            if (clearInputs) {
                 $$('.time-input', contactSheetControlsElement).forEach(input => input.value = '0.00');
                 $$('.time-formatted', contactSheetControlsElement).forEach(input => input.value = '0:00');
            }
            if (downloadContactSheetButton) {
                 downloadContactSheetButton.disabled = true;
                 downloadContactSheetButton.classList.remove('needs-update');
                 downloadContactSheetButton.title = '';
            }
            if (previewContactSheetButton) {
                previewContactSheetButton.disabled = true;
                previewContactSheetButton.classList.remove('needs-update');
                previewContactSheetButton.title = '';
            }
             if (processContactSheetButton) {
                 processContactSheetButton.classList.remove('needs-update');
                 processContactSheetButton.style.background = ''; // Reset style
                 processContactSheetButton.textContent = 'Generate/Update Sheet'; // Reset text
             }
        };

        const updatePreviewCell = (index, blob, timestamp) => {
            const cell = contactSheetPreviewElement?.querySelector(`.grid-cell[data-index="${index}"]`);
            if (!cell || !blob || index < 0 || index >= contactSheetPreviewData.length) return; // Add index bounds check

            const existingData = contactSheetPreviewData[index];
            if (existingData?.blobUrl) URL.revokeObjectURL(existingData.blobUrl);

            const blobUrl = URL.createObjectURL(blob);
            const img = cell.querySelector('img'); if (img) img.src = blobUrl;
            cell.classList.add('filled'); cell.dataset.blobUrl = blobUrl; cell.dataset.timestamp = String(timestamp); cell.style.cursor = 'pointer';

            let overlay = cell.querySelector('.screenshot-overlay');
            if (!overlay) { overlay = document.createElement('div'); overlay.className = 'screenshot-overlay'; cell.appendChild(overlay); }
            overlay.textContent = formatTime(timestamp);

            contactSheetPreviewData[index] = { blob, timestamp, blobUrl };
             // Don't call updateImageCount here
         };

         const generateTimeInputs = (rows = 4, cols = 5) => {
              if (!contactSheetControlsElement) return;
              contactSheetControlsElement.innerHTML = '';
              contactSheetControlsElement.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
              const numCells = rows * cols;

              // Show/hide based on grid size
              const isLargeGrid = rows > 6 || cols > 6;
              contactSheetControlsElement.style.display = isLargeGrid ? 'none' : 'grid';
              largeGridDisclaimer.style.display = isLargeGrid ? 'block' : 'none';

              if (isLargeGrid) return; // Don't generate inputs if hidden

              for (let i = 0; i < numCells; i++) {
                  const container = document.createElement('div'); container.className = 'time-input-container'; container.dataset.index = i;
                  const wrapper = document.createElement('div'); wrapper.className = 'time-input-wrapper';

                  // Use data from array IF it exists for this index, otherwise calculate default if duration known
                  let initialTimestamp = contactSheetPreviewData[i]?.timestamp;
                  if (initialTimestamp === undefined || initialTimestamp === null || initialTimestamp <= 0) { // Also check if 0
                      if (currentVideoDuration > 0) {
                         const startPercent = 0.1; const endPercent = 0.9;
                         const step = numCells > 1 ? (endPercent - startPercent) / (numCells - 1) : 0;
                         const percent = startPercent + (i * step);
                         initialTimestamp = Math.max(0.01, Math.min(percent * currentVideoDuration, currentVideoDuration - 0.01));
                      } else {
                         initialTimestamp = 0; // Default if duration unknown
                      }
                  }


                  const timeInput = document.createElement('input'); timeInput.type = 'number'; timeInput.className = 'time-input'; timeInput.id = `timeInput_${i}`;
                  timeInput.value = initialTimestamp.toFixed(2); timeInput.min = '0'; timeInput.max = currentVideoDuration ? currentVideoDuration.toFixed(2) : '999'; timeInput.step = '0.01'; timeInput.dataset.index = i;

                  const timeFormatted = document.createElement('input'); timeFormatted.type = 'text'; timeFormatted.className = 'time-formatted'; timeFormatted.id = `timeFormatted_${i}`;
                  timeFormatted.value = formatTime(initialTimestamp); timeFormatted.dataset.index = i; timeFormatted.placeholder = "0:00"; timeFormatted.setAttribute('draggable', 'false');

                  timeFormatted.addEventListener('change', (e) => { updateTimeValue(parseInt(e.target.dataset.index), parseTimeString(e.target.value), true); });
                  timeFormatted.addEventListener('focus', (e) => e.target.select());

                  let isDragging = false; let startY = 0; let startValue = 0; let sensitivity = 0.05;
                  timeFormatted.addEventListener('mousedown', (e) => {
                      isDragging = true; startY = e.clientY; startValue = parseFloat(timeInput.value);
                      document.body.style.cursor = 'ns-resize';
                      document.addEventListener('mousemove', handleMouseMove);
                      document.addEventListener('mouseup', handleMouseUp);
                      e.preventDefault();
                  });
                  const handleMouseMove = (e) => {
                      if (!isDragging) return;
                      const deltaY = startY - e.clientY;
                      const newValue = Math.max(0, Math.min(startValue + (deltaY * sensitivity), (currentVideoDuration ? currentVideoDuration - 0.01 : 0)));
                      timeInput.value = newValue.toFixed(2);
                      timeFormatted.value = formatTime(newValue);
                      handleFineTuneChange(parseInt(timeInput.dataset.index), newValue);
                  };
                  const handleMouseUp = () => {
                      if (!isDragging) return;
                      isDragging = false;
                      document.body.style.cursor = '';
                      document.removeEventListener('mousemove', handleMouseMove);
                      document.removeEventListener('mouseup', handleMouseUp);
                  };

                  container.addEventListener('mouseenter', () => {
                      container.classList.add('highlight');
                      const cell = contactSheetPreviewElement?.querySelector(`.grid-cell[data-index="${i}"]`);
                      if (cell) cell.classList.add('input-hover-highlight'); // Use specific class for input hover
                  });
                  container.addEventListener('mouseleave', () => {
                       container.classList.remove('highlight');
                       const cell = contactSheetPreviewElement?.querySelector(`.grid-cell[data-index="${i}"]`);
                       if (cell) cell.classList.remove('input-hover-highlight');
                  });


                  wrapper.appendChild(timeInput); wrapper.appendChild(timeFormatted); container.appendChild(wrapper); contactSheetControlsElement.appendChild(container);
              }
             // contactSheetControlsElement.style.display = 'grid'; // Display is now handled above
          };

        // Main function to generate or update the sheet
        const generateContactSheet = async () => {
             if (!video?.src || processingActive || video.readyState < video.HAVE_METADATA) {
                 alert("Please load a video file first or wait for it to be ready.");
                 return;
             }
             setProcessingUI('contactSheet');
             // contactSheetBlob = null; // Clear old final blob *before* starting processing

             const activeGridSizeTab = $$('.grid-size-tab.active')[0];
             const rows = parseInt(activeGridSizeTab?.getAttribute('data-rows') || 4);
             const cols = parseInt(activeGridSizeTab?.getAttribute('data-cols') || 5);
             const numSamples = rows * cols;
             const isLargeGrid = rows > 6 || cols > 6;

             // --- Read timestamps from current input fields ---
             // This ensures manual changes are captured when Update is clicked
             const sampleTimestamps = [];
             console.log("Reading current input values for sheet generation.");
             for (let i = 0; i < numSamples; i++) {
                const input = $(`timeInput_${i}`);
                // If grid is large, inputs don't exist, calculate default
                const existingValue = !isLargeGrid && input ? parseFloat(input.value) : NaN;

                 if (isLargeGrid || !input || isNaN(existingValue)) {
                     // Calculate default if large grid or input is invalid/missing
                     const startPercent = 0.1; const endPercent = 0.9;
                     const step = numSamples > 1 ? (endPercent - startPercent) / (numSamples - 1) : 0;
                     const percent = startPercent + (i * step);
                     const time = Math.max(0.01, Math.min(percent * currentVideoDuration, currentVideoDuration ? currentVideoDuration - 0.01 : 0.01));
                     sampleTimestamps.push(time);
                     // Update visual input only if it exists and we calculated default
                     if (!isLargeGrid && input && isNaN(existingValue)) {
                         const timeFormatted = $(`timeFormatted_${i}`);
                         input.value = time.toFixed(2);
                         if (timeFormatted) timeFormatted.value = formatTime(time);
                         console.warn(`Calculated default for invalid input at index ${i}.`);
                     }
                 } else {
                    // Use the valid value from the input
                    sampleTimestamps.push(Math.max(0.01, Math.min(existingValue, currentVideoDuration ? currentVideoDuration - 0.01 : 0.01)));
                 }
             }
             // --- End Timestamp Reading ---

             if (sampleTimestamps.length === 0 || sampleTimestamps.length !== numSamples) {
                 alert("Error: Could not calculate timestamps for contact sheet.");
                 resetProcessingUI('contactSheet');
                 return;
             }

             // Clear visual cells and reset preview data *before* sampling
             $$('.grid-cell', contactSheetPreviewElement).forEach(cell => {
                 cell.classList.remove('filled');
                 const img = cell.querySelector('img'); if (img) img.src = '';
                 const overlay = cell.querySelector('.screenshot-overlay'); if (overlay) overlay.remove();
                 delete cell.dataset.blobUrl;
             });
             contactSheetPreviewData.forEach(data => { if (data?.blobUrl) URL.revokeObjectURL(data.blobUrl); });
             contactSheetPreviewData = new Array(numSamples).fill(null);
             contactSheetBlob = null; // Always clear the old final blob before regeneration


             try {
                 // Don't remove: Janky fix to address a timing issue where the first frame capture would fail
                 const preCaptureTime = 0.1;
                 console.log("Performing pre-capture seek...");
                 await new Promise((resolve, reject) => {
                     captureFrameAtTime(preCaptureTime, (blob) => {
                         if (blob) {
                             URL.revokeObjectURL(URL.createObjectURL(blob));
                             resolve();
                         } else {
                             console.warn("Pre-capture failed, proceeding anyway...");
                             resolve();
                         }
                     }, { videoElement: video, timeout: 3000 });
                 });

                 if (cancelExtractionRequested) { resetProcessingUI('contactSheet'); return; }

                 currentSamplingProcess = sampleVideoFrames({
                     videoElement: video, sampleTimestamps, outputType: 'blob', useCrop: removeBarsEnabled,
                     processFrameCallback: (blob, timestamp, index) => {
                         // Index corresponds to the position in sampleTimestamps
                         if (index >= 0 && index < contactSheetPreviewData.length) {
                             updatePreviewCell(index, blob, timestamp); // Updates preview AND data array
                         } else { console.warn(`Invalid index ${index} received in processFrameCallback`); }
                     },
                     onProgressCallback: (progress) => { if (progressBarFillContactSheet) progressBarFillContactSheet.style.width = `${progress}%`; },
                     onCompleteCallback: async (collectedData) => { // collectedData is just confirmation
                         if (cancelExtractionRequested) { console.log("Contact Sheet generation cancelled."); resetProcessingUI('contactSheet'); return; }
                         if (progressBarFillContactSheet) progressBarFillContactSheet.style.width = `100%`;

                         const validPreviewData = contactSheetPreviewData.filter(data => data?.blob);

                         if (validPreviewData.length === 0) {
                            console.error("Failed to collect any valid frames for final contact sheet render.");
                            alert("Failed to capture frames for the contact sheet.");
                            resetProcessingUI('contactSheet');
                            return;
                         }

                         // --- Start Final Image Compositing ---
                         const renderCols = parseInt($$('.grid-size-tab.active')[0]?.getAttribute('data-cols') || 5);
                         const renderRows = parseInt($$('.grid-size-tab.active')[0]?.getAttribute('data-rows') || 4);
                         const targetWidth = 1920;
                         const cellWidth = Math.floor(targetWidth / renderCols);

                         const imageLoadPromises = validPreviewData.map(({ blob, timestamp, blobUrl }, index) => new Promise((resolve) => {
                             const img = new Image();
                             // Find the original index in the full previewData array based on the blobUrl
                             const originalIndex = contactSheetPreviewData.findIndex(d => d?.blobUrl === blobUrl);
                             img.onload = () => resolve({img, tempUrl: blobUrl, aspectRatio: img.width / img.height, originalIndex });
                             img.onerror = (err) => { console.warn(`Failed to load image for contact sheet cell (ts: ${timestamp})`); resolve(null); };
                             img.src = blobUrl;
                         }));

                         const loadedImageResults = (await Promise.all(imageLoadPromises)).filter(r => r !== null);

                         if (loadedImageResults.length === 0) {
                             console.error("No images could be loaded for the contact sheet.");
                             resetProcessingUI('contactSheet');
                             return;
                         }

                         const rowHeights = new Array(renderRows).fill(0);
                         loadedImageResults.forEach(result => {
                             if (result.originalIndex === -1) return;
                             const row = Math.floor(result.originalIndex / renderCols);
                             if (row < rowHeights.length) {
                                 const heightForCell = cellWidth / result.aspectRatio;
                                 rowHeights[row] = Math.max(rowHeights[row], heightForCell);
                             }
                         });
                         const totalHeight = rowHeights.reduce((sum, height) => sum + Math.ceil(height), 0);
                         const rowOffsets = [];
                         let currentOffset = 0;
                         for (const height of rowHeights) {
                             rowOffsets.push(currentOffset);
                             currentOffset += Math.ceil(height);
                         }

                         const ctx = contactSheetCanvas.getContext('2d'); if (!ctx) throw new Error("Could not get contact sheet canvas context");
                         contactSheetCanvas.width = targetWidth;
                         contactSheetCanvas.height = totalHeight;
                         ctx.fillStyle = 'black'; ctx.fillRect(0, 0, targetWidth, totalHeight);

                         let imagesDrawn = 0;
                         loadedImageResults.forEach(result => {
                            if (result.originalIndex === -1) return;
                             const { img, aspectRatio, originalIndex } = result;
                             const row = Math.floor(originalIndex / renderCols);
                             const col = originalIndex % renderCols;
                             const drawX = col * cellWidth;
                             const drawY = rowOffsets[row];
                             const drawHeight = Math.ceil(rowHeights[row]);
                             const drawWidth = cellWidth;

                             const actualImageHeight = drawWidth / aspectRatio;
                             const actualImageWidth = drawHeight * aspectRatio;
                             let finalDrawWidth, finalDrawHeight, offsetX, offsetY;
                             if (actualImageHeight <= drawHeight) { finalDrawWidth = drawWidth; finalDrawHeight = actualImageHeight; offsetX = drawX; offsetY = drawY + (drawHeight - finalDrawHeight) / 2; }
                             else { finalDrawHeight = drawHeight; finalDrawWidth = actualImageWidth; offsetX = drawX + (drawWidth - finalDrawWidth) / 2; offsetY = drawY; }

                             try { ctx.drawImage(img, offsetX, offsetY, finalDrawWidth, finalDrawHeight); imagesDrawn++; }
                             catch (drawError) { console.error(`Error drawing image for cell ${originalIndex}:`, drawError); }
                             // No need to revoke tempUrl here
                         });
                         // --- End Final Image Compositing ---

                        if (imagesDrawn > 0) {
                            contactSheetCanvas.toBlob((finalBlob) => {
                                if (finalBlob) {
                                    contactSheetBlob = finalBlob;
                                    const activeTab = $$('.grid-size-tab.active')[0];
                                    if (activeTab) { activeTab.classList.add('completed'); const { rows, cols } = activeTab.dataset; const cacheKey = `${cols}x${rows}`; gridCache[cacheKey] = { data: [...contactSheetPreviewData], blob: finalBlob, completed: true }; }
                                     // Re-enable buttons and remove update indicators
                                    if (downloadContactSheetButton) { downloadContactSheetButton.disabled = false; downloadContactSheetButton.classList.remove('needs-update'); downloadContactSheetButton.title = ''; }
                                    if (previewContactSheetButton) { previewContactSheetButton.disabled = false; previewContactSheetButton.classList.remove('needs-update'); previewContactSheetButton.title = '';}
                                } else {
                                    console.error("Failed to generate final contact sheet blob.");
                                    contactSheetBlob = null;
                                }
                                resetProcessingUI('contactSheet');
                            }, 'image/jpeg', 0.9);
                        } else {
                            console.error("No images drawn to contact sheet.");
                            contactSheetBlob = null;
                            resetProcessingUI('contactSheet');
                        }
                     },
                     onErrorCallback: (error) => {
                        console.error("Error during contact sheet frame sampling:", error);
                        alert(`Error generating contact sheet: ${error.message}`);
                        resetProcessingUI('contactSheet');
                     }
                 });
             } catch (error) {
                 console.error("Failed to start contact sheet generation:", error);
                 alert(`Error starting contact sheet generation: ${error.message}`);
                 resetProcessingUI('contactSheet');
             }
         };


        if (pageTitle) pageTitle.addEventListener('click', () => window.location.reload());

        if (videoInput) videoInput.addEventListener('change', (event) => { const file = event.target.files[0]; if (file) handleFileLoad(file); });
        if (dropZone) {
             dropZone.addEventListener('dragover', (e) => { e.preventDefault(); if (!dropZone.classList.contains('file-loaded')) dropZone.classList.add('hover'); });
             dropZone.addEventListener('dragleave', (e) => { e.preventDefault(); dropZone.classList.remove('hover'); });
             dropZone.addEventListener('drop', (e) => { e.preventDefault(); dropZone.classList.remove('hover'); const file = e.dataTransfer.files[0]; if (file?.type.startsWith('video/')) handleFileLoad(file); else alert("Please drop a valid video file."); });
             dropZone.addEventListener('click', (e) => { if (dropZone.classList.contains('file-loaded')) { if (selectFileButton && !selectFileButton.contains(e.target) && videoInput) videoInput.click(); } else { if (initialSelectFileButton && !initialSelectFileButton.contains(e.target) && videoInput) videoInput.click(); } });
        }
        if (selectFileButton) selectFileButton.addEventListener('click', (e) => { e.stopPropagation(); if(videoInput) videoInput.click(); });
        if (initialSelectFileButton) initialSelectFileButton.addEventListener('click', (e) => { e.stopPropagation(); if(videoInput) videoInput.click(); });

        if (modeTabs.length > 0 && modeContentDiv) {
            modeTabs.forEach(tab => {
                tab.addEventListener('click', () => {
                   if (processingActive) return;
                   const newMode = tab.getAttribute('data-mode'); if (!newMode || !modeContentDiv) return; currentMode = newMode;
                   modeTabs.forEach(t => t.classList.remove('active')); tab.classList.add('active');
                   $$('.mode-content > div', modeContentDiv).forEach(contentDiv => { contentDiv.classList.toggle('active', contentDiv.id === `${newMode}Mode`); });
                   outputColumn.classList.toggle('show-contact-sheet', newMode === 'contactSheet');

                   Object.values(buttonGroups).forEach(group => { if (group) group.style.display = 'none'; });
                   if (buttonGroups[newMode]) buttonGroups[newMode].style.display = 'flex';

                   Object.values(progressBarElements).forEach(bar => { if (bar) bar.style.display = 'none'; });

                   processingActive = false;
                   cancelExtractionRequested = false;
                   if (currentSamplingProcess?.cancel) currentSamplingProcess.cancel();

                   if (newMode === 'contactSheet') {
                       const activeGridSizeTab = $$('.grid-size-tab.active')[0];
                       const rows = parseInt(activeGridSizeTab?.getAttribute('data-rows') || 4);
                       const cols = parseInt(activeGridSizeTab?.getAttribute('data-cols') || 5);
                       const cacheKey = `${cols}x${rows}`;
                       const cachedGrid = gridCache[cacheKey];

                       initContactSheetPreview(rows, cols); // Always init preview grid

                        // Show/hide time inputs based on current grid size
                        if (updateContactSheetControlsVisibility(rows, cols)) {
                            if (cachedGrid?.data) {
                                contactSheetPreviewData = cachedGrid.data;
                                contactSheetBlob = cachedGrid.blob;
                                generateTimeInputs(rows, cols); // Generate inputs *after* potentially restoring data

                                contactSheetPreviewData.forEach((data, index) => {
                                    if (data?.blob) {
                                        const blobUrl = URL.createObjectURL(data.blob);
                                        contactSheetPreviewData[index].blobUrl = blobUrl; // Update blobUrl in restored data
                                        updatePreviewCell(index, data.blob, data.timestamp);
                                        $(`timeInput_${index}`).value = data.timestamp.toFixed(2);
                                        $(`timeFormatted_${index}`).value = formatTime(data.timestamp);
                                    }
                                });
                            } else {
                                contactSheetPreviewData = new Array(rows * cols).fill(null);
                                contactSheetBlob = null;
                                generateTimeInputs(rows, cols); // Generate default inputs
                            }
                        } else {
                            // If inputs are hidden, ensure data array is correct size but has no blobs
                            contactSheetPreviewData = new Array(rows * cols).fill(null);
                            contactSheetBlob = null;
                         }

                         activeGridSizeTab?.classList.toggle('completed', cachedGrid?.completed ?? false);
                         if (processContactSheetButton) processContactSheetButton.textContent = cachedGrid?.completed ? 'Generate/Update Sheet' : 'Generate/Update Sheet';
                         if (downloadContactSheetButton) downloadContactSheetButton.disabled = !contactSheetBlob;
                         if (previewContactSheetButton) previewContactSheetButton.disabled = !contactSheetBlob;

                   } else {
                       // Clear general screenshot area if switching away from contact sheet
                        $$('.screenshot-container', screenshotsDiv).forEach(container => { if (container.dataset.blobUrl) URL.revokeObjectURL(container.dataset.blobUrl); });
                        if(screenshotsDiv) screenshotsDiv.innerHTML = '';
                        screenshotBlobs = []; // Clear auto/smart blobs
                        // Keep manual blobs unless explicitly cleared
                   }

                   resetProcessingUI(newMode); // Reset buttons based on video presence
                   updateImageCount();

                   $$(`#${newMode}Mode input[type="range"]`).forEach(updateSliderBackground);
                   updateImageCount(); // Ensure count is updated after mode switch
                });
            });
        }

        const updateContactSheetControlsVisibility = (rows, cols) => {
             const isLargeGrid = rows > 6 || cols > 6;
             contactSheetControlsElement.style.display = isLargeGrid ? 'none' : 'grid';
             largeGridDisclaimer.style.display = isLargeGrid ? 'block' : 'none';
             return !isLargeGrid; // Return true if inputs should be generated
        };


        if (gridSizeTabs.length > 0) {
            gridSizeTabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    if (processingActive) return;
                    const currentActiveTab = $$('.grid-size-tab.active')[0];

                    let rows = parseInt(tab.getAttribute('data-rows') || 4);
                    let cols = parseInt(tab.getAttribute('data-cols') || 5);
                    const isCustom = tab.textContent.trim() === 'Custom';
                     if (customGridControls) customGridControls.style.display = isCustom ? 'block' : 'none';

                    if (isCustom && customGridRows && customGridCols) {
                        rows = Math.max(parseInt(customGridRows.value) || 2, 1);
                        cols = Math.max(parseInt(customGridCols.value) || 3, 1);
                         customGridRows.value = rows; customGridCols.value = cols;
                        tab.setAttribute('data-rows', rows); tab.setAttribute('data-cols', cols);
                    }
                    if (isNaN(rows) || isNaN(cols)) return;

                    const newCacheKey = `${cols}x${rows}`;

                    if (currentActiveTab && currentActiveTab !== tab) {
                        const prevRows = parseInt(currentActiveTab.getAttribute('data-rows'));
                        const prevCols = parseInt(currentActiveTab.getAttribute('data-cols'));
                        const prevCacheKey = `${prevCols}x${prevRows}`;
                         if (contactSheetPreviewData.some(item => item !== null) || contactSheetBlob) {
                              gridCache[prevCacheKey] = { data: [...contactSheetPreviewData], blob: contactSheetBlob, completed: currentActiveTab.classList.contains('completed') };
                               contactSheetPreviewData.forEach(item => { if (item?.blobUrl) URL.revokeObjectURL(item.blobUrl); });
                          }
                    }

                    gridSizeTabs.forEach(t => t.classList.remove('active')); tab.classList.add('active');

                    const cachedGrid = gridCache[newCacheKey];
                    clearContactSheetPreview(true); // Clear first
                    initContactSheetPreview(rows, cols); // Initialize preview grid

                     // Show/hide controls *before* trying to generate inputs
                     const showInputs = updateContactSheetControlsVisibility(rows, cols);

                    if (cachedGrid?.data) {
                        contactSheetPreviewData = cachedGrid.data;
                        contactSheetBlob = cachedGrid.blob;
                         if (showInputs) {
                            generateTimeInputs(rows, cols); // Generate inputs only if not too large
                         }

                        contactSheetPreviewData.forEach((data, index) => {
                            if (data?.blob) {
                                const blobUrl = URL.createObjectURL(data.blob);
                                contactSheetPreviewData[index].blobUrl = blobUrl; // Update blobUrl in restored data
                                updatePreviewCell(index, data.blob, data.timestamp);
                                // Update inputs only if they exist
                                const timeInput = $(`timeInput_${index}`);
                                const timeFormatted = $(`timeFormatted_${index}`);
                                if (timeInput) timeInput.value = data.timestamp.toFixed(2);
                                if (timeFormatted) timeFormatted.value = formatTime(data.timestamp);
                            }
                        });
                        tab.classList.toggle('completed', cachedGrid.completed);
                        if (processContactSheetButton) processContactSheetButton.textContent = cachedGrid.completed ? 'Generate/Update Sheet' : 'Generate/Update Sheet';

                    } else {
                         contactSheetPreviewData = new Array(rows * cols).fill(null);
                         contactSheetBlob = null;
                         if (showInputs) {
                            generateTimeInputs(rows, cols); // Generate default inputs only if not too large
                         }
                         tab.classList.remove('completed');
                         if (processContactSheetButton) processContactSheetButton.textContent = 'Generate/Update Sheet';
                    }

                    if (downloadContactSheetButton) downloadContactSheetButton.disabled = !contactSheetBlob;
                    if (previewContactSheetButton) previewContactSheetButton.disabled = !contactSheetBlob;
                     // Reset update button style on grid change
                     if (processContactSheetButton) {
                        processContactSheetButton.classList.remove('needs-update');
                        processContactSheetButton.style.background = '';
                     }
                });
            });
        }

        if (customGridCols && customGridRows) {
             const updateCustomGrid = debounce(() => {
                  if (processingActive) return;
                  const customTab = Array.from(gridSizeTabs).find(tab => tab.textContent.trim() === 'Custom');
                  if (!customTab || !customTab.classList.contains('active')) return;

                  const rows = Math.max(parseInt(customGridRows.value) || 2, 1);
                  const cols = Math.max(parseInt(customGridCols.value) || 3, 1);
                  customGridRows.value = rows; customGridCols.value = cols;

                  customTab.click();

             }, 500);
             customGridCols.addEventListener('input', updateCustomGrid);
             customGridRows.addEventListener('input', updateCustomGrid);
         }

        // Setup global format controls
        initGlobalFormatControls();
        // Setup mode-specific sliders
        setupSlider(intervalInput, intervalValue, 's');
        setupSlider(histThresholdInput, histThresholdValue, '');
        setupSlider(pixelThresholdInput, pixelThresholdValue, '');

        if (removeBarsToggle) removeBarsToggle.addEventListener('change', (e) => {
            removeBarsEnabled = e.target.checked;
            if (removeBarsEnabled && video?.src && video.readyState >= 2) {
                 detectCropBoundariesMulti(() => { updateDropZoneThumbnail(); updateFileInfoDisplay(); });
            } else if (!removeBarsEnabled) {
                cropData = null; updateDropZoneThumbnail(); updateFileInfoDisplay();
            }
        });

        if (smartAlgoTabs.length > 0) {
            const updateThresholdSliders = (algo) => {
                if(histThresholdSettings) histThresholdSettings.style.display = (algo === 'histogram') ? 'flex' : 'none';
                if(pixelThresholdSettings) pixelThresholdSettings.style.display = (algo === 'pixeldiff') ? 'flex' : 'none';
                // Also toggle the disclaimer note visibility
                pixelDiffDisclaimer.style.display = (algo === 'pixeldiff') ? 'block' : 'none';
                $$('#autoSmartMode .disclaimer-note:not(#pixelDiffDisclaimer)')[0].style.display = (algo === 'histogram') ? 'block' : 'none';


                requestAnimationFrame(() => {
                    if(histThresholdInput && algo === 'histogram') updateSliderBackground(histThresholdInput);
                    if(pixelThresholdInput && algo === 'pixeldiff') updateSliderBackground(pixelThresholdInput);
                });
            };
            let initialAlgo = 'histogram'; $$('.smart-tab').forEach(tab => { if (tab.classList.contains('active')) initialAlgo = tab.getAttribute('data-algo') || 'histogram'; });
             smartAlgoTabs.forEach(tab => {
                 tab.addEventListener('click', () => {
                     if (processingActive) return; const algo = tab.getAttribute('data-algo'); if(!algo) return; smartAlgorithm = algo;
                     $$('.smart-tab').forEach(t => t.classList.remove('active')); tab.classList.add('active');
                     updateThresholdSliders(algo);
                 });
             });
             smartAlgorithm = initialAlgo;
             updateThresholdSliders(initialAlgo);
         }


        const startAutoExtraction = () => {
             if (!video?.src || processingActive || !intervalInput || video.readyState < video.HAVE_METADATA) {
                 alert("Please load a video file first or wait for it to be ready.");
                 return;
             }
             setProcessingUI('auto');
             screenshotBlobs = [];
             if(screenshotsDiv) screenshotsDiv.innerHTML = '';
             updateImageCount();
             contactSheetBlob = null;

             const interval = parseFloat(intervalInput.value); if (isNaN(interval) || interval <= 0) { resetProcessingUI('auto'); return; }

             const startExtraction = () => {
                 let currentTime = 0.1; const totalDuration = currentVideoDuration; let frameTimeoutId = null; let isCancelled = false;
                 currentSamplingProcess = { cancel: () => { isCancelled = true; cancelExtractionRequested = true; if (frameTimeoutId) clearTimeout(frameTimeoutId); resetProcessingUI('auto'); } }; // Reset UI on cancel

                 function processNextFrame() {
                     if (isCancelled || cancelExtractionRequested || currentTime > totalDuration + 0.1) { if(!isCancelled) resetProcessingUI('auto'); return; } // Check cancel before processing
                     const timestamp = currentTime;
                     if (progressBarFillAuto) progressBarFillAuto.style.width = `${Math.min((currentTime / totalDuration) * 100, 100)}%`;

                     captureFrameAtTime(timestamp, (blob) => {
                         if (isCancelled || cancelExtractionRequested) { return; }
                         if (blob) {
                            createScreenshotContainer(blob, timestamp, screenshotBlobs);
                            updateImageCount();
                         }
                         if (currentTime <= totalDuration + 0.1) {
                              currentTime += interval;
                              frameTimeoutId = setTimeout(processNextFrame, 0);
                         } else {
                              resetProcessingUI('auto');
                         }
                     });
                 }
                 frameTimeoutId = setTimeout(processNextFrame, 0);
             };
             startExtraction();
         };

        const startSmartExtraction = () => {
            if (!video?.src || processingActive || video.readyState < video.HAVE_METADATA) {
                alert("Please load a video file first or wait for it to be ready.");
                return;
            }
            setProcessingUI('autoSmart');
            screenshotBlobs = [];
            if(screenshotsDiv) screenshotsDiv.innerHTML = '';
            updateImageCount();
            contactSheetBlob = null;

            const smartInterval = 0.5;
            const sampleFactor = 8;
            const histThreshold = histThresholdInput ? parseFloat(histThresholdInput.value) : 0.35;
            const pixelThreshold = pixelThresholdInput ? parseFloat(pixelThresholdInput.value) : 35;

            const startExtraction = () => {
                 let currentTime = 0.1; const totalDuration = currentVideoDuration; let previousImageData = null; let previousHist = null; let previousPixelData = null;
                 let frameTimeoutId = null; let isCancelled = false;
                 currentSamplingProcess = { cancel: () => { isCancelled = true; cancelExtractionRequested = true; if (frameTimeoutId) clearTimeout(frameTimeoutId); resetProcessingUI('autoSmart'); } }; // Reset UI on cancel

                function processNextSmartFrame() {
                    if (isCancelled || cancelExtractionRequested || currentTime > totalDuration + 0.1) { if(!isCancelled) resetProcessingUI('autoSmart'); return; }
                    const timestamp = currentTime;
                     if (progressBarFillSmart) progressBarFillSmart.style.width = `${Math.min((currentTime / totalDuration) * 100, 100)}%`;

                    captureFrameAtTime(timestamp, (blob) => {
                        if (isCancelled || cancelExtractionRequested) { return; }

                        if (!blob) {
                            if (currentTime <= totalDuration + 0.1) {
                                currentTime += smartInterval; frameTimeoutId = setTimeout(processNextSmartFrame, 0);
                            } else { resetProcessingUI('autoSmart'); }
                            return;
                        }

                        const tempCanvas = document.createElement('canvas'); const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
                        const img = new Image();
                         const blobUrl = URL.createObjectURL(blob);
                         img.src = blobUrl;

                        img.onload = () => {
                             URL.revokeObjectURL(blobUrl);
                             if (isCancelled || cancelExtractionRequested) { return; }

                             try {
                                 tempCanvas.width = img.width; tempCanvas.height = img.height; if (!tempCtx) throw new Error("Could not get temp canvas context"); tempCtx.drawImage(img, 0, 0);
                                 const currentImageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);

                                 let captureThisFrame = false;
                                 if (!previousImageData) {
                                     captureThisFrame = true;
                                     if (smartAlgorithm === "histogram") previousHist = computeHistogram(currentImageData, sampleFactor);
                                     if (smartAlgorithm === 'pixeldiff') previousPixelData = currentImageData.data.slice();
                                 } else {
                                     if (smartAlgorithm === "histogram") {
                                         const currentHist = computeHistogram(currentImageData, sampleFactor);
                                         if (!previousHist || histogramDifference(currentHist, previousHist) >= histThreshold) { captureThisFrame = true; previousHist = currentHist; }
                                     } else if (smartAlgorithm === "pixeldiff") {
                                         const diff = computePixelDiff(currentImageData.data, previousPixelData, sampleFactor);
                                         if (diff >= pixelThreshold) { captureThisFrame = true; previousPixelData = currentImageData.data.slice(); }
                                     }
                                 }

                                 if (captureThisFrame) {
                                     createScreenshotContainer(blob, timestamp, screenshotBlobs);
                                     updateImageCount();
                                     previousImageData = currentImageData;
                                 }

                                 if (currentTime <= totalDuration + 0.1) { currentTime += smartInterval; frameTimeoutId = setTimeout(processNextSmartFrame, 0); }
                                 else resetProcessingUI('autoSmart');

                             } catch (error) {
                                 console.error("[Process Smart] Error:", error);
                                 if (currentTime <= totalDuration + 0.1) { currentTime += smartInterval; frameTimeoutId = setTimeout(processNextSmartFrame, 0); }
                                 else resetProcessingUI('autoSmart');
                             }
                        };

                        img.onerror = () => {
                             URL.revokeObjectURL(blobUrl);
                            console.error("[Process Smart] Failed to load blob into image");
                            if (currentTime <= totalDuration + 0.1) { currentTime += smartInterval; frameTimeoutId = setTimeout(processNextSmartFrame, 0); }
                            else resetProcessingUI('autoSmart');
                        };
                    });
                }
                 frameTimeoutId = setTimeout(processNextSmartFrame, 0);
            };
            startExtraction();
        };

        if (extractManualButton) extractManualButton.addEventListener('click', () => {
             if (!manualVideo?.src || manualVideo.readyState < 1 || processingActive || !canvas) return;
             try {
                 const { type, quality } = getCurrentFormatSettings();
                 const ctx = canvas.getContext('2d'); if(!ctx) throw new Error("Canvas context not available");
                 const effectiveCropData = removeBarsEnabled && cropData ? cropData : { cropX: 0, cropY: 0, cropWidth: manualVideo.videoWidth, cropHeight: manualVideo.videoHeight };
                 if (effectiveCropData.cropWidth <= 0 || effectiveCropData.cropHeight <= 0) throw new Error("Invalid video or crop dimensions for Save Frame.");

                 canvas.width = effectiveCropData.cropWidth; canvas.height = effectiveCropData.cropHeight;
                 ctx.drawImage(manualVideo, effectiveCropData.cropX, effectiveCropData.cropY, effectiveCropData.cropWidth, effectiveCropData.cropHeight, 0, 0, canvas.width, canvas.height);

                 canvas.toBlob((blob) => {
                     if (blob) {
                         const url = URL.createObjectURL(blob);
                         const tempLink = document.createElement('a'); tempLink.href = url;
                         const extension = getFileExtensionFromType(type);
                         tempLink.download = `quick_frame_${formatTime(manualVideo.currentTime).replace(':','-')}.${extension}`;
                         document.body.appendChild(tempLink); tempLink.click(); document.body.removeChild(tempLink); URL.revokeObjectURL(url);
                     }
                 }, type, quality);
             } catch(error) { console.error("[Manual Save Frame] Error:", error); alert("An error occurred during Save Frame: " + error.message); }
         });

        if (addManualButton) addManualButton.addEventListener('click', () => {
             // Scissors icon animation only for Manual Cut Frame button
             addManualButton.classList.add('cutting'); setTimeout(() => { addManualButton.classList.remove('cutting'); }, 300);

             if (!manualVideo?.src || manualVideo.readyState < 1 || processingActive || !canvas) return;

             try {
                 const { type, quality } = getCurrentFormatSettings();
                 const ctx = canvas.getContext('2d'); if(!ctx) throw new Error("Canvas context not available");
                 const effectiveCropData = removeBarsEnabled && cropData ? cropData : { cropX: 0, cropY: 0, cropWidth: manualVideo.videoWidth, cropHeight: manualVideo.videoHeight };
                 if (effectiveCropData.cropWidth <= 0 || effectiveCropData.cropHeight <= 0) throw new Error("Invalid video or crop dimensions for Manual Add.");

                 canvas.width = effectiveCropData.cropWidth; canvas.height = effectiveCropData.cropHeight;
                 ctx.drawImage(manualVideo, effectiveCropData.cropX, effectiveCropData.cropY, effectiveCropData.cropWidth, effectiveCropData.cropHeight, 0, 0, canvas.width, canvas.height);

                 const timestamp = manualVideo.currentTime;
                 canvas.toBlob((blob) => {
                     if (blob) {
                        createScreenshotContainer(blob, timestamp, manualScreenshotBlobs);
                        updateImageCount();
                     }
                 }, type, quality);
             } catch(error) { console.error("[Manual Add] Error:", error); alert("An error occurred while adding the frame: " + error.message); }
         });

        if(downloadAllButton) downloadAllButton.addEventListener('click', () => { if (!processingActive) downloadBlobsAsZip(screenshotBlobs.filter(item => item?.blob), "auto_screenshots"); });
        if(downloadAllSmartButton) downloadAllSmartButton.addEventListener('click', () => { if (!processingActive) downloadBlobsAsZip(screenshotBlobs.filter(item => item?.blob), "smart_screenshots"); });
        if(downloadManualButton) downloadManualButton.addEventListener('click', () => { if (!processingActive) downloadBlobsAsZip(manualScreenshotBlobs.filter(item => item?.blob), "manual_screenshots"); });

        if(previewContactSheetButton) previewContactSheetButton.addEventListener('click', () => {
             if (!processingActive && contactSheetBlob) {
                 const url = URL.createObjectURL(contactSheetBlob); window.open(url, '_blank');
             } else { alert("Please generate or update the contact sheet first."); }
         });
        if(downloadContactSheetButton) downloadContactSheetButton.addEventListener('click', () => {
             if (!processingActive && contactSheetBlob) {
                 const url = URL.createObjectURL(contactSheetBlob);
                 const tempLink = document.createElement('a'); tempLink.href = url;
                 tempLink.download = `contact_sheet_${uploadedFile?.name.split('.')[0] || 'video'}.jpg`;
                 document.body.appendChild(tempLink); tempLink.click(); document.body.removeChild(tempLink); URL.revokeObjectURL(url);
             } else { alert("Please generate or update the contact sheet first."); }
         });

        if (clearScreenshotsButton) clearScreenshotsButton.addEventListener('click', () => {
             if (processingActive) return;
             const hasAnyOutput = (screenshotBlobs.length + manualScreenshotBlobs.length > 0) || contactSheetPreviewData.some(d => d !== null) || contactSheetBlob;
             if (hasAnyOutput && confirm("Are you sure you want to clear all generated output (screenshots and contact sheet preview)?")) {
                 screenshotBlobs.concat(manualScreenshotBlobs).forEach(item => { if(item?.blobUrl) URL.revokeObjectURL(item.blobUrl); });
                 if(screenshotsDiv) screenshotsDiv.innerHTML = '';
                 screenshotBlobs = []; manualScreenshotBlobs = [];

                 clearContactSheetPreview(true);
                 contactSheetBlob = null;

                 Object.keys(gridCache).forEach(key => { gridCache[key] = { data: null, blob: null, completed: false }; });
                 $$('.grid-size-tab').forEach(tab => tab.classList.remove('completed'));

                 if(downloadContactSheetButton) downloadContactSheetButton.disabled = true;
                 if(previewContactSheetButton) previewContactSheetButton.disabled = true;
                 if(processContactSheetButton) processContactSheetButton.textContent = 'Generate/Update Sheet';
                 updateImageCount();
             }
        });

        // Initial setup calls
        currentMode = $$('.mode-tab.active')[0]?.getAttribute('data-mode') || 'manual';
        smartAlgorithm = $$('.smart-tab.active')[0]?.getAttribute('data-algo') || 'histogram';
        $$('input[type="range"]').forEach(updateSliderBackground);

         if (buttonGroups[currentMode]) {
            Object.values(buttonGroups).forEach(group => { if (group) group.style.display = 'none'; });
            buttonGroups[currentMode].style.display = 'flex';
         }

        resetProcessingUI('all');
        updateDropZoneUI(false, null);
        updateImageCount();
        initGlobalFormatControls();

        const initialActiveGridTab = $$('.grid-size-tab.active')[0];
        if (initialActiveGridTab) {
            const rows = parseInt(initialActiveGridTab.getAttribute('data-rows') || 4);
            const cols = parseInt(initialActiveGridTab.getAttribute('data-cols') || 5);
            initContactSheetPreview(rows, cols);
             if (updateContactSheetControlsVisibility(rows, cols)) {
                 generateTimeInputs(rows, cols);
             }

            if (initialActiveGridTab.textContent.trim() === 'Custom' && customGridControls) {
                customGridControls.style.display = 'block';
                if (customGridRows && customGridCols) {
                    customGridRows.value = initialActiveGridTab.getAttribute('data-rows') || '2';
                    customGridCols.value = initialActiveGridTab.getAttribute('data-cols') || '3';
                }
            }
        } else {
             initContactSheetPreview(4, 5);
             generateTimeInputs(4, 5);
        }


      } catch (error) { console.error("Error during script execution:", error); const errorDisplay = document.createElement('div'); errorDisplay.textContent = `Initialization Error: ${error.message}. Please refresh or check console (F12).`; errorDisplay.style.cssText = 'color: var(--danger-color); padding: 1rem; background-color: var(--bg-secondary); border: 1px solid var(--danger-color); margin: 1rem; border-radius: var(--border-radius-md);'; document.body.prepend(errorDisplay); }
    });
  </script>

</body>
</html>